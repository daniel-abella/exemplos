<?xml version="1.0" encoding="UTF-8"?><!-- edited with XMLSPY v2004 rel. 3 U (http://www.xmlspy.com) by junio (cs) --><?xml-stylesheet type="text/xsl" href="questoes.xslt"?><Avaliacao xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="questoes.xsd">	<identificacao>		<titulo>Linguagem de Programação Java</titulo>		<copyright>Fábio Nogueira de Lucena</copyright>		<versao>1.0</versao>	</identificacao>	<historico>		<evento data="2003-10-07">			<comentario>Atingido o total de 2071 questões!</comentario>		</evento>		<evento data="2003-09-01">			<comentario>Atingida a marca de 1540 questões em Java.</comentario>		</evento>		<evento data="2003-08-09">			<comentario>Ultrapassado o total de 1000 questões em Java.                Há motivo para comemorar!</comentario>		</evento>		<evento data="2003-07-22">			<pagina>55</pagina>			<comentario>Várias mudanças pequenas foram efetuadas no                esquema: questoes.xsd. Trabalho futuro deverá contemplar                o emprego de links para figuras, por exemplo, para                ilustrar código em Java e diagramas UML associados a uma questão.</comentario>		</evento>		<evento data="2003-07-16">			<comentario>Criação do arquivo XSLT para geração de HTML a                partir de um arquivo de base de questões. Também foi                utilizado um processador FOP para geração de arquivo PDF                correspondente. Alguns pequenos ajustes foram feitos no                Schema do arquiv XML.</comentario>		</evento>		<evento data="2003-07-15">			<pagina>42</pagina>		</evento>		<evento data="2003-07-07">			<pagina>35</pagina>			<comentario>Primeiras questões pós a definição parcial do                Schema para as questões.</comentario>		</evento>		<evento data="2003-07-06">			<comentario>Criação do XML Schema para questões. Versão Inicial.</comentario>		</evento>		<evento data="2003-07-05">			<pagina>28</pagina>			<comentario/>		</evento>		<evento data="2003-06-09">			<pagina>23</pagina>		</evento>		<evento data="2003-06-08">			<pagina>20</pagina>		</evento>		<evento data="2003-06-02">			<pagina>14</pagina>		</evento>		<evento data="2003-06-01">			<pagina>8</pagina>		</evento>		<evento data="2003-05-31">			<pagina>1</pagina>			<comentario>Criação do arquivo</comentario>		</evento>	</historico>	<questao id="301" qi="1" tipo="lógico" objetivo="4.4">		<introducao>Programa em Java que faz uso de <stmt>const</stmt>            e/ou <stmt>goto</stmt> provoca erro em tempo de compilação.</introducao>		<resposta valor="v">Não é uma instrução <stmt>java</stmt>, mas é uma palavra reservada e não deve ser usada em <stmt>java</stmt>		</resposta>	</questao>	<questao id="302" qi="1" tipo="lógico" objetivo="4.4">		<introducao>O código abaixo compila sem erros.
		<java>
public class Teste {     
    public static void main(String[] args) {}
}</java>		</introducao>		<resposta valor="v"/>	</questao>	<questao id="303" qi="1" tipo="lógico" objetivo="4.1">		<introducao>Uma nova instância da classe <stmt>String</stmt> é            implicitamente criada quando quando o operador de            concatenação <stmt>+</stmt> é utilizado, como na sentença            <stmt>(&quot;a&quot;+&quot;b&quot;).toUpperCase()</stmt> que            envolve 4 instâncias de <stmt>String</stmt>. As duas strings            <stmt>&quot;a&quot;</stmt> e <stmt>&quot;b&quot;</stmt>,            aquela resultante da concatenação e aquela            <stmt>&quot;AB&quot;</stmt>, criada pelo método <stmt>toUpperCase()</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="304" qi="1" tipo="lógico" objetivo="1.1">		<introducao>Um novo objeto <it>array</it> é criado            implicitamente quando uma expressão de inicialização de            <it>array</it> é avaliada. Por exemplo, <stmt>String [] strs                = { &quot;a&quot;, &quot;b&quot; }</stmt> cria            implicitamente o <it>array</it> de objetos            <stmt>String</stmt> com dois componentes.</introducao>		<resposta valor="v"/>	</questao>	<questao id="305" qi="1" tipo="lógico" objetivo="7.4">		<introducao>Todo objeto possui um <it>lock</it> associado            através do qual é controlado o acesso concorrente por            múltiplos <it>threads</it>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="306" qi="1" tipo="lógico" objetivo="4.4">		<introducao>A classe <stmt>Object</stmt> é a superclasse de            todas as classes em Java.</introducao>		<resposta valor="v"/>	</questao>	<questao id="307" qi="1" tipo="lógico" objetivo="5.4">		<introducao>Uma variável do tipo <stmt>Object</stmt> retém uma            referência para qualquer objeto, seja instância de uma            classe ou um <it>array</it>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="308" qi="1" tipo="lógico" objetivo="4.1">		<introducao>O método <stmt>getClass</stmt> retorna um objeto            <stmt>Class</stmt> que representa a classe de um objeto.</introducao>		<resposta valor="v"/>	</questao>	<questao id="309" qi="1" tipo="lógico" objetivo="4.1">		<introducao>Existe um objeto do tipo <stmt>Class</stmt> para            cada tipo de referência. Este objeto pode ser usado para            descobrir o nome completo de uma classe, seus membros, sua            superclasse imediata e as interfaces que implementa.</introducao>		<resposta valor="v"/>	</questao>	<questao id="310" qi="1" tipo="lógico" objetivo="4.6">		<introducao>Instâncias da classe <stmt>String</stmt> representam            seqüências de caracteres UNICODE.</introducao>		<resposta valor="v"/>	</questao>	<questao id="311" qi="1" tipo="lógico" objetivo="4.1">		<introducao>A sentença <stmt>import doc.texto.Formata</stmt>            declara o tipo <stmt>Formata</stmt>, importado do tipo            <stmt>doc.texto.Formata</stmt>, contido no <it>package</it>            denominado de <stmt>doc.texto</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="312" qi="1" tipo="lógico" objetivo="4.1">		<introducao>Uma variável é um espaço de armazenamento com um            tipo associado, que é um tipo primitivo ou um tipo de referência.</introducao>		<resposta valor="v"/>	</questao>	<questao id="313" qi="1" tipo="lógico" objetivo="4.1">		<introducao>Uma variável do tipo referência retém ou o valor            <stmt>null</stmt> ou uma referência para qualquer objeto            cuja classe é compatível com a atribuição ao tipo da variável.</introducao>		<resposta valor="v"/>	</questao>	<questao id="314" qi="1" tipo="lógico" objetivo="4.1">		<introducao>Uma variável de um tipo primitivo sempre retém um            valor do tipo primitivo correspondente.</introducao>		<resposta valor="v"/>	</questao>	<questao id="315" objetivo="1.2">		<introducao>Uma variável de classe pode ser declarada em uma            classe declarado com a palavra reservada <stmt>static</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="316" objetivo="4.1">		<introducao>Uma variável de classe pode ser declarada em uma            interface (<stmt>interface</stmt>) e, neste caso, não é            necessário o emprego da palavra reservada <stmt>static</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="317" objetivo="4.1">		<introducao>Uma variável de classe cessa a sua existência quando            a classe ou interface correspondente é descarregada (<it>unloaded</it>).</introducao>		<resposta valor="v"/>	</questao>	<questao id="318" objetivo="1.2">		<introducao>Uma variável de instância é um campo de uma classe            declarado sem o emprego da palavra reservada <stmt>static</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="319" objetivo="6.2">		<introducao>Se uma classe <stmt>C</stmt> possui um campo            <stmt>c</stmt> que é uma variável de instância, então uma            nova instância da variável <stmt>c</stmt> é criada e            iniciada com um valor <it>default</it> como parte de cada            objeto criado da classe <stmt>C</stmt> ou de qualquer classe            que é descendente de <stmt>C</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="320" objetivo="1.4">		<introducao>Componentes de um <it>array</it>, conhecidos em            inglês pelo termo <it>array components</it>, são variáveis            anônimas criadas e iniciadas com valores <it>default</it>            sempre que um objeto que é um <it>array</it> é criado.</introducao>		<resposta valor="v"/>	</questao>	<questao id="321" objetivo="4.5">		<introducao>Quando um <it>array</it> não é mais referenciado,            todos os componentes que dele fazem parte têm suas            existências finalizadas.</introducao>		<resposta valor="v"/>	</questao>	<questao id="322" objetivo="5.4">		<introducao>Parâmetros de um mêtodo são valores passados a um método.</introducao>		<resposta valor="v"/>	</questao>	<questao id="323" objetivo="4.1">		<introducao>Toda vez que um método <stmt>M</stmt> é chamado            (<it>invoked</it>) cada um dos parâmetros deste método dá            origem a uma nova variável, que é iniciada com o            correspondente valor da chamada.</introducao>		<resposta valor="v"/>	</questao>	<questao id="324" objetivo="1.1">		<introducao>As variáveis criadas para reter os argumentos            fornecidos durante a chamada de um método, cada uma delas            correspondentes a um argumento deste método, deixam de            existir quando não mais há o que executar no corpo do método            em questão.</introducao>		<resposta valor="v"/>	</questao>	<questao id="325" objetivo="2.4">		<introducao>O parâmetro de um tratador de exceção, ou                <it>exception-handler parameter</it>, é criado toda vez            que uma exceção é capturada por uma cláusula            <stmt>catch</stmt> de uma sentença <stmt>try</stmt>. A nova            variável criada é iniciada com o objeto associado com a            exceção. O parâmetro cessa a sua existência quando a            execução do bloco <stmt>catch</stmt> é finalizada.</introducao>		<resposta valor="v"/>	</questao>	<questao id="326" objetivo="4.1">		<introducao>Variáveis locais são declaradas no corpo de métodos,            por exemplo.</introducao>		<resposta valor="v"/>	</questao>	<questao id="327" objetivo="4.1">		<introducao>Toda vez que o fluxo de controle entra em um bloco            (delimitado por <stmt>{</stmt> e <stmt>}</stmt>) ou uma            sentença <stmt>for</stmt>, uma nova variável é criada para            cada variável local declarada no interior do bloco ou            sentença <stmt>for</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="328" objetivo="4.1">		<introducao>O valor de uma variável local não pode ser utilizado            se a variável correspondente não foi iniciada ou se um valor            não foi atribuído à variável em questão.</introducao>		<resposta valor="v"/>	</questao>	<questao id="329" objetivo="4.1">		<introducao>Uma variável local tem sua existência finalizada            quando é terminada a execução do bloco ou sentença            <stmt>for</stmt> correspondente.</introducao>		<resposta valor="v"/>	</questao>	<questao id="330" objetivo="1.2">		<introducao>A variável <stmt>x</stmt> é uma variável                local.<java> public class X {     static int x = 1; }</java>		</introducao>		<resposta valor="f">Não. Trata-se de uma variável de classe.</resposta>	</questao>	<questao id="331" objetivo="4.1">		<introducao>A variável <stmt>i</stmt>, declarada no código            abaixo é dita uma variável de instância.<java> public class                I {     int i; }</java>		</introducao>		<resposta valor="v"/>	</questao>	<questao id="332" objetivo="1.1">		<introducao>Para o código fornecido abaixo pode-se afirmar que            <stmt>a[1]</stmt> é um componente de um <it>array</it>.<java><![CDATA[public class I {    int a[] = new int[2];}]]></java>		</introducao>		<resposta valor="v">Sim, pois se mantém dentro da faixa definida		</resposta>	</questao>	<questao id="333" objetivo="1.2">		<introducao>Uma variável pode ser declarada <stmt>final</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="334" objetivo="1.2">		<introducao>Dado o trecho de código abaixo que compila satisfatoriamente, pode-se afirmar que            a variável <stmt>x</stmt> é uma variável declarada como                <stmt>final</stmt>.<java> x = 2; x = x + 3;</java>		</introducao>		<resposta valor="f">Para isso ela deveria ser declarada com a palavra <stmt>final</stmt>		</resposta>	</questao>	<questao id="335" objetivo="1.2">		<introducao>Uma variável declarada como <stmt>final</stmt> só            pode participar do lado esquerdo de uma atribuição uma única vez.</introducao>		<resposta valor="v">Sim, pois podemos atribuir valor a ela uma única vez.		</resposta>	</questao>	<questao id="336" objetivo="1.2">		<introducao>Após a inicialização de uma variável            <stmt>final</stmt> com um valor, esta variável sempre            conterá este valor</introducao>		<resposta valor="v"/>	</questao>	<questao id="337" objetivo="1.2">		<introducao>A declaração de uma variável como <stmt>final</stmt>            significa que o valor correspondente, atribuído a esta            variável, não será alterado ao longo de toda a existência            desta variável.</introducao>		<resposta valor="v"/>	</questao>	<questao id="338" objetivo="1.2">		<introducao>Um objeto referenciado por uma variável declarada            como <stmt>final</stmt> pode alterar os valores de seus campos.</introducao>		<resposta valor="v"/>	</questao>	<questao id="339" objetivo="4.1">		<introducao>O código abaixo produz um erro de compilação, pois            tenta-se alterar o valor de uma variável declarada como <stmt>final</stmt>.<java><![CDATA[class Final {    public int i = 0;    public void M() {        final Final f = new Final();        f.i = 2;    }}]]></java>		</introducao>		<resposta valor="f">A variável em questão não é do tipo <stmt>final</stmt>, somente o nome foi utilizado.		</resposta>	</questao>	<questao id="340" objetivo="4.1">		<introducao>Toda variável de classe, variável de instância ou            componente de <it>array</it> é iniciado com um valor            <it>default</it> quando é criada.</introducao>		<resposta valor="v"/>	</questao>	<questao id="341" objetivo="4.1">		<introducao>O valor <it>default</it> para uma variável do tipo            <stmt>byte</stmt> é zero, ou seja, o valor <stmt>(byte)0</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="342" objetivo="4.1">		<introducao>O valor <it>default</it> para uma variável do tipo            <stmt>short</stmt> é zero, ou seja, o valor <stmt>(short)0</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="343" objetivo="4.1">		<introducao>O valor <it>default</it> para uma variável do tipo            <stmt>int</stmt> é zero, ou seja, o valor <stmt>0</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="344" objetivo="4.1">		<introducao>O valor <it>default</it> para uma variável do tipo            <stmt>long</stmt> é zero, ou seja, o valor            <stmt>(long)0</stmt>, ou <stmt>0l</stmt> ou <stmt>0L</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="345" objetivo="4.1">		<introducao>O valor <it>default</it> para uma variável do tipo            <stmt>float</stmt> é zero, ou seja, o valor            <stmt>0.0f</stmt>, ou <stmt>(float)0</stmt>, ou <stmt>0.0F</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="346" objetivo="4.1">		<introducao>O valor <it>default</it> para uma variável do tipo            <stmt>double</stmt> é zero, ou seja, o valor            <stmt>(double)0</stmt>, ou <stmt>0.0</stmt>, ou            <stmt>0.0D</stmt> ou <stmt>0.0d</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="347" objetivo="4.1">		<introducao>O valor <it>default</it> para uma variável do tipo            <stmt>char</stmt> é o caractere nulo, ou seja, <stmt>'\u0000'</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="348" objetivo="4.1">		<introducao>O valor <it>default</it> para uma variável do tipo            <stmt>boolean</stmt> é falso, ou seja, <stmt>false</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="349" objetivo="4.1">		<introducao>O valor <it>default</it> para uma variável do tipo            referência é o valor <stmt>null</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="350" objetivo="4.1">		<introducao>Toda variável correspondente a um parâmetro de um            método é iniciada com o valor do correspondente argumento            fornecido durante a chamada do método</introducao>		<resposta valor="v"/>	</questao>	<questao id="351" objetivo="4.1">		<introducao>Antes de se fazer uso de uma variável local, um            valor deve ser explicitamente atribuído à variável.</introducao>		<resposta valor="v"/>	</questao>	<questao id="352" objetivo="4.1">		<introducao>Valores <it>default</it> não são empregados em            variáveis locais.</introducao>		<resposta valor="v"/>	</questao>	<questao id="353" objetivo="4.1">		<introducao>Em Java, toda variável e toda expressão possui um            tipo que pode ser determinado em tempo de compilação.</introducao>		<resposta valor="v"/>	</questao>	<questao id="354" objetivo="4.1">		<introducao>Uma expressão ou uma variável pode ter como tipo um            dos tipos primitivos ou o tipo referência.</introducao>		<resposta valor="v"/>	</questao>	<questao id="355" objetivo="4.1">		<introducao>Os tipos referência incluem os tipos classes e os            tipos interfaces.</introducao>		<resposta valor="v"/>	</questao>	<questao id="356" objetivo="4.1">		<introducao>Diz-se que um objeto é uma instância da classe            correspondente e de todas as superclasses desta classe.</introducao>		<resposta valor="v"/>	</questao>	<questao id="357" objetivo="4.1">		<introducao>Pode-se dizer, para a sentença <stmt>P p = new            P()</stmt>, que <stmt>p</stmt> é uma variável do tipo            <stmt>P</stmt> cujo valor inicial é uma referência para a            nova instância criada da classe <stmt>P</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="358" objetivo="4.1">		<introducao>Se a classe <stmt>Quadrado</stmt> é derivada da            classe <stmt>Quadrilátero</stmt>, <stmt>a</stmt> é uma            variável que retém uma referência para um objeto do tipo            <stmt>Quadrado</stmt> e <stmt>b</stmt> é uma variável que            armazena uma referência para uma instância de            <stmt>Quadrilátero</stmt>, então pode-se afirmar que a            atribuição <stmt>b=a</stmt> é válida, enquanto a atribuição            <stmt>a=b</stmt> não é permitida em Java.</introducao>		<resposta valor="v"/>	</questao>	<questao id="359" objetivo="4.2">		<introducao>Uma variável <stmt>v</stmt> do tipo referência, em            particular, tipo interface <stmt>I</stmt>, pode reter como            valor qualquer referência para um objeto cuja classe            implementa a interface <stmt>I</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="360" objetivo="4.2">		<introducao>A sentença <stmt>ICor ic = new ICor()</stmt> é            inválida se <stmt>ICor</stmt> é uma interface.</introducao>		<resposta valor="v"/>	</questao>	<questao id="361" objetivo="4.2">		<introducao>Não se pode criar instâncias de interfaces.</introducao>		<resposta valor="v"/>	</questao>	<questao id="362" objetivo="4.1">		<introducao>Instâncias de classes podem ser criadas através do            emprego do operador <stmt>new</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="363" objetivo="4.5">		<introducao>Todo <it>array</it> possui uma classe            correspondente. O método <stmt>getClass</stmt> quando            aplicado a um <it>array</it> retorna o objeto da classe            <stmt>Class</stmt> que representa a classe do <it>array</it>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="364" objetivo="4.6">		<introducao>A conversão de um valor do tipo <stmt>float</stmt>            para o tipo <stmt>double</stmt> não perde informação. A            conversão no sentido inverso pode ocasionar perda de precisão.</introducao>		<resposta valor="v"/>	</questao>	<questao id="365" objetivo="2.4">		<introducao>Conversão de atribuição e de invocação de método            nunca gera exceção.</introducao>		<resposta valor="v"/>	</questao>	<questao id="366" objetivo="2.2">		<introducao>A conversão por moldagem (<it>casting</it>) pode            gerar exceção em tempo de execução.</introducao>		<resposta valor="v"/>	</questao>	<questao id="367" objetivo="4.6">		<introducao>A conversão de um tipo para o mesmo tipo é permitida            para qualquer que seja o tipo.</introducao>		<resposta valor="v"/>	</questao>	<questao id="368" objetivo="4.6">		<introducao>Toda expressão é sujeita à conversão de tipo.</introducao>		<resposta valor="v"/>	</questao>	<questao id="369" objetivo="4.6">		<introducao>A única conversão envolvendo o tipo            <stmt>boolean</stmt> é a conversão de <stmt>boolean</stmt>            para o próprio <stmt>boolean</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="370" objetivo="4.6">		<introducao>Conversão do tipo <stmt>byte</stmt> para o tipo            <stmt>short</stmt> não envolve perda de informação.</introducao>		<resposta valor="v"/>	</questao>	<questao id="371" objetivo="4.6">		<introducao>Conversão do tipo <stmt>byte</stmt> para o tipo            <stmt>int</stmt> não envolve perda de informação.</introducao>		<resposta valor="v"/>	</questao>	<questao id="372" objetivo="4.6">		<introducao>Conversão do tipo <stmt>byte</stmt> para o tipo            <stmt>long</stmt> não envolve perda de informação.</introducao>		<resposta valor="v"/>	</questao>	<questao id="373" objetivo="4.6">		<introducao>Conversão do tipo <stmt>float</stmt> para o tipo            <stmt>double</stmt> não envolve perda de informação.</introducao>		<resposta valor="v"/>	</questao>	<questao id="374" objetivo="4.6">		<introducao>Conversão do tipo <stmt>short</stmt> para o tipo            <stmt>double</stmt> não envolve perda de informação.</introducao>		<resposta valor="v"/>	</questao>	<questao id="375" objetivo="4.6">		<introducao>Conversão do tipo <stmt>short</stmt> para o tipo            <stmt>float</stmt> não envolve perda de informação.</introducao>		<resposta valor="v"/>	</questao>	<questao id="376" objetivo="4.6">		<introducao>Conversão do tipo <stmt>short</stmt> para o tipo            <stmt>int</stmt> não envolve perda de informação.</introducao>		<resposta valor="v"/>	</questao>	<questao id="377" objetivo="4.6">		<introducao>Conversão do tipo <stmt>char</stmt> para o tipo            <stmt>int</stmt> não envolve perda de informação.</introducao>		<resposta valor="v"/>	</questao>	<questao id="378" objetivo="4.6">		<introducao>Conversão do tipo <stmt>char</stmt> para o tipo            <stmt>long</stmt> não envolve perda de informação.</introducao>		<resposta valor="v"/>	</questao>	<questao id="379" objetivo="4.6">		<introducao>Conversão do tipo <stmt>char</stmt> para o tipo            <stmt>float</stmt> não envolve perda de informação.</introducao>		<resposta valor="v"/>	</questao>	<questao id="380" objetivo="4.6">		<introducao>Conversão do tipo <stmt>char</stmt> para o tipo            <stmt>double</stmt> não envolve perda de informação.</introducao>		<resposta valor="v"/>	</questao>	<questao id="381" objetivo="4.6">		<introducao>Conversão do tipo <stmt>int</stmt> para o tipo            <stmt>long</stmt> não envolve perda de informação.</introducao>		<resposta valor="v"/>	</questao>	<questao id="382" objetivo="4.6">		<introducao>Conversão do tipo <stmt>int</stmt> para o tipo            <stmt>float</stmt> não envolve perda de informação.</introducao>		<resposta valor="f"/>	</questao>	<questao id="383" objetivo="4.6">		<introducao>Conversão do tipo <stmt>int</stmt> para o tipo            <stmt>double</stmt> não envolve perda de informação.</introducao>		<resposta valor="v"/>	</questao>	<questao id="384" objetivo="4.6">		<introducao>Conversão do tipo <stmt>long</stmt> para o tipo            <stmt>float</stmt> não envolve perda de informação.</introducao>		<resposta valor="f"/>	</questao>	<questao id="385" objetivo="4.6">		<introducao>As conversões entre tipos primitivos podem causar            perda de precisão, por exemplo, do tipo <stmt>int</stmt>            para o tipo <stmt>float</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="386" objetivo="4.6">		<introducao>Conversões entre tipos primitivos do tipo            <it>widening</it>, apesar da possível perda de informação,            não geram exceções em tempo de execução.</introducao>		<resposta valor="v"/>	</questao>	<questao id="387" objetivo="4.6">		<introducao>Conversão do tipo <stmt>float</stmt> para o tipo            <stmt>double</stmt> não envolve perda de informação.</introducao>		<resposta valor="v"/>	</questao>	<questao id="388" objetivo="4.6">		<introducao>Uma conversão do tipo <it>narrowing</it> de um            inteiro com sinal para um tipo inteiro <it>T</it>            simplesmente discarta todos os bits que não fazem parte dos            <it>n</it> bits de menor ordem de <it>T</it>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="389" objetivo="4.6">		<introducao>Valores do tipo <stmt>char</stmt>, mesmo sendo            inteiros sem sinal, quando convertidos para um tipo inteiro            (<it>narrowing</it>), podem resultar em um valor negativo.</introducao>		<resposta valor="v"/>	</questao>	<questao id="390" objetivo="4.6">		<introducao>A conversão de um valor em ponto-flutuante para um            valor inteiro pode exigir duas conversões. Primeiro o valor            em ponto-flutuante é convertido para o tipo            <stmt>long</stmt> ou tipo <stmt>int</stmt>. Esta conversão            segue a seguinte regra: (a) a conversão é para o tipo            <stmt>long</stmt> se o tipo destino é do tipo            <stmt>long</stmt>; (b) a conversão é para o tipo            <stmt>int</stmt> se o tipo destino é <stmt>byte</stmt>,            <stmt>short</stmt>, <stmt>int</stmt> ou <stmt>char</stmt>.            Por último, se a conversão para o tipo destino é            <stmt>long</stmt> ou <stmt>int</stmt>, então a conversão foi            realizada completamente. Caso contrário, será necessário            converter o tipo <stmt>int</stmt>, via <it>narrowing</it>,            para o tipo desejado, ou seja, <stmt>byte</stmt>,            <stmt>short</stmt> ou <stmt>char</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="391" objetivo="2.4">		<introducao>A tentativa de impressão do valor            <stmt>0.0f/0.0F</stmt> gera uma exceção.</introducao>		<resposta valor="f"/>	</questao>	<questao id="392" objetivo="4.4">		<introducao>O resultado da impressão do valor            <stmt>0.0/0.0D</stmt> é <stmt>NaN</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="393" objetivo="2.4">		<introducao>A execução de <stmt>Math.sqrt(-1)</stmt> gera uma exceção.</introducao>		<resposta valor="f"/>	</questao>	<questao id="394" objetivo="4.4">		<introducao>O resultado de <stmt>Math.sqrt(-1.0)</stmt> é <stmt>NaN</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="395" objetivo="4.4">		<introducao>O valor de <stmt>(int)(0.0/0.0D)</stmt> é o valor            inteiro <stmt>0</stmt>		</introducao>		<resposta valor="v"/>	</questao>	<questao id="396" objetivo="4.4">		<introducao>O valor de <stmt>(int)(0.0/0.0D)</stmt> é o valor            inteiro <stmt>0L</stmt>		</introducao>		<resposta valor="f"/>	</questao>	<questao id="397" objetivo="4.4">		<introducao>A expressão <stmt>(int)(1.0/0.0) ==            Integer.MAX_VALUE</stmt> é verdadeira.</introducao>		<resposta valor="f"/>	</questao>	<questao id="398" objetivo="4.4">		<introducao>A expressão <stmt>(int)(-1.0/0.0) ==            Integer.MIN_VALUE</stmt> é verdadeira.</introducao>		<resposta valor="f"/>	</questao>	<questao id="399" objetivo="2.4">		<introducao>A conversão entre referências não gera exceção            quando se converte uma referência para um tipo classe            <stmt>S</stmt> para o tipo classe <stmt>T</stmt> e            <stmt>S</stmt> é subclasse de <stmt>T</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="400" objetivo="4.4">		<introducao>Não gera exceção a conversão de uma referência de um            tipo <it>array</it>para uma do tipo classe <stmt>Object</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="401" objetivo="2.4">		<introducao>Não gera exceção a conversão de uma referência de um            tipo <it>array</it>para uma do tipo classe <stmt>Cloneable</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="402" objetivo="2.4">		<introducao>Não gera exceção a conversão de uma referência de um            tipo <it>array</it>para uma do tipo classe <stmt>java.io.Serializable</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="403" objetivo="2.4">		<introducao>Uma conversão de um valor de referência para outro            pode gerar a exceção <stmt>ClassCastException</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="404" objetivo="2.4">		<introducao>A conversão de um valor de referência do tipo classe            <stmt>Object</stmt>para o tipo <it>array</it> pode gerar a            exceção <stmt>ClassCastException</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="405" objetivo="4.6">		<introducao>Há conversão para o tipo classe <stmt>String</stmt>            de qualquer outro tipo, incluindo o tipo <stmt>null</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="406" objetivo="4.6">		<introducao>Não é permitida a conversão do tipo referência para            qualquer tipo primitivo.</introducao>		<resposta valor="v"/>	</questao>	<questao id="407" objetivo="4.6">		<introducao>Não é permitida a conversão do tipo            <stmt>null</stmt> para qualquer tipo primitivo.</introducao>		<resposta valor="v"/>	</questao>	<questao id="408" objetivo="5.1">		<introducao>A única conversão envolvendo o tipo            <stmt>boolean</stmt> é aquela deste tipo para o próprio.</introducao>		<resposta valor="v"/>	</questao>	<questao id="409" objetivo="6.1">		<introducao>Excluindo-se a classe <stmt>String</stmt>, não            existe nenhuma conversão envolvendo os tipos classe            <stmt>S</stmt> e <stmt>T</stmt> se <stmt>S</stmt>não é            subclasse de <stmt>T</stmt> ou <stmt>S</stmt> não é            superclasse de <stmt>T</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="410" objetivo="4.1">		<introducao>Se a classe <stmt>S</stmt> é uma classe            <stmt>final</stmt> e não implementa a interface            <stmt>I</stmt>, então não é permitida a conversão do tipo            referência da classe <stmt>S</stmt> para a interface <stmt>I</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="411" objetivo="4.1">		<introducao>Não é permitida a conversão do tipo classe            <stmt>S</stmt> para qualquer tipo <it>array</it> se            <stmt>S</stmt> não é <stmt>Object</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="412" objetivo="4.1">		<introducao>Não é permitida a conversão do tipo interface            <stmt>J</stmt> para o tipo interface <stmt>K</stmt> se            <stmt>J</stmt> e <stmt>K</stmt> contêm métodos com as mesmas            assinaturas mas diferentes tipos de retorno.</introducao>		<resposta valor="v"/>	</questao>	<questao id="413" objetivo="1.1">		<introducao>Não é permitida a conversão de nenhum tipo            <it>array</it> para qualquer tipo interface, exceto para os            tipos interface <stmt>java.io.Serializable</stmt> e <stmt>Cloneable</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="414" objetivo="1.1">		<introducao>Todo e qualquer <it>array</it> implementa as            interfaces <stmt>java.io.Serializable</stmt> e <stmt>Cloneable</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="415" objetivo="11">		<introducao>Quando se deseja implementar a linguagem de            programação Java, há opções (decisões) de implementação que            devem ser realizadas.</introducao>		<resposta valor="v"/>	</questao>	<questao id="416" objetivo="11">		<introducao>Toda implementação da linguagem de programação Java            realiza, rigorosamente, os mesmos serviços funcionais            através dos quais os mesmos resultados são obtidos,            independente da implementação considerada.</introducao>		<resposta valor="f"/>	</questao>	<questao id="417" objetivo="2.4">		<introducao>Se o tipo de uma expressão não pode ser convertido            para o tipo da variável do lado direito de uma atribuição,            então um erro em tempo de compilação é gerado.</introducao>		<resposta valor="v"/>	</questao>	<questao id="418" objetivo="2.4">		<introducao>Uma atribuição pode gerar a exceção <stmt>ArrayStoreException</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="419" objetivo="5.1">		<introducao>A operação de moldagem (<it>casting</it>) da            atribuição <stmt>byte umByte = (byte)20;</stmt> é permitida,            mas não é obrigatória.</introducao>		<resposta valor="v"/>	</questao>	<questao id="420" objetivo="4.6">		<introducao>A atribuição <stmt>byte x = 20;</stmt> provoca um            erro em tempo de compilação.</introducao>		<resposta valor="f"/>	</questao>	<questao id="421" objetivo="4.6">		<introducao>A atribuição <stmt>byte bValor = (int)45;</stmt>            provoca um erro em tempo de compilação.</introducao>		<resposta valor="f"/>	</questao>	<questao id="422" objetivo="4.6">		<introducao>A atribuição <stmt>byte bValor = (int)45;</stmt>            provoca um erro em tempo de execução.</introducao>		<resposta valor="f"/>	</questao>	<questao id="423" objetivo="4.6">		<introducao>Um valor de um tipo primitivo, qualquer que seja            este, não pode ser atribuído a uma variável do tipo referência.</introducao>		<resposta valor="v"/>	</questao>	<questao id="424" objetivo="4.6">		<introducao>Um dos valores de tipos primitivos que pode ser            atribuído a uma variável referência é a constante <stmt>null</stmt>.</introducao>		<resposta valor="f"/>	</questao>	<questao id="425" objetivo="4.6">		<introducao>A tentativa de atribuir um valor de um tipo            primitivo a uma referência é verificado em tempo de execução.</introducao>		<resposta valor="f"/>	</questao>	<questao id="426" objetivo="5.1">		<introducao>Um valor do tipo <stmt>boolean</stmt> só pode ser            atribuído a uma variável do tipo <stmt>boolean</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="427" objetivo="5.1">		<introducao>A atribuição <stmt>short s = (int)-10;</stmt> não é            permitida em Java.</introducao>		<resposta valor="f"/>	</questao>	<questao id="428" objetivo="5.1">		<introducao>A atribuição <stmt>short s = (byte)-1;</stmt> não é            permitida em Java.</introducao>		<resposta valor="f"/>	</questao>	<questao id="429" objetivo="5.1">		<introducao>A atribuição <stmt>short s = (char)65;</stmt> é            permitida em Java.</introducao>		<resposta valor="f"/>	</questao>	<questao id="430" objetivo="4.6">		<introducao>Nem todo valor <stmt>short</stmt> também é um valor            <stmt>char</stmt> e nem todo valor <stmt>char</stmt> também            é um valor <stmt>short</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="431" objetivo="4.6">		<introducao>O valor <stmt>null</stmt> do tipo <stmt>null</stmt>            é um dentre os valores comumente atribuídos a uma variável            do tipo referência.</introducao>		<resposta valor="f"/>	</questao>	<questao id="432" objetivo="4.6">		<introducao>Em Java, o tipo <stmt>null</stmt> contém um único            valor, a referência <stmt>null</stmt>. Comparando-o com o            tipo primitivo <stmt>boolean</stmt>, pode-se dizer que o            tipo <stmt>null</stmt> possui um domínio mais restrito, com            um único valor, ao contrário dos dois valores possíveis para            o tipo <stmt>boolean</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="433" objetivo="4.6">		<introducao>Um <it>array</it> de elementos do tipo primitivo            <stmt>byte</stmt> pode ser atribuído a um <it>array</it>            cujos elementos são do tipo <stmt>int</stmt>.</introducao>		<resposta valor="f"/>	</questao>	<questao id="434" objetivo="4.1">		<introducao>A atribuição de uma referência do tipo interface            <stmt>O</stmt> para uma variável do tipo classe            <stmt>D</stmt> é válida apenas se <stmt>D</stmt> for            <stmt>Object</stmt>. Caso contrário, um erro em tempo de            compilação ocorre.</introducao>		<resposta valor="v"/>	</questao>	<questao id="435" objetivo="4.1">		<introducao>O código abaixo é compilado com sucesso.<java><![CDATA[interface O { void ok(); }class D implements O {    public void ok() {}}public class teste {    public static void main(String[] args) {	O obj = new D();	Object oo = obj;    }}]]></java>		</introducao>		<resposta valor="v"/>	</questao>	<questao id="436" objetivo="4.1">		<introducao>O código abaixo é compilado com sucesso.<java><![CDATA[interface O { void ok(); }class D implements O {    public void ok() {}}public class teste {    public static void main(String[] args) {	O obj = new D();	D objD = obj;    }}]]></java>		</introducao>		<resposta valor="f">O código não compila porque possui tipos incompatíveis.</resposta>	</questao>	<questao id="437" objetivo="4.1">		<introducao>O código abaixo gera erro em tempo de compilação.<java><![CDATA[interface O { void ok(); }class D implements O {    public void ok() {}}public class teste {    public static void main(String[] args) {	O obj = new D();	D objD = (D)obj;    }}]]></java>		</introducao>		<resposta valor="f">O código compila com sucesso.</resposta>	</questao>	<questao id="438" objetivo="2.4">		<introducao>O código abaixo é compilado com sucesso, mas gera um            erro em tempo de execução.<java><![CDATA[public class Teste {    public static void main(String[] args) {	long[] aLong = new long[100];	Object o = aLong;	((byte[])o)[1] = 2;    }}]]></java>		</introducao>		<resposta valor="v">O código compila, mas gera erro em tempo de execução. A exceção ClassCastException.</resposta>	</questao>	<questao id="439" objetivo="4.1">		<introducao>O código abaixo é compilado com sucesso, mas gera um            erro em tempo de execução.<java><![CDATA[public class Teste {    public static void main(String[] args) {	long[] aLong = new long[100];	Object o = aLong;	((long[])o)[1] = 2;    }}]]></java>		</introducao>		<resposta valor="f">O código compila, e não gera erro em tempo de execução.</resposta>	</questao>	<questao id="440" objetivo="2.4">		<introducao>O código abaixo, embora seja compilado            satisfatoriamente, gera a exceção            <stmt>ClassCastException</stmt> em tempo de execução.<java><![CDATA[public class Teste {    public static void main(String[] args) {	byte[] vecByte = new byte[100];	Object o = vecByte;	((int[])o)[1] = 2;    }}]]></java>		</introducao>		<resposta valor="v"/>	</questao>	<questao id="441" objetivo="4.1">		<introducao>O código abaixo é compilado com sucesso, mas gera um            erro em tempo de execução.<java><![CDATA[class Base {}class Derivada extends Base {}public class teste {    public static void main(String[] args) {	Base[] aBase = new Base[1];	Derivada[] aDerivada = new Derivada[1];	aBase = aDerivada;    }}]]></java>		</introducao>		<resposta valor="f">O código compila e é executado sem exceção.</resposta>	</questao>	<questao id="442" objetivo="2.4">		<introducao>O código abaixo, quando executado, gera a exceção <stmt>ArrayStoreException</stmt>.<java><![CDATA[class Base {}class Derivada extends Base {}public class teste {    public static void main(String[] args) {	Base[] aBase = new Base[1];	Derivada[] aDerivada = new Derivada[1];	aBase = aDerivada;	aBase[0] = new Base();    }}]]></java>		</introducao>		<resposta valor="v"/>	</questao>	<questao id="443" objetivo="4.1">		<introducao>O código abaixo gera a exceção            <stmt>ArrayStoreException</stmt>, quando executado.<java><![CDATA[class Base {}class Derivada extends Base {}public class teste {    public static void main(String[] args) {	Base[] aBase = new Base[1];	Derivada[] aDerivada = new Derivada[1];	aBase = aDerivada;	aBase[0] = new Derivada();    }}]]></java>		</introducao>		<resposta valor="f">É executado sem exceção.</resposta>	</questao>	<questao id="444" objetivo="4.1">		<introducao>O código abaixo é compilado com sucesso.<java><![CDATA[class Base {}class Derivada extends Base {}public class teste {    public static void main(String[] args) {	Base[] aBase = new Base[1];	Derivada[] aDerivada = new Derivada[1];	aDerivada = aBase;    }}]]></java>		</introducao>		<resposta valor="f">O código não compila porque possui tipos incompatíveis.</resposta>	</questao>	<questao id="445" objetivo="4.1">		<introducao>O código abaixo não é compilado com sucesso.<java><![CDATA[class Base {}class Derivada extends Base {}public class teste {    public static void main(String[] args) {	Base[] aBase = new Base[1];	Derivada[] aDerivada = new Derivada[1];	aBase = aDerivada;	aDerivada = (Derivada[])aBase;    }}]]></java>		</introducao>		<resposta valor="f">O código compila e é executado sem exceção.</resposta>	</questao>	<questao id="446" objetivo="4.1">		<introducao>O código abaixo gera uma exceção em tempo de execução.<java><![CDATA[class Base {}class Derivada extends Base {}public class teste {    public static void main(String[] args) {	Base[] aBase = new Base[1];	Derivada[] aDerivada = new Derivada[1];	aBase = aDerivada;	aDerivada = (Derivada[])aBase;    }}]]></java>		</introducao>		<resposta valor="f">Não gera exceção em tempo de execução.</resposta>	</questao>	<questao id="447" objetivo="2.4">		<introducao>O código abaixo, quando executado, gera a exceção <stmt>ArrayStoreException</stmt>.<java><![CDATA[class Base {}class Derivada extends Base {}public class teste {    public static void main(String[] args) {	Base[] aBase = new Base[1];	Derivada[] aDerivada = new Derivada[1];	aDerivada = (Derivada[])aBase;    }}]]></java>		</introducao>		<resposta valor="f">A exceção gerada é <stmt>ClassCastException</stmt>.</resposta>	</questao>	<questao id="448" objetivo="5.1">		<introducao>O operador <stmt>+</stmt> torna-se um operador de            concatenação apenas quando um dos operandos é uma <stmt>String</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="449" objetivo="5.1">		<introducao>Quando um dos argumentos do operador <stmt>+</stmt>            é uma <stmt>String</stmt>, caso o outro não seja, este será            convertido para uma <stmt>String</stmt> e uma nova            <stmt>String</stmt>, resultado da concatenação das duas            <stmt>String</stmt>s envolvidas é produzida. </introducao>		<resposta valor="v"/>	</questao>	<questao id="450" objetivo="5.1">		<introducao>O operador de moldagem (<it>casting</it>) converte o            valor da expressão (operando) em um valor do tipo fornecido            pelo operador de moldagem.</introducao>		<resposta valor="v"/>	</questao>	<questao id="451" objetivo="5.1">		<introducao>A atribuição <stmt>X obj = (X)null;</stmt> não é válida.</introducao>		<resposta valor="f"/>	</questao>	<questao id="452" objetivo="5.1">		<introducao>A operação de moldagem (<it>casting</it>) exige            validação em tempo de compilação.</introducao>		<resposta valor="v"/>	</questao>	<questao id="453" objetivo="5.1">		<introducao>A operação de moldagem (<it>casting</it>) não é            validada em tempo de execução.</introducao>		<resposta valor="f"/>	</questao>	<questao id="454" objetivo="4.1">		<introducao>O código abaixo compila satisfatoriamente.<java><![CDATA[interface O {}class Base {}class Derivada extends Base implements O {}final class Outra {}public class teste {    public static void main(String[] args) {	Base aBase = new Base();	Derivada aDerivada = new Derivada();	O iO;	aDerivada = (Derivada)aBase;	iO = (O)aBase;	iO = (O)(new Outra());    }}]]></java>		</introducao>		<resposta valor="f">O código não compila, porque possui tipos incompatíveis.</resposta>	</questao>	<questao id="455" objetivo="4.1">		<introducao>O código abaixo compila satisfatoriamente.<java><![CDATA[interface O {}class Base {}class Derivada extends Base implements O {}class Outra {}public class teste {    public static void main(String[] args) {	Base aBase = new Base();	Derivada aDerivada = new Derivada();	O iO;	aDerivada = (Derivada)aBase;	iO = (O)aBase;	iO = (O)(new Outra());    }}]]></java>		</introducao>		<resposta valor="v">O código compila, mas gera uma exceção ClassCastException.</resposta>	</questao>	<questao id="456" objetivo="4.1">		<introducao>O código abaixo não compila.<java><![CDATA[interface O { void a(); }class Base {}class Derivada extends Base implements O { public void a() {} }public class teste {    public static void main(String[] args) {	Base aBase = new Derivada();	Derivada aDerivada;	O iO;	aDerivada = (Derivada)aBase;	iO = (O)aBase;	iO = (O)(new O(){ public void a() {} });    }}]]></java>		</introducao>		<resposta valor="f">O código compila e é executado sem exceção.</resposta>	</questao>	<questao id="457" objetivo="4.1">		<introducao>O código abaixo gera a exceção            <stmt>ClassCastException</stmt> quando  executado.<java><![CDATA[interface O { void a(); }class Base {}class Derivada extends Base implements O { public void a() {} }public class teste {    public static void main(String[] args) {	Base aBase = new Derivada();	Derivada aDerivada;	O iO;	aDerivada = (Derivada)aBase;	iO = (O)aBase;	iO = (O)(new O(){ public void a() {} });    }}]]></java>		</introducao>		<resposta valor="f">O código compila e é executado sem exceção.</resposta>	</questao>	<questao id="458" objetivo="5.1">		<introducao>Promoções numéricas (<it>numeric promotions</it>)            referem-se às conversões de operandos de um operador            numérico para um tipo comum de tal forma que a operação            possa ser realizada.</introducao>		<resposta valor="v"/>	</questao>	<questao id="459" objetivo="5.1">		<introducao>A sentença <stmt>byte b = +4;</stmt> gera um erro de compilação.</introducao>		<resposta valor="f"/>	</questao>	<questao id="460">		<introducao>Se o operando do operador unário <stmt>+</stmt> é </introducao>		<resposta valor="">ENUNCIADO INCOMPLETO.</resposta>	</questao>	<questao id="461" objetivo="4.1">		<introducao>O código abaixo não compila.<java><![CDATA[public class teste {    public static void main(String[] args) {	byte b1 = -4;	byte b2 = (int)+(byte)4;	System.out.println( "b1 + b2 = " + b1 + b2 );    }}]]></java>		</introducao>		<resposta valor="f">O código compila e é executado sem exceção.</resposta>	</questao>	<questao id="462" objetivo="4.1">		<introducao>O código abaixo compila e, quando executado, exibe a            mensagem <stmt>&quot;b1 + b2 = 0&quot;</stmt>			<java><![CDATA[public class teste {    public static void main(String[] args) {	byte b1 = -4;	byte b2 = (int)+(byte)4;	System.out.println( "b1 + b2 = " + b1 + b2 );    }}]]></java>		</introducao>		<resposta valor="f">O código compila e quando executado exibe a mensagem "b1 + b2 = - 44".</resposta>	</questao>	<questao id="463" objetivo="4.1">		<introducao>O código abaixo compila e, quando executado, exibe a            mensagem <stmt>&quot;b1 + b2 = -44&quot;</stmt>			<java><![CDATA[public class teste {    public static void main(String[] args) {	byte b1 = -4;	byte b2 = (int)+(byte)4;	System.out.println( "b1 + b2 = " + b1 + b2 );    }}]]></java>		</introducao>		<resposta valor="v">O resultado é a mensagem "b1 + b2 = - 44".</resposta>	</questao>	<questao id="464" objetivo="5.1">		<introducao>O operando do tipo <stmt>byte</stmt>,            <stmt>short</stmt> ou <stmt>char</stmt>, em tempo de            compilação, de um operador unário promove o valor            correspondente para o tipo <stmt>int</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="465" objetivo="5.1">		<introducao>Para um operador binário, se um dos operandos é do            tipo primitivo <stmt>double</stmt>, então o outro é            convertido para o tipo <stmt>double</stmt> antes que a            operação seja executada.</introducao>		<resposta valor="v"/>	</questao>	<questao id="466" objetivo="5.1">		<introducao>Para um operador binário, se nenhum operando é do            tipo <stmt>double</stmt> e há um operando do tipo            <stmt>float</stmt>, então o outro é convertido para            <stmt>float</stmt> antes da execução da operação.</introducao>		<resposta valor="v"/>	</questao>	<questao id="467" objetivo="5.1">		<introducao>Para um operador binário, se nenhum operando é do            tipo ponto-flutuante e há um operando do tipo            <stmt>long</stmt>, então o outro é convertido para o tipo            <stmt>long</stmt> antes que a operação seja realizada.</introducao>		<resposta valor="v"/>	</questao>	<questao id="468" objetivo="5.1">		<introducao>Para um operador binário, se ambos os operandos são            inteiros e não são do tipo <stmt>long</stmt>, então ambos            são convertidos para o tipo <stmt>int</stmt> antes que a            operação seja executada.</introducao>		<resposta valor="v"/>	</questao>	<questao id="469" objetivo="5.1">		<introducao>Se a <stmt>String</stmt> produzida por            <stmt>Integer.toHexString(~k+1)</stmt> é <stmt>80</stmt>,            então pode-se afirmar que o valor decimal armazenado na            variável <stmt>k</stmt> do tipo <stmt>byte</stmt> é <stmt>-128</stmt>		</introducao>		<resposta valor="v">O valor hexadecimal 80 representa o            decimal 128.  Observe que 128 foi obtido por meio da negação            bit a bit do valor em <stmt>k</stmt> seguido do posterior            acréscimo de uma unidade, o que significa que o valor em            <stmt>k</stmt> é -128, pois são estas as operações            necessárias para se determinar o valor armazenado em uma            variável inteira com sinal.</resposta>	</questao>	<questao id="470" objetivo="4.1">		<introducao>Em Java, nomes são empregados para se referir a            entidades declaradas em um programa.</introducao>		<resposta valor="v"/>	</questao>	<questao id="471" objetivo="4.1">		<introducao>Um pacote (<it>package</it>), uma classe, uma            interface, um método, um campo de interface ou classe,            parâmetros de método, construtor ou tratador de exceção                (<it>exception handler</it>) e uma variável local são            exemplos de entidades em Java que são referenciadas pelos            seus nomes.</introducao>		<resposta valor="v"/>	</questao>	<questao id="472" objetivo="4.1">		<introducao>Toda declaração que introduz um nome tem um escopo.</introducao>		<resposta valor="v"/>	</questao>	<questao id="473" objetivo="4.1">		<introducao>Escopo (<it>scope</it>) é o nome de uma parte do            texto de um programa no qual uma entidade pode ser            referenciada por um nome simples.</introducao>		<resposta valor="v"/>	</questao>	<questao id="474" objetivo="4.1">		<introducao>Controle de acesso pode ser especificado na            declaração de uma classe, interface, método ou campo, para            determinar quando o acesso à entidade em questão é permitida.</introducao>		<resposta valor="v"/>	</questao>	<questao id="475" objetivo="1.2">		<introducao>Controle de acesso e escopo são sinônimos.</introducao>		<resposta valor="f">Escopo estabelece uma &quot;região&quot;            de um programa onde uma entidade é conhecida pelo seu nome.            Controle de acesso, por outro lado, é mecanismo para            prevenir usuários de acesso desnecessário ou que se deve            evitar a uma entidade.</resposta>	</questao>	<questao id="476" objetivo="4.1">		<introducao>Uma declaração introduz uma entidade em um programa            e inclui um identificador. O identificador pode ser            utilizado, em um nome, para fazer referência à entidade.</introducao>		<resposta valor="v"/>	</questao>	<questao id="477" objetivo="4.6">		<introducao>O campo <stmt>length</stmt> é um membro de todo tipo            <it>array</it> e <stmt>String</stmt>.</introducao>		<resposta valor="f">			<stmt>String</stmt> não tem campo <stmt>length</stmt>, mas o            método <stmt>length()</stmt>.</resposta>	</questao>	<questao id="478" objetivo="4.1">		<introducao>Um nome é usado para referenciar uma entidade            declarada em um programa.</introducao>		<resposta valor="v"/>	</questao>	<questao id="479" objetivo="4.1">		<introducao>Há dois tipos de nomes em Java: nomes simples e            nomes qualificados.</introducao>		<resposta valor="v"/>	</questao>	<questao id="480" objetivo="4.1">		<introducao>Em Java, um nome simples é um único identificador,            que pode fazer uso da notação usando o ponto como em <stmt>java.lang.String</stmt>.</introducao>		<resposta valor="f">O exemplo é de um nome qualificado.</resposta>	</questao>	<questao id="481" objetivo="4.1">		<introducao>Nem todos os identificadores em um programa são            parte de um nome.</introducao>		<resposta valor="v"/>	</questao>	<questao id="482" objetivo="4.1">		<introducao>Um nome qualificado é uma seqüência de            identificadores separados por pontos.</introducao>		<resposta valor="v"/>	</questao>	<questao id="483" objetivo="4.1">		<introducao>Membros de uma classe são declarados quando da            declaração da classe ou são herdados.</introducao>		<resposta valor="v"/>	</questao>	<questao id="484" objetivo="1.3">		<introducao>Construtores não são membros.</introducao>		<resposta valor="v"/>	</questao>	<questao id="485" objetivo="1.2">		<introducao>Membros de uma classe incluem os construtores desta classe.</introducao>		<resposta valor="f"/>	</questao>	<questao id="486" objetivo="1.2">		<introducao>Uma classe não pode ter dois ou mais campos com os            mesmos nomes simples.</introducao>		<resposta valor="f">Basta que estes nomes sejam declarados            em diferentes interfaces ou sejam herdados.</resposta>	</questao>	<questao id="487" objetivo="4.1">		<introducao>Dois métodos cujos tipos de retorno sejam distintos            não possuem a mesma assinatura.</introducao>		<resposta valor="f">O tipo de retorno não é relevante para a            assinatura de um método.</resposta>	</questao>	<questao id="488" objetivo="4.1">		<introducao>Um pacote, em determinado contexto, pode não estar acessível.</introducao>		<resposta valor="f"/>	</questao>	<questao id="489">		<introducao>Um membro declarado como <stmt>protected</stmt>		</introducao>		<resposta valor="">ENUNCIADO INCOMPLETO.</resposta>	</questao>	<questao id="490" objetivo="4.1">		<introducao>Exceto a classe <stmt>Object</stmt>, todas as demais            são extensões (ou seja, são subclasses) de uma única classe</introducao>		<resposta valor="v"/>	</questao>	<questao id="491" objetivo="6.3">		<introducao>Uma classe aninhada é uma classe cuja declaração            ocorre no interior de outra classe ou de uma interface.</introducao>		<resposta valor="v"/>	</questao>	<questao id="492" objetivo="6.3">		<introducao>Uma classe de nível superior (<it>top level</it>) é            uma classe que não é aninhada.</introducao>		<resposta valor="v"/>	</questao>	<questao id="493" objetivo="1.2">		<introducao>Uma classe que não é completamente implementada onde            é declarada deve ser, necessariamente, declarada como <stmt>abstract</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="494" objetivo="1.2">		<introducao>Os modificadores de acesso explícitos incluem            <stmt>public</stmt>, <stmt>protected</stmt> e <stmt>private</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="495" objetivo="1.3">		<introducao>Um construtor pode ser declarado <stmt>private</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="496" objetivo="1.3">		<introducao>Um construtor pode ser declarado <stmt>protected</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="497" objetivo="1.2">		<introducao>A declaração de uma classe possivelmente inclui zero            ou mais dos modificadores <stmt>public</stmt>,            <stmt>protected</stmt>, <stmt>private</stmt>,            <stmt>strictfp</stmt>, <stmt>abstract</stmt>,            <stmt>final</stmt> e <stmt>static</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="498" objetivo="1.2">		<introducao>Apenas classes declaradas como <stmt>abstract</stmt>            podem conter métodos <stmt>abstract</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="499" objetivo="1.2">		<introducao>Uma classe que não é <stmt>abstract</stmt> e contém            um método <stmt>abstract</stmt> gera um erro em tempo de compilação.</introducao>		<resposta valor="v"/>	</questao>	<questao id="500" objetivo="1.2">		<introducao>Uma classe derivada de uma classe            <stmt>abstract</stmt> necessariamente deve implementar todos            os métodos declarados como <stmt>abstract</stmt> da classe herdada.</introducao>		<resposta valor="f"/>	</questao>	<questao id="501" objetivo="6.2">		<introducao>Uma classe declarada como <stmt>final</stmt> não            pode possuir subclasses.</introducao>		<resposta valor="v">Todos os métodos em classe <stmt>final</stmt> são implicitamente<stmt>final.</stmt>		</resposta>	</questao>	<questao id="502" objetivo="6.2">		<introducao>Os métodos de uma classe <stmt>final</stmt> podem            ser sobrepostos (<it>overriden</it>).</introducao>		<resposta valor="f"/>	</questao>	<questao id="503" objetivo="4.4">		<introducao>			<stmt>inherits</stmt> é palavra reservada de Java.</introducao>		<resposta valor="f"/>	</questao>	<questao id="504" objetivo="4.4">		<introducao>			<stmt>protect</stmt> é palavra reservada.</introducao>		<resposta valor="f">			<stmt>protected</stmt> é palavra reservada.</resposta>	</questao>	<questao id="505" objetivo="4.4">		<introducao>			<stmt>synchronize</stmt> é palavra reservada.</introducao>		<resposta valor="f">			<stmt>synchronized</stmt> é uma palavra reservada.</resposta>	</questao>	<questao id="506" objetivo="4.4">		<introducao>Pelo meno uma das palavras reservadas de Java possui            uma letra maiúscula.</introducao>		<resposta valor="f">Todas as palavras chaves possuem todas as letras minúsculas.</resposta>	</questao>	<questao id="507" objetivo="4.4">		<introducao>			<stmt>overload</stmt> é palavra reservada.</introducao>		<resposta valor="f"/>	</questao>	<questao id="508" objetivo="4.4">		<introducao>			<stmt>unsigned</stmt> é palavra reservada.</introducao>		<resposta valor="f"/>	</questao>	<questao id="509" objetivo="4.4">		<introducao>			<stmt>signed</stmt> é palavra reservada.</introducao>		<resposta valor="f"/>	</questao>	<questao id="510" objetivo="4.4">		<introducao>			<stmt>virtual</stmt> é palavra reservada.</introducao>		<resposta valor="f"/>	</questao>	<questao id="511" qi="1" tipo="lógico" objetivo="4.4">		<introducao>			<stmt>friend</stmt> é palavra reservada.</introducao>		<resposta valor="f"/>	</questao>	<questao id="512" qi="1" tipo="lógico" objetivo="4.4">		<introducao>			<stmt>Private</stmt>, <stmt>Protected</stmt> e            <stmt>Public</stmt> são palavras reservadas.</introducao>		<resposta valor="f">			<stmt>private</stmt>, <stmt>protected</stmt> e            <stmt>public</stmt> são palavras reservadas.</resposta>	</questao>	<questao id="513" objetivo="6.1">		<introducao>O código abaixo não compila.<java><![CDATA[abstract class A {     abstract void a(); }abstract class B extends A {     void a() {} }]]></java>		</introducao>		<resposta valor="f"/>	</questao>	<questao id="514" objetivo="6.1">		<introducao>O código abaixo compila.<java><![CDATA[class A {     abstract void a(); }abstract class B extends A {     void a() {} }]]></java>		</introducao>		<resposta valor="f">Toda classe que contém um método            <stmt>abstract</stmt> deve ser declarada            <stmt>abstract</stmt> ou um erro em tempo de compilação é gerado.</resposta>	</questao>	<questao id="515" objetivo="6.1">		<introducao>Um método <stmt>abstract</stmt> de uma classe            <stmt>X</stmt> deve ser implementado por uma classe derivada            de <stmt>X</stmt> e que não é declarada <stmt>abstract</stmt>.</introducao>		<resposta valor="f">Uma classe declarada            <stmt>abstract</stmt> pode implementar ou não um método declarado            <stmt>abstract</stmt> de uma superclasse herdada.</resposta>	</questao>	<questao id="516">		<introducao>Uma classe declarada </introducao>		<resposta valor=""/>	</questao>	<questao id="517" objetivo="6.1">		<introducao>O código abaixo não compila.<java><![CDATA[abstract class A {     public int x;    abstract void a(); }abstract class B extends A {     void a() {} }class C extends B {}public class Teste {    public static void main(String[] args) {	Object o = new C();	System.out.println(((A)o).x);    }}]]></java>		</introducao>		<resposta valor="f"/>	</questao>	<questao id="518" qi="1" tipo="lógico" objetivo="2.4">		<introducao>O código abaixo, quando executado, gera a exceção <stmt>ClassCastException</stmt>.<java><![CDATA[abstract class A {     public int x;    abstract void a(); }abstract class B extends A {     void a() {} }class C extends B {}public class Teste {    public static void main(String[] args) {	Object o = new C();	System.out.println(((A)o).x);    }}]]></java>		</introducao>		<resposta valor="f"/>	</questao>	<questao id="519" qi="1" tipo="lógico" objetivo="2.4">		<introducao>O código abaixo, quando executado gera uma exceção            decorrente da operação de moldagem (<it>casting</it>), pois            a classe <stmt>A</stmt> é declarada como <stmt>abstract</stmt>.<java><![CDATA[abstract class A {     public int x;    abstract void a(); }class B extends A {     void a() {} }public class Teste {    public static void main(String[] args) {	Object o = new B();	A a = (A)o;	System.out.println(a.x);    }}]]></java>		</introducao>		<resposta valor="f"/>	</questao>	<questao id="520" qi="1" tipo="lógico" objetivo="6.2">		<introducao>Uma classe <stmt>X</stmt>, declarada            <stmt>final</stmt>, não permite que instâncias sejam criadas            da forma <stmt>new X()</stmt>. </introducao>		<resposta valor="f">Uma classe declarada<stmt>final</stmt> não pode possuir subclasses.</resposta>	</questao>	<questao id="521" objetivo="6.1">		<introducao>Uma classe <stmt>X</stmt>, declarada            <stmt>abstract</stmt>, não pode possuir subclasse.</introducao>		<resposta valor="f"/>	</questao>	<questao id="522" objetivo="6.1">		<introducao>Se uma classe declarada <stmt>abstract</stmt> é            herdada por uma subclasse não declarada            <stmt>abstract</stmt>, então a subclasse, em sua declaração,            faz uso da palavra reservada <stmt>implements</stmt>.</introducao>		<resposta valor="f">Usa-se a palavra reservada<stmt> extends.</stmt>		</resposta>	</questao>	<questao id="523" objetivo="4.1">		<introducao>Um método declarado <stmt>native</stmt> significa            que está implementado na linguagem de programação C.</introducao>		<resposta valor="f"/>	</questao>	<questao id="524" objetivo="6.1">		<introducao>O código abaixo compila e, quando executado, imprime            o valor zero na saída padrão.<java><![CDATA[class A {     public int x;}public class Teste extends A {    public static void main(String[] args) {	Object o = new Teste();	A a = (A)o;	System.out.println(a.x);    }}]]></java>		</introducao>		<resposta valor="v"/>	</questao>	<questao id="525" qi="1" tipo="lógico" objetivo="6.1">		<introducao>O código abaixo compila.<java><![CDATA[native class A {     public int x;}public class Teste extends A {    public static void main(String[] args) {	Object o = new Teste();	A a = (A)o;	System.out.println(a.x);    }}]]></java>		</introducao>		<resposta valor="f">O modificador <stmt>native</stmt> só se            aplica a métodos.</resposta>	</questao>	<questao id="526" qi="1" tipo="lógico" objetivo="6.1">		<introducao>O código abaixo compila.<java><![CDATA[class A {     public int x;    public native void a() {}}public class Teste extends A {    public static void main(String[] args) {	Object o = new Teste();	A a = (A)o;	System.out.println(a.x);    }}]]></java>		</introducao>		<resposta valor="f">Método declarado <stmt>native</stmt> não            pode possuir bloco de código (corpo).</resposta>	</questao>	<questao id="527" qi="1" tipo="lógico" objetivo="6.1">		<introducao>O código abaixo não compila.<java><![CDATA[class A {     public int x;    public native void a();}public class Teste extends A {    public static void main(String[] args) {	Object o = new Teste();	A a = (A)o;	System.out.println(a.x);    }}]]></java>		</introducao>		<resposta valor="f"/>	</questao>	<questao id="528" qi="1" tipo="lógico" objetivo="6.1">		<introducao>O código abaixo não compila.<java><![CDATA[class A {     public int x;    public native void a();}public class Teste extends A {    public static void main(String[] args) {	Object o = new Teste();	A a = (A)o;	a.a();	System.out.println(a.x);    }}]]></java>		</introducao>		<resposta valor="f">Embora compile, quando executado, gera            uma exceção: <stmt>UnsatisfiedLinkError</stmt>.</resposta>	</questao>	<questao id="529" qi="1" tipo="lógico" objetivo="6.1">		<introducao>O código abaixo não compila.<java><![CDATA[abstract class A {     public int x;    public native void a();}public class Teste extends A {    public static void main(String[] args) {	Object o = new Teste();	A a = (A)o;	System.out.println(a.x);    }}]]></java>		</introducao>		<resposta valor="f"/>	</questao>	<questao id="530" qi="1" tipo="lógico" objetivo="4.1">		<introducao>O código abaixo compila.<java><![CDATA[abstract class A {     public int x;    public abstract native void a();}public class Teste extends A {    public void a() {}    public static void main(String[] args) {	System.out.println( 10 );    }}]]></java>		</introducao>		<resposta valor="f">Um método não pode ser declarado            <stmt>native</stmt> e <stmt>abstract</stmt>.</resposta>	</questao>	<questao id="531" qi="1" tipo="lógico" objetivo="1.2">		<introducao>Um campo definido como <stmt>volatile</stmt> previne            este de ser serializado.</introducao>		<resposta valor="f">Para tal, o campo deve ser declarado            como <stmt>transient</stmt>.</resposta>	</questao>	<questao id="532" qi="1" tipo="lógico" objetivo="1.2">		<introducao>Para que um campo seja impedido de ser serializado,            este deve ser declarado <stmt>volatile</stmt>.</introducao>		<resposta valor="f">Deve ser declarado como <stmt>transient</stmt>.</resposta>	</questao>	<questao id="533" qi="1" tipo="lógico" objetivo="4.4">		<introducao>O tipo primitivo <stmt>bool</stmt> admite apenas            dois valores: <stmt>true</stmt> e <stmt>false</stmt>.</introducao>		<resposta valor="f">A palavra reservada escrita corretamente            é <stmt>boolean</stmt>.</resposta>	</questao>	<questao id="534" qi="1" tipo="lógico" objetivo="4.4">		<introducao>O código abaixo imprime o valor <stmt>false</stmt>.<java><![CDATA[class Super {     boolean super;    boolean getSuper() {	return super;    }}class SuperMan extends Super {}public class Teste extends A {    public static void main(String[] args) {	System.out.println( (new SuperMan()).getSuper() );    }}]]></java>		</introducao>		<resposta valor="f">A compilação falha, pois            <stmt>super</stmt> é palavra reservada.</resposta>	</questao>	<questao id="535" qi="1" tipo="lógico" objetivo="4.4">		<introducao>			<stmt>null</stmt>, <stmt>true</stmt> e <stmt>false</stmt>            são literais que não podem ser empregadas como            identificadores e devem ser tratadas como as demais palavras reservadas.</introducao>		<resposta valor="f">			<stmt>null</stmt>, <stmt>true</stmt> e <stmt>false</stmt> são palavras reservadas.</resposta>	</questao>	<questao id="536" objetivo="4.4">		<introducao>O código abaixo compila.<java><![CDATA[public class Teste {    public static void main(String[] args) {	long true = 23L;	System.out.println( true );    }}]]></java>		</introducao>		<resposta valor="f">Observe o emprego errado da literal            <stmt>true</stmt> (valor do tipo primitivo <stmt>boolean</stmt>).<stmt> true</stmt> é palavra reservada.            </resposta>	</questao>	<questao id="537" objetivo="4.4">		<introducao>A declaração de um método como <stmt>public</stmt>,            <stmt>protect</stmt> ou <stmt>private</stmt> permite            controlar o tipo de acesso ao método.</introducao>		<resposta valor="f">			<stmt>protect</stmt> não é modificador de acesso, ao            contrário de <stmt>protected</stmt>, sendo este uma palavra reservada.</resposta>	</questao>	<questao id="538" objetivo="4.4">		<introducao>A sentença <stmt>class A extend B implements                Interface {}</stmt> declara uma classe <stmt>A</stmt>            cuja superclasse é <stmt>B</stmt> e implementa a interface <stmt>Interface</stmt>.</introducao>		<resposta valor="f">O correto é <stmt>extends</stmt> e não            <stmt>extend</stmt>, como fornecido.</resposta>	</questao>	<questao id="539" qi="1" tipo="lógico" objetivo="4.4">		<introducao>			<stmt>external</stmt> é palavra reservada.</introducao>		<resposta valor="f"/>	</questao>	<questao id="540" qi="1" tipo="lógico" objetivo="4.4">		<introducao>			<stmt>define</stmt> é palavra reservada.</introducao>		<resposta valor="f"/>	</questao>	<questao id="541" qi="1" tipo="lógico" objetivo="4.4">		<introducao>Embora criticado por muitos, o emprego de            <stmt>goto</stmt> em Java é permitido.</introducao>		<resposta valor="f">			<stmt>goto</stmt> é uma palavra reservada, mas não é empregada por Java.</resposta>	</questao>	<questao id="542" qi="1" tipo="lógico" objetivo="4.4">		<introducao>			<stmt>const</stmt> é empregada na declaração de uma variável            cujo valor não pode ser alterado.</introducao>		<resposta valor="f">			<stmt>const</stmt> é uma palavra reservada, mas não é empregada por Java.</resposta>	</questao>	<questao id="543" qi="1" tipo="lógico" objetivo="4.4">		<introducao>Pode-se construir uma classe que empregue todas as            palavras reservadas de Java.</introducao>		<resposta valor="f">			<stmt>const</stmt> e <stmt>goto</stmt> são palavras            reservadas que não são empregadas por Java.</resposta>	</questao>	<questao id="544" qi="1" tipo="lógico" objetivo="4.4">		<introducao>			<stmt>const</stmt> e <stmt>goto</stmt> são palavras            reservadas que podem ser empregadas na definição do corpo de            um método.</introducao>		<resposta valor="f">Não podem ser empregadas, embora sejam            palavras reservadas.</resposta>	</questao>	<questao id="545" qi="1" tipo="lógico" objetivo="4.4">		<introducao>O código abaixo, quando executado, é executado em            intervalo de tempo finito.<java><![CDATA[public class Teste {    public static void main(String[] args) {	boolean final = false;	while ( !final ) {	    final = !final;	}    }}]]></java>		</introducao>		<resposta valor="f">A compilação do código acima falha pela            tentativa de empregar a palavra reservada <stmt>final</stmt>            como identificador.</resposta>	</questao>	<questao id="546" qi="1" tipo="lógico" objetivo="4.4">		<introducao>O código abaixo imprime, quando executado, a            seqüência de caracteres correspondente ao literal            <stmt>false</stmt> do tipo <stmt>boolean</stmt>.</introducao>		<resposta valor="f">O código não compila. Observe que há            tentativa de empregar a palavra reservada <stmt>do</stmt>            como identificador.</resposta>	</questao>	<questao id="547" qi="1" tipo="lógico" objetivo="4.4">		<introducao>			<stmt>abstract</stmt>, <stmt>char</stmt>,            <stmt>double</stmt> e <stmt>String</stmt> são todas palavras reservadas.</introducao>		<resposta valor="f">			<stmt>String</stmt> não é palavra reservada.</resposta>	</questao>	<questao id="548" qi="1" tipo="lógico" objetivo="4.4">		<introducao>O código abaixo não compila.<java><![CDATA[public class Teste {    public static void main(String[] args) {	int String = 10;	System.out.println( String );    }}]]></java>		</introducao>		<resposta valor="f">			<stmt>String</stmt> não é palavra reservada.</resposta>	</questao>	<questao id="549" objetivo="4.4">		<introducao>			<stmt>for</stmt>, <stmt>int</stmt>, <stmt>private</stmt> e            <stmt>strictf</stmt> são todas palavras reservadas.</introducao>		<resposta valor="f">O correto é <stmt>strictfp</stmt>.</resposta>	</questao>	<questao id="550" qi="1" tipo="lógico" objetivo="4.4">		<introducao>			<stmt>throws</stmt>, <stmt>assert</stmt> e <stmt>case</stmt>            são palavras reservadas.</introducao>		<resposta valor="v"/>	</questao>	<questao id="551" qi="1" tipo="lógico" objetivo="4.4">		<introducao>			<stmt>assert</stmt> não é palavra reservada de Java, mas um            mecanismo que pode ser empregado para que, em determinado            ponto da execução de uma programa, uma condição, quando            avaliada como verdadeiro, não produza nenhum efeito. Por            outro lado, se a avaiação conduzir a um valor falso, então            um mensagem é emitida e a execução do programa é interrompida.</introducao>		<resposta valor="f">			<stmt>assert</stmt> é palavra reservada.</resposta>	</questao>	<questao id="552" qi="1" tipo="lógico" objetivo="4.4">		<introducao>O código abaixo compila.<java><![CDATA[public class Teste {    public static void main(String[] args) {	int assert = 10;	System.out.println( assert );    }}]]></java>		</introducao>		<resposta valor="f">			<stmt>assert</stmt> é palavra reservada.</resposta>	</questao>	<questao id="553" qi="1" tipo="lógico" objetivo="4.4">		<introducao>			<stmt>enabled</stmt> é palavra reservada.</introducao>		<resposta valor="f"/>	</questao>	<questao id="554" qi="1" tipo="lógico" objetivo="4.4">		<introducao>			<stmt>bool</stmt>, <stmt>class</stmt>, <stmt>else</stmt> e            <stmt>if</stmt> são palavras reservadas.</introducao>		<resposta valor="f">O correto é <stmt>boolean</stmt> e não            apenas <stmt>bool</stmt>.</resposta>	</questao>	<questao id="555" qi="1" tipo="lógico" objetivo="4.4">		<introducao>			<stmt>goto</stmt>, <stmt>const</stmt> e <stmt>assert</stmt>            são palavras reservadas.</introducao>		<resposta valor="v"/>	</questao>	<questao id="556" qi="1" tipo="lógico" objetivo="4.4">		<introducao>			<stmt>super</stmt>, <stmt>strictfp</stmt> e            <stmt>synchronize</stmt> são palavras reservadas.</introducao>		<resposta valor="f">O correto é <stmt>synchronized</stmt>.</resposta>	</questao>	<questao id="557" qi="1" tipo="lógico" objetivo="4.4">		<introducao>			<stmt>synchronized</stmt> e <stmt>protected</stmt> são            palavras reservadas.</introducao>		<resposta valor="v"/>	</questao>	<questao id="558" qi="1" tipo="lógico" objetivo="4.4">		<introducao>			<stmt>native</stmt>, <stmt>volatile</stmt> e            <stmt>strictfp</stmt> são palavras reservadas.</introducao>		<resposta valor="v"/>	</questao>	<questao id="559" qi="1" tipo="lógico" objetivo="4.4">		<introducao>			<stmt>transient</stmt>, <stmt>native</stmt> e            <stmt>volatile</stmt> não são palavras reservadas.</introducao>		<resposta valor="f"/>	</questao>	<questao id="560" qi="1" tipo="lógico" objetivo="4.4">		<introducao>			<stmt>throws</stmt> e <stmt>throw</stmt> são palavras reservadas.</introducao>		<resposta valor="v"/>	</questao>	<questao id="561" qi="1" tipo="lógico" objetivo="4.4">		<introducao>			<stmt>extend</stmt> e <stmt>implement</stmt> são palavras reservadas.</introducao>		<resposta valor="f">O correto é <stmt>extends</stmt> e <stmt>implements</stmt>.</resposta>	</questao>	<questao id="562" qi="1" tipo="lógico" objetivo="4.4">		<introducao>			<stmt>final</stmt> e <stmt>finally</stmt> são palavras reservadas.</introducao>		<resposta valor="v"/>	</questao>	<questao id="563" qi="1" tipo="lógico" objetivo="4.4">		<introducao>			<stmt>throws</stmt>, <stmt>extends</stmt> e            <stmt>implements</stmt> são palavras reservadas.</introducao>		<resposta valor="v"/>	</questao>	<questao id="564" qi="1" tipo="lógico" objetivo="4.4">		<introducao>			<stmt>continue</stmt> e <stmt>default</stmt> são palavras reservadas.</introducao>		<resposta valor="v"/>	</questao>	<questao id="565" qi="1" tipo="lógico" objetivo="4.4">		<introducao>			<stmt>break</stmt>, <stmt>goto</stmt>, <stmt>const</stmt>,            <stmt>assert</stmt> e <stmt>continue</stmt> são palavras reservadas.</introducao>		<resposta valor="v"/>	</questao>	<questao id="566" qi="1" tipo="lógico" objetivo="4.4">		<introducao>			<stmt>static</stmt> e <stmt>dynamic</stmt> são palavras reservadas.</introducao>		<resposta valor="f">Apenas <stmt>static</stmt>.</resposta>	</questao>	<questao id="567" qi="1" tipo="lógico" objetivo="4.4">		<introducao>			<stmt>try</stmt> e <stmt>this</stmt> são palavras reservadas.</introducao>		<resposta valor="v"/>	</questao>	<questao id="568" qi="1" tipo="lógico" objetivo="4.4">		<introducao>			<stmt>instanceof</stmt>, <stmt>interface</stmt> e            <stmt>imports</stmt> são palavras reservadas.</introducao>		<resposta valor="f">O correto é <stmt>import</stmt>.</resposta>	</questao>	<questao id="569" qi="1" tipo="lógico" objetivo="4.4">		<introducao>			<stmt>implements</stmt>, <stmt>extends</stmt> e            <stmt>catches</stmt> são palavras reservadas.</introducao>		<resposta valor="f">O correto é <stmt>catch</stmt>.</resposta>	</questao>	<questao id="570" qi="1" tipo="lógico" objetivo="4.4">		<introducao>			<stmt>do</stmt>, <stmt>native</stmt> e <stmt>include</stmt>            são palavras reservadas.</introducao>		<resposta valor="f">Apenas <stmt>do</stmt> e            <stmt>native</stmt> destas três são palavras reservadas.</resposta>	</questao>	<questao id="571" qi="1" tipo="lógico" objetivo="4.4">		<introducao>			<stmt>super</stmt>, <stmt>native</stmt>,            <stmt>volatile</stmt> e <stmt>synchronize</stmt> são            palavras reservadas.</introducao>		<resposta valor="f">O correto é <stmt>synchronized</stmt>.</resposta>	</questao>	<questao id="572" qi="1" tipo="lógico" objetivo="4.4">		<introducao>			<stmt>package</stmt>, <stmt>abstract</stmt>,            <stmt>else</stmt>, <stmt>interface</stmt> e            <stmt>transiente</stmt> são palavras reservadas.</introducao>		<resposta valor="f">O correto é <stmt>transient</stmt>.</resposta>	</questao>	<questao id="573" qi="1" tipo="lógico" objetivo="4.4">		<introducao>			<stmt>switch</stmt>, <stmt>case</stmt> e            <stmt>transiente</stmt> são palavrs reservadas.</introducao>		<resposta valor="f">O correto é <stmt>transient</stmt>.</resposta>	</questao>	<questao id="574" qi="1" tipo="lógico" objetivo="4.4">		<introducao>			<stmt>byte</stmt> e <stmt>boolean</stmt> são palavras reservadas.</introducao>		<resposta valor="v"/>	</questao>	<questao id="575" qi="1" tipo="lógico" objetivo="4.4">		<introducao>			<stmt>Character</stmt>, <stmt>byte</stmt> e            <stmt>boolean</stmt> são palavras reservadas.</introducao>		<resposta valor="f">			<stmt>Character</stmt> não é palavra reservada.</resposta>	</questao>	<questao id="576" qi="1" tipo="lógico" objetivo="4.1">		<introducao>			<stmt>String</stmt> é identificador válido.</introducao>		<resposta valor="v"/>	</questao>	<questao id="577" qi="1" tipo="lógico" objetivo="4.1">		<introducao>			<stmt>Boolean</stmt> é identificador válido.</introducao>		<resposta valor="v">			<stmt>boolean</stmt> é uma palavra reservada.</resposta>	</questao>	<questao id="578" objetivo="4.6">		<introducao>			<stmt>Integer</stmt> é tipo primitivo.</introducao>		<resposta valor="f">O correto é <stmt>int</stmt>.</resposta>	</questao>	<questao id="579" qi="1" tipo="lógico" objetivo="4.6">		<introducao>			<stmt>Double</stmt> é identificador válido.</introducao>		<resposta valor="v"/>	</questao>	<questao id="580" qi="1" tipo="lógico" objetivo="4.1">		<introducao>			<stmt>goto</stmt> é identificador válido.</introducao>		<resposta valor="f">			<stmt>goto</stmt> é uma palavra reservada, mas não é utilizada por Java.</resposta>	</questao>	<questao id="581" objetivo="4.1">		<introducao>			<stmt>const</stmt> é um identificador válido.</introducao>		<resposta valor="f">			<stmt>const</stmt> é uma palavra reservada, mas não é utilizada por Java.</resposta>	</questao>	<questao id="582" qi="1" tipo="lógico" objetivo="4.1">		<introducao>			<stmt>synchronize</stmt> é identificador válido.</introducao>		<resposta valor="v">Observe que            <stmt>synchronized</stmt> é palavra reservada.</resposta>	</questao>	<questao id="583" qi="1" tipo="lógico" objetivo="4.1">		<introducao>			<stmt>instanceOf</stmt> é identificador válido.</introducao>		<resposta valor="v">			<stmt>instanceof</stmt> é uma palavra reservada.</resposta>	</questao>	<questao id="584" objetivo="4.1">		<introducao>			<stmt>transiente</stmt> é identificador válido.</introducao>		<resposta valor="v">			<stmt>transient</stmt> é uma palavra reservada.</resposta>	</questao>	<questao id="585" objetivo="4.1">		<introducao>			<stmt>transient</stmt> é identificador válido.</introducao>		<resposta valor="f">			<stmt>transient</stmt> é palavra reservada.</resposta>	</questao>	<questao id="586" objetivo="4.1">		<introducao>			<stmt>null</stmt> é identificador válido.</introducao>		<resposta valor="f">			<stmt>null</stmt> é uma palavra reservada.</resposta>	</questao>	<questao id="587" objetivo="4.1">		<introducao>			<stmt>false</stmt> é identificador válido.</introducao>		<resposta valor="f">			<stmt>false</stmt> é uma palavra reservada.</resposta>	</questao>	<questao id="588" objetivo="4.1">		<introducao>			<stmt>true</stmt> é identificador válido.</introducao>		<resposta valor="f">			<stmt>true</stmt> é uma palavra reservada.</resposta>	</questao>	<questao id="589" objetivo="4.1">		<introducao>			<stmt>final</stmt> é identificador válido.</introducao>		<resposta valor="f">			<stmt>final</stmt> é uma palavra reservada.</resposta>	</questao>	<questao id="590" objetivo="4.1">		<introducao>			<stmt>finale</stmt> não é identificador válido.</introducao>		<resposta valor="f">A palavra reservada            &quot;homógrafa&quot; é <stmt>finally</stmt>.</resposta>	</questao>	<questao id="591" qi="1" tipo="lógico" objetivo="4.1">		<introducao>Palavras reservadas não podem ser utilizadas como            identificadores de classes, métodos e variáveis.</introducao>		<resposta valor="v"/>	</questao>	<questao id="592" qi="1" tipo="lógico" objetivo="4.4">		<introducao>Todas as palavras reservadas estão escritas            exclusivamente em letras minúsculas.</introducao>		<resposta valor="v"/>	</questao>	<questao id="593" qi="1" tipo="lógico" objetivo="4.4">		<introducao>Algumas palavras reservadas como            <stmt>boolean</stmt> e <stmt>double</stmt>, por exemplo,            possuem versões equivalentes com a inicial maiúscula.</introducao>		<resposta valor="f">Todas as palavras reservadas são            escritas exclusivamente em minúsculas.</resposta>	</questao>	<questao id="594" qi="1" tipo="lógico" objetivo="4.4">		<introducao>			<stmt>instanceOf</stmt> é uma palavra reservada que possui,            embora não seja a primeira letra, uma letra escrita em maiúscula.</introducao>		<resposta valor="f">			<stmt>instanceOf</stmt> é um identificador válido, enquanto            <stmt>instanceof</stmt> é palavra reservada.</resposta>	</questao>	<questao id="595" qi="1" tipo="lógico" objetivo="4.4">		<introducao>			<stmt>byte</stmt>, <stmt>short</stmt>, <stmt>integer</stmt>            e <stmt>long</stmt> são palavras reservadas.</introducao>		<resposta valor="f">O correto é <stmt>int</stmt>.</resposta>	</questao>	<questao id="596" qi="1" tipo="lógico" objetivo="4.4">		<introducao>			<stmt>reserved</stmt> é palavra reservada.</introducao>		<resposta valor="f"/>	</questao>	<questao id="597" qi="1" tipo="lógico" objetivo="4.4">		<introducao>			<stmt>default</stmt> e <stmt>continues</stmt> são palavras reservadas.</introducao>		<resposta valor="f">O correto é <stmt>continue</stmt>.</resposta>	</questao>	<questao id="598" qi="1" tipo="lógico" objetivo="4.4">		<introducao>			<stmt>asserts</stmt> e <stmt>return</stmt> são palavras reservadas.</introducao>		<resposta valor="f">O correto é <stmt>assert</stmt>.</resposta>	</questao>	<questao id="599" qi="1" tipo="lógico" objetivo="4.1">		<introducao>			<stmt>break</stmt> e <stmt>instanceOf</stmt> são            identificadores válidos.</introducao>		<resposta valor="f">			<stmt>break</stmt> é palavra reservada.</resposta>	</questao>	<questao id="600" qi="1" tipo="lógico" objetivo="4.1">		<introducao>			<stmt>catch</stmt>, <stmt>break</stmt> e <stmt>begin</stmt>            são palavras reservadas.</introducao>		<resposta valor="f">			<stmt>begin</stmt> é identificador válido.</resposta>	</questao>	<questao id="601" objetivo="4.1">		<introducao>			<stmt>with</stmt> e <stmt>synchronized</stmt> são palavras reservadas.</introducao>		<resposta valor="f">			<stmt>with</stmt> é identificador válido.</resposta>	</questao>	<questao id="602" objetivo="4.6">		<introducao>Os tipos primtivitos include <stmt>byte</stmt>,            <stmt>short</stmt>, <stmt>int</stmt>, <stmt>long</stmt>,            <stmt>float</stmt>, <stmt>double</stmt>, <stmt>char</stmt> e <stmt>boolean</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="603" objetivo="4.6">		<introducao>Os tipos primitivos numéricos, ou seja,            <stmt>byte</stmt>, <stmt>short</stmt>, <stmt>int</stmt>,            <stmt>long</stmt>, <stmt>float</stmt> e <stmt>double</stmt>            são tipos com sinal (<it>singed</it>). Ou seja, valores            deste tipo podem ser negativos ou positivos.</introducao>		<resposta valor="v"/>	</questao>	<questao id="604" objetivo="4.6">		<introducao>Os tipos com sinal em Java usam o bit mais a            esquerda, o bit mais significativo, para representar o            sinal. Quando este bit é 1, o número é negativo, caso            contrário, o número é positivo (o que inclui o zero).</introducao>		<resposta valor="v"/>	</questao>	<questao id="605" objetivo="4.6">		<introducao>Em Java, os tipos com sinal usam a notação de            complemento de dois para representá-los internamente. </introducao>		<resposta valor="v"/>	</questao>	<questao id="606" objetivo="4.6">		<introducao>O tipo primitivo <stmt>byte</stmt> representa um            conjunto de 256 valores, correspondentes a 2 elevado a 8.            Destes 256 valores, 128 são negativos, de -128 até -1. Os            outros 128 valores vão de 0 a 127.</introducao>		<resposta valor="v"/>	</questao>	<questao id="607" objetivo="4.6">		<introducao>Uma variável do tipo primitivo <stmt>short</stmt>            faz uso de 16 bits para representar números deste tipo.            Estes 16 bits permitem representar 2 elevado a 16 números,            ou 65536 valores distintos. Destes, 32768 valores são            negativos e os demais 32768 são positivos. Os negativos vão            de -32768 até -1, enquanto os positivos vão de 0 até 32767</introducao>		<resposta valor="v"/>	</questao>	<questao id="608" objetivo="4.6">		<introducao>Quando se escreve um valor do tipo <stmt>int</stmt>,            <stmt>boolean</stmt> ou outro, em Java, diz-se que o que            você escreve é uma literal.</introducao>		<resposta valor="v"/>	</questao>	<questao id="609" objetivo="4.6">		<introducao>Há três formas de representar números inteiros em            Java: decimal (base 10), octal (base 8) e hexadecimal (base 16).</introducao>		<resposta valor="v"/>	</questao>	<questao id="610" objetivo="4.6">		<introducao>Números inteiros na base 10, em Java, são            representados normalmente como em muitos outros cenários,            por exemplo, <stmt>-10</stmt>, <stmt>26</stmt> e            <stmt>32767</stmt> são literais inteiras na representação decimal.</introducao>		<resposta valor="v"/>	</questao>	<questao id="611" objetivo="4.6">		<introducao>Números na base octal fazem uso apenas dos dígitos            de 0 a 7, inclusive.</introducao>		<resposta valor="v"/>	</questao>	<questao id="612" objetivo="4.6">		<introducao>Um número em octal na linguagem de programação Java            é necessariamente iniciado por um zero.</introducao>		<resposta valor="v"/>	</questao>	<questao id="613" objetivo="4.6">		<introducao>São exemplos de números inteiros na base octal em            Java as seguintes literais: <stmt>00</stmt> e <stmt>01234567</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="614" objetivo="4.6">		<introducao>A literal Java <stmt>032386</stmt> corresponde a            um inteiro na base octal.</introducao>		<resposta valor="f">Observe o dígito <stmt>8</stmt>, não            permitido em números na base octal.</resposta>	</questao>	<questao id="615" objetivo="4.1">		<introducao>O código abaixo não imprime a mensagem            <stmt>ok</stmt> quando executado.<java><![CDATA[public class Literal11 {    public static void main(String[] args) {        int sete = 07;        int treze = 015;        int vinte = 20;        if ( vinte == (sete + treze) ) {            System.out.println("ok");        }    }}]]></java>		</introducao>		<resposta valor="v">Observe que as variáveis            <stmt>sete</stmt> e <stmt>treze</stmt> foram iniciadas com            literais inteiras no formato octal. Neste caso, o código nem compila e nem será executado.</resposta>	</questao>	<questao id="616" objetivo="4.6">		<introducao>Em Java, a igualdade <stmt>-2 == (8 - 010)</stmt> é verdadeira.</introducao>		<resposta valor="f">Observe que<stmt>010</stmt> é literal no formato octal cujo valor decimal correspondente é 8.</resposta>	</questao>	<questao id="617" objetivo="4.6">		<introducao>A condição <stmt>(1000-0001) == 0999</stmt> é verdadeira.</introducao>		<resposta valor="f">Observe que <stmt>0001</stmt> e            <stmt>0999</stmt> deveriam, ambos ser números na            representação octal. O último deles não é uma literal válida.</resposta>	</questao>	<questao id="618" objetivo="4.6">		<introducao>A condição <stmt>(100-020)==80</stmt> é verdadeira.</introducao>		<resposta valor="f">Observe que <stmt>020</stmt> é literal            no formato octal cujo valor decimal correspondente é 16.</resposta>	</questao>	<questao id="619" objetivo="4.6">		<introducao>Literais na representação hexadecimal empregam todos            os dígitos empregados na representação decimal acrescidos            dos caracteres alfabéticos <stmt>a</stmt>, <stmt>b</stmt>,            <stmt>c</stmt>, <stmt>d</stmt>, <stmt>e</stmt> e, por            último, <stmt>f</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="620" objetivo="4.6">		<introducao>Os dígitos hexadecimais representam 16 valores            possíveis, do 0 ao 15.</introducao>		<resposta valor="v"/>	</questao>	<questao id="621" objetivo="4.6">		<introducao>Toda literal na representação hexadecimal contém o            prefixo <stmt>0x</stmt> ou <stmt>0X</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="622" objetivo="4.6">		<introducao>			<stmt>0xCafe</stmt> é uma literal válida.</introducao>		<resposta valor="v"/>	</questao>	<questao id="623" objetivo="4.6">		<introducao>			<stmt>0xfe</stmt> é uma literal válida.</introducao>		<resposta valor="v"/>	</questao>	<questao id="624" objetivo="4.6">		<introducao>			<stmt>0xBabel</stmt> é uma literal válida.</introducao>		<resposta valor="v"/>	</questao>	<questao id="625" objetivo="4.6">		<introducao>			<stmt>0xFaca</stmt> é uma literal válida.</introducao>		<resposta valor="v"/>	</questao>	<questao id="626" objetivo="4.6">		<introducao>O texto <stmt>0xB0CA</stmt> representa uma literal            válida em Java.</introducao>		<resposta valor="v"/>	</questao>	<questao id="627" objetivo="4.6">		<introducao>Todas as literais inteiras são, exceto se            especificado o contrário, do tipo <stmt>int</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="628" objetivo="4.6">		<introducao>A literal <stmt>0xal</stmt> representa o valor 10 do            tipo <stmt>long</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="629" objetivo="4.6">		<introducao>Literais na notação ponto-flutuante são do tipo            <stmt>double</stmt> por <it>default</it>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="630" objetivo="4.6">		<introducao>A literal <stmt>1.0</stmt> representa um valor do            tipo <stmt>float</stmt> ou <stmt>double</stmt>.</introducao>		<resposta valor="f">Apenas <stmt>double</stmt>.</resposta>	</questao>	<questao id="631" objetivo="4.6">		<introducao>A literal <stmt>2.64</stmt> representa um valor do            tipo <stmt>double</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="632" objetivo="4.6">		<introducao>As literais <stmt>1</stmt>, <stmt>024</stmt> e            <stmt>0xC0CA</stmt> representam valores do tipo <stmt>int</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="633" objetivo="4.6">		<introducao>O sufixo <stmt>L</stmt> ou <stmt>l</stmt> pode ser            empregado para representar uma literal do tipo            <stmt>long</stmt>, independente da representação ser            decimal, octal ou hexadecimal.</introducao>		<resposta valor="v"/>	</questao>	<questao id="634" objetivo="4.6">		<introducao>A literal <stmt>010L</stmt> representa o valor 8 do            tipo <stmt>long</stmt>		</introducao>		<resposta valor="v"/>	</questao>	<questao id="635" objetivo="4.6">		<introducao>A literal <stmt>0144L</stmt> representa o valor            decimal 100 do tipo <stmt>long</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="636" objetivo="4.6">		<introducao>Valores do tipo <stmt>byte</stmt> fazem uso de 8            bits para serem representados.</introducao>		<resposta valor="v"/>	</questao>	<questao id="637" objetivo="4.6">		<introducao>Valores do tipo <stmt>short</stmt> fazem uso de 16            bits para serem representados.</introducao>		<resposta valor="v"/>	</questao>	<questao id="638" objetivo="4.6">		<introducao>Valores do tipo <stmt>int</stmt> fazem uso de 32            bits para serem representados.</introducao>		<resposta valor="v"/>	</questao>	<questao id="639" objetivo="4.6">		<introducao>Valores do tipo <stmt>long</stmt> fazem uso de 64            bits para serem representados.</introducao>		<resposta valor="v"/>	</questao>	<questao id="640" objetivo="4.6">		<introducao>Valores do tipo <stmt>float</stmt> fazem uso de 32            bits para serem representados.</introducao>		<resposta valor="v"/>	</questao>	<questao id="641" objetivo="4.6">		<introducao>Valores do tipo <stmt>double</stmt> fazem uso de 64            bits para serem representados.</introducao>		<resposta valor="v"/>	</questao>	<questao id="642" objetivo="4.6">		<introducao>Valores do tipo <stmt>float</stmt> e            <stmt>int</stmt> fazem uso de 4 bytes para serem representados.</introducao>		<resposta valor="v"/>	</questao>	<questao id="643" objetivo="4.6">		<introducao>Valores do tipo <stmt>long</stmt> e            <stmt>double</stmt> fazem uso de 8 bits para serem representados.</introducao>		<resposta valor="f">Fazem uso de 8 bytes.</resposta>	</questao>	<questao id="644" objetivo="4.6">		<introducao>O tipo <stmt>short</stmt> representa um conjunto com            o dobro do número de elementos daquele representado pelo            tipo <stmt>byte</stmt>.</introducao>		<resposta valor="f">O tipo short é representado pelo dobro do número de bits em relação ao tipo byte.</resposta>	</questao>	<questao id="645" objetivo="4.6">		<introducao>O tipo <stmt>short</stmt> representa um conjunto com            o quadrado do número de elementos daquele representado pelo            tipo <stmt>byte</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="646" objetivo="4.6">		<introducao>Nem todo valor do tipo <stmt>float</stmt> tem            correspondente exato do tipo <stmt>int</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="647" objetivo="4.1">		<introducao>Se <stmt>x</stmt> e <stmt>y</stmt> armazenam valores            do tipo <stmt>int</stmt> e sabe-se que o valor inteiro            armazenado em <stmt>x</stmt> é diferente daquele armazenado            em <stmt>y</stmt>, então os valores correspondentes,            convertidos para o tipo <stmt>float</stmt> também são distintos.</introducao>		<resposta valor="f">Experimente, por exemplo, os valores            -2147482724 e -2147482725. Quando convertidos para            <stmt>float</stmt>, os valores convertidos são iguais.</resposta>	</questao>	<questao id="648" objetivo="4.1">		<introducao>Todos os possíveis valores que uma variável do tipo            <stmt>float</stmt> pode assumir podem ser contados com uma            variável do tipo <stmt>int</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="649" objetivo="4.6">		<introducao>Todo valor do tipo <stmt>int</stmt> possui um            correspondente exato do tipo <stmt>float</stmt>.</introducao>		<resposta valor="f">Caso contrário, todos os valores seriam inteiros.</resposta>	</questao>	<questao id="650" objetivo="4.6">		<introducao>Todo valor do tipo <stmt>long</stmt> possui um            correspondente exato do tipo <stmt>double</stmt>.</introducao>		<resposta valor="f">Caso contrário, todos os valores seriam inteiros.</resposta>	</questao>	<questao id="651" objetivo="4.6">		<introducao>Nem todo valor do tipo <stmt>float</stmt> pode ser            representado sem perda de precisão por um valor do tipo <stmt>int</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="652" objetivo="4.6">		<introducao>Nem todo valor do tipo <stmt>float</stmt> pode ser            representado sem perda de precisão por um valor do tipo <stmt>long</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="653" objetivo="4.6">		<introducao>Nem todo valor do tipo <stmt>long</stmt> pode ser            representado sem perda de precisão por um valor do tipo <stmt>int</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="654" objetivo="4.6">		<introducao>Nem todo valor do tipo <stmt>byte</stmt> pode ser            representado sem perda de precisão por um valor do tipo <stmt>int</stmt>.</introducao>		<resposta valor="f">O tipo nativo byte não pode representar casas decimais jamais. Qualquer variável do tipo byte pode representar valores inteiros havendo perda de precisão.</resposta>	</questao>	<questao id="655" objetivo="4.6">		<introducao>Nem todo valor do tipo <stmt>int</stmt> pode ser            representado sem perda de precisão por um valor do tipo <stmt>long</stmt>.</introducao>		<resposta valor="f">Variáveis do tipo int representam valores numéricos inteiros. Se houver necessidade, pode ocorrer perda de precisão durante uma operação.</resposta>	</questao>	<questao id="656" objetivo="4.6">		<introducao>Nem todo valor do tipo <stmt>short</stmt> pode ser            representado sem perda de precisão por um valor do tipo <stmt>float</stmt>.</introducao>		<resposta valor="f">Qualquer variável do tipo short pode representar valores inteiros com perda de precisão. O tipo float só aceita valores sem precisão exta.</resposta>	</questao>	<questao id="657" objetivo="4.6">		<introducao>Nem todo valor do tipo <stmt>short</stmt> pode ser            representado sem perda de precisão por um valor do tipo <stmt>int</stmt>.</introducao>		<resposta valor="f">Qualquer variável do tipo short pode representar valores do tipo int com perda de precisão.</resposta>	</questao>	<questao id="658" objetivo="4.6">		<introducao>Literais ponto-flutuante em Java podem fazer uso de vírgula.</introducao>		<resposta valor="f">Fazem uso somente do ponto.</resposta>	</questao>	<questao id="659" objetivo="4.6">		<introducao>Literais ponto-flutuante em Java podem fazer uso de ponto.</introducao>		<resposta valor="v"/>	</questao>	<questao id="660" objetivo="4.6">		<introducao>Literais ponto-flutuante em Java podem fazer uso de            vírgula e de ponto, simultaneamente.</introducao>		<resposta valor="f">Fazem uso somente do ponto.</resposta>	</questao>	<questao id="661" objetivo="4.6">		<introducao>Uma literal ponto-flutuante em Java pode fazer uso            de mais de um ponto.</introducao>		<resposta valor="f">Fazem uso apenas de um ponto.</resposta>	</questao>	<questao id="662" objetivo="4.6">		<introducao>Em Java, o tipo que representa o menor conjunto            possível de valores é o tipo primitivo <stmt>boolean</stmt>,            que representa apenas dois valores.</introducao>		<resposta valor="f">O tipo <stmt>null</stmt> é menor.</resposta>	</questao>	<questao id="663" objetivo="4.6">		<introducao>O tipo em Java que possui o menor conjunto de            valores é o tipo <stmt>null</stmt>, que possui um único valor.</introducao>		<resposta valor="v"/>	</questao>	<questao id="664" objetivo="1.2">		<introducao>O código abaixo compila.<java><![CDATA[public class Boolean1 {    public static void main(String[] args) {        int x = 1;        int y = x ? -1 : 1;        System.out.println(y);    }}]]></java>		</introducao>		<resposta valor="f"/>	</questao>	<questao id="665" objetivo="1.2">		<introducao>O código abaixo, quando executado, deposita em            <stmt>y</stmt> a literal <stmt>-1</stmt>.<java><![CDATA[public class Boolean1 {    public static void main(String[] args) {        int x = 1;        int y = x ? -1 : 1;        System.out.println(y);    }}]]></java>		</introducao>		<resposta valor="f">O código não compila.</resposta>	</questao>	<questao id="666" objetivo="1.2">		<introducao>O código abaixo, quando executado, imprime a literal <stmt>true</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="667" objetivo="4.6">		<introducao>Uma literal do tipo <stmt>char</stmt> é representada            por um único caracteres entre aspas simples.</introducao>		<resposta valor="v"/>	</questao>	<questao id="668" objetivo="4.1">		<introducao>A declaração <stmt>char c = 'ab';</stmt> é válida em Java.</introducao>		<resposta valor="f">Variável do tipo básico char representa um único caracter por vez em java.</resposta>	</questao>	<questao id="669" objetivo="4.1">		<introducao>A declaração <stmt>char c = &quot;a&quot;;</stmt> é            válida em Java.</introducao>		<resposta valor="f">As aspas devem ser simples para o caso acima.</resposta>	</questao>	<questao id="670" objetivo="4.6">		<introducao>A literal correspondente a um caractere pode ser            fornecida através do valor UNICODE do caracteres.</introducao>		<resposta valor="v"/>	</questao>	<questao id="671" objetivo="4.1">		<introducao>			<stmt>char c = '\u0041';</stmt> é uma declaração válida em Java.</introducao>		<resposta valor="v"/>	</questao>	<questao id="672" objetivo="4.1">		<introducao>			<stmt>char c = '\x0041';</stmt> é uma declaração válida em Java.</introducao>		<resposta valor="f"/>	</questao>	<questao id="673" objetivo="4.1">		<introducao>As declarações <stmt>char c = '\u0041';</stmt> e                <stmt>char c = 0x0041</stmt> são equivalentes.</introducao>		<resposta valor="v"/>	</questao>	<questao id="674" objetivo="4.1">		<introducao>Embora muito exótico e que se deve evitar, pode-se            utilizar a declaração <stmt>char c =            (char)0xffff0041;</stmt> ou, em vez do número hexadecimal, o            número negativo correspondente em notação decimal, para            depositar na variável <stmt>c</stmt> a letra A, cuja literal            UNICODE correspondente é <stmt>'\u0041'</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="675" objetivo="4.1">		<introducao>Caracteres, ou valores do tipo primitivo            <stmt>char</stmt>, são inteiros positivos de 16 bits.            Qualquer número inteiro de 16 bits e que é maior que zero            pode ser utilizado para uma atribuição a variáveis do tipo <stmt>char</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="676" objetivo="4.1">		<introducao>Não se pode atribuir um valor inteiro negativo a uma            variável do tipo <stmt>char</stmt> porque o compilador            verifica que o número em questão está fora da faixa de            valores permitidos.</introducao>		<resposta valor="f">Pode atribuir mas, um erro de compilação será mostrado por exemplo, ERRO: valor inteiro com sinal diferente de char.</resposta>	</questao>	<questao id="677" objetivo="4.1">		<introducao>A declaração <stmt>char c = 66000;</stmt> provoca um            erro de compilação.</introducao>		<resposta valor="v">O tipo char é capaz de representar valores na faixa de 0 a 65535.</resposta>	</questao>	<questao id="678" objetivo="4.1">		<introducao>A declaração <stmt>char c = (char)66000;</stmt>            provoca um erro de compilação.</introducao>		<resposta valor="f">É uma declaração não válida e com valor inteiro diferente de char.</resposta>	</questao>	<questao id="679" objetivo="4.1">		<introducao>A declaração <stmt>char c = 0101;</stmt> provoca um            erro de compilação.</introducao>		<resposta valor="f"/>	</questao>	<questao id="680" objetivo="4.1">		<introducao>A declaração <stmt>char c = 0101;</stmt> deposita em            <stmt>c</stmt> o caractere cujo valor UNICODE corresponde ao            valor <stmt>101</stmt>.</introducao>		<resposta valor="f"/>	</questao>	<questao id="681" objetivo="4.1">		<introducao>Nem todos os caracteres podem ser digitados quando se declara strings, como o            caractere que indica uma nova linha, por exemplo.</introducao>		<resposta valor="v"/>	</questao>	<questao id="682" objetivo="4.1">		<introducao>Para definir a variável <stmt>c</stmt> do tipo            primitivo <stmt>char</stmt> e, no momento da declaração            iniciar esta variável com o caractere de &quot;nova            linha&quot; (<it>new line</it>), pode-se empregar uma            sentença como <stmt>char c = '\n';</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="683" objetivo="4.6">		<introducao>Uma literal <stmt>String</stmt> em Java é uma            seqüência de caracteres fornecida entre aspas duplas.</introducao>		<resposta valor="v"/>	</questao>	<questao id="684" objetivo="4.6">		<introducao>			<stmt>String</stmt> não é um tipo primitivo de Java.</introducao>		<resposta valor="v"/>	</questao>	<questao id="685" objetivo="4.6">		<introducao>			<stmt>Boolean</stmt> não é um tipo primitivo de Java.</introducao>		<resposta valor="v"/>	</questao>	<questao id="686" objetivo="4.6">		<introducao>Embora <stmt>String</stmt> não seja um tipo            primitivo, valores deste tipo podem ser representados como literais.</introducao>		<resposta valor="v"/>	</questao>	<questao id="687" objetivo="4.6">		<introducao>Embora o tipo <stmt>null</stmt> não seja um tipo            primitivo, o único valor deste tipo pode ser representado            como literal, o valor <stmt>null</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="688" objetivo="4.6">		<introducao>Dois tipos que não são primitivos, na linguagem de            programação Java, possuem literais que podem ser diretamente            digitados pelos programadores em código fonte nesta            linguagem. Estes tipos são: <stmt>String</stmt> e <stmt>null</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="689" objetivo="4.1">		<introducao>Um <it>array</it> é uma instância da classe            <stmt>Object</stmt> em Java.</introducao>		<resposta valor="v"/>	</questao>	<questao id="690" objetivo="4.5">		<introducao>Um <it>array</it> armazena múltiplas variáveis de um            mesmo tipo.</introducao>		<resposta valor="v"/>	</questao>	<questao id="691" objetivo="1.1">		<introducao>A declaração de uma <it>array</it> exige que seja            fornecido o tipo dos elementos que serão armazenados no <it>array</it>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="692" objetivo="4.5">		<introducao>Um <it>array</it> pode armazenar variáveis de um            tipo primitivo ou tipo referência.</introducao>		<resposta valor="v"/>	</questao>	<questao id="693" objetivo="1.1">		<introducao>Um <it>array</it> de inteiros cujo identificador é            <stmt>x</stmt> pode ser declarado com os colchetes            imediatamente após o tipo (<stmt>int[] x;</stmt>) ou com os            colchetes após o identificador (<stmt>int x[];).</stmt>		</introducao>		<resposta valor="v"/>	</questao>	<questao id="694" objetivo="1.1">		<introducao>A declaração <stmt>int [] x;</stmt> não é válida.</introducao>		<resposta valor="f"/>	</questao>	<questao id="695" objetivo="1.1">		<introducao>A declaração <stmt>int x [];</stmt> não é válida.</introducao>		<resposta valor="f"/>	</questao>	<questao id="696" objetivo="1.1">		<introducao>A declaração <stmt>int[]x;</stmt> não compila.</introducao>		<resposta valor="f"/>	</questao>	<questao id="697" objetivo="1.1">		<introducao>A declaração <stmt>int[]x;</stmt> seguida de <stmt>a                = new int[0];</stmt> gera um erro de compilação.</introducao>		<resposta valor="f">Cria um objeto array com zero elementos e cuja referência é depositada na variável a.</resposta>	</questao>	<questao id="698" objetivo="1.1">		<introducao>A declaração <stmt>int[]x;</stmt> seguida de <stmt>a                = new int[0];</stmt> cria um objeto <it>array</it> cuja            referência é depositada na variável <stmt>a</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="699" objetivo="1.1">		<introducao>A declaração <stmt>int[]x;</stmt> seguida de <stmt>a                = new int[0];</stmt> cria um objeto <it>array</it> com            zero elementos. Ou seja, a tentativa de usar qualquer            componente do <it>array</it> gera uma exceção.</introducao>		<resposta valor="v"/>	</questao>	<questao id="700" objetivo="7.1">		<introducao>As declarações <stmt>Thread[] threads;</stmt> e                <stmt>Thread threads[];</stmt> são equivalentes.</introducao>		<resposta valor="v"/>	</questao>	<questao id="701" objetivo="1.1">		<introducao>			<it>Arrays</it> são implementados em Java como objetos.</introducao>		<resposta valor="v"/>	</questao>	<questao id="702" objetivo="1.1">		<introducao>			<it>Arrays</it> multidimensionais são permitidos em Java            através de <it>arrays</it> de <it>arrays</it>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="703" objetivo="1.1">		<introducao>			<stmt>String[][] gerencia;</stmt> declara o <it>array</it>            identificado por <stmt>gerencia</stmt> cujos elementos são            <it>arrays</it> de <stmt>String</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="704" objetivo="1.1">		<introducao>			<stmt>int[] arrayInt[];</stmt> é uma declaração ilegal.</introducao>		<resposta valor="f"/>	</questao>	<questao id="705" objetivo="1.1">		<introducao>A compilação do código abaixo falha.<java><![CDATA[public class Array2 {    public static void main(String[] args) {        int array[][][];        array = new int[2][2][2];        array[0][0][0] = 1;    }}]]></java>		</introducao>		<resposta valor="f"/>	</questao>	<questao id="706" objetivo="4.4">		<introducao>			<stmt>array</stmt> é palavra reservada mas não empregada            pela linguagem Java.</introducao>		<resposta valor="f"/>	</questao>	<questao id="707" objetivo="1.1">		<introducao>A declaração <stmt>int a[10];</stmt> cria a variável            de referência <stmt>a</stmt>de um <it>array</it> cujos            elementos são do tipo <stmt>int</stmt> e em um total de 10.</introducao>		<resposta valor="f">Não se pode fornecer o tamanho do            <it>array</it> na declaração.</resposta>	</questao>	<questao id="708" objetivo="1.1">		<introducao>Não se pode fornecer o tamanho de um <it>array</it>            quando este é declarado, ou seja, <stmt>char            nome[80];</stmt> é uma declaração ilegal.</introducao>		<resposta valor="f"/>	</questao>	<questao id="709" objetivo="1.1">		<introducao>			<stmt>double d[120];</stmt> declara o <it>array</it>            identificado por <stmt>d</stmt> de um total de 120 elementos            do tipo <stmt>double</stmt>.</introducao>		<resposta valor="f"/>	</questao>	<questao id="710" objetivo="1.1">		<introducao>A quantidade de elementos que compõe um            <it>array</it> é estabelecida apenas quando este é            construído no <it>heap</it> (ou alocado).</introducao>		<resposta valor="v"/>	</questao>	<questao id="711" objetivo="4.4">		<introducao>Um <it>array</it> é construído, entre outras formas,            através do emprego da palavra reservada  <stmt>new</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="712" objetivo="1.1">		<introducao>Quando se cria um <it>array</it> em Java, ao            contrário da declaração, é necessário conhecer o tamanho do <it>array</it>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="713" objetivo="1.1">		<introducao>O tamanho de um <it>array</it> é a quantidade de            elementos que o <it>array</it> poderá reter. </introducao>		<resposta valor="v"/>	</questao>	<questao id="714" objetivo="1.1">		<introducao>			<stmt>int x[];</stmt> declara um <it>array</it> identificado            por <stmt>x</stmt> cujos elementos são do tipo primitivo <stmt>int</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="715" objetivo="1.1">		<introducao>Se <stmt>aInt</stmt> foi declarado como um            <it>array</it> de inteiros (<stmt>int</stmt>), então                <stmt>aInt = int[10];</stmt> cria o <it>array</it> com            10 elementos do tipo <stmt>int</stmt>.</introducao>		<resposta valor="f">A construção correta seria assim aInt[] = int[10].</resposta>	</questao>	<questao id="716" qi="1" objetivo="1.1">		<introducao>A sentença <stmt>int [] aInt = new int[5];</stmt>            declara um <it>array</it> de elementos do tipo            <stmt>int</stmt> e cria um objeto correspondente contendo            com capacidade para 5 inteiros.</introducao>		<resposta valor="v"/>	</questao>	<questao id="717" objetivo="2.4">		<introducao>Após a execução de <stmt>double x[] = new            double[3];</stmt> a soma de todos os elementos do            <it>array</it> irá provocar uma exceção em tempo de execução.</introducao>		<resposta valor="f"/>	</questao>	<questao id="718" objetivo="5.1">		<introducao>Após a execução de <stmt>double x[] = new            double[3];</stmt> a soma de todos os elementos do            <it>array</it> irá resultar no valor <stmt>0.0</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="719" objetivo="1.1">		<introducao>Todos os elementos de um <it>array</it>, quando este            é criado por meio de <stmt>new</stmt>, são iniciados com o            valor <it>default</it> correspondente ao tipo em questão.</introducao>		<resposta valor="v"/>	</questao>	<questao id="720" objetivo="1.1">		<introducao>			<stmt>int [] a;</stmt> seguida de <stmt>a = new            int[6];</stmt> tem o mesmo efeito que <stmt>int [] a = new int[6];</stmt>		</introducao>		<resposta valor="v"/>	</questao>	<questao id="721" objetivo="1.1">		<introducao>			<stmt>boolean b[] = new boolean(4);</stmt> declara a            variável de referência <stmt>b</stmt> como um <it>array</it>            de elementos do tipo primitivo <stmt>boolean</stmt> e cria            um objeto no <it>heap</it> capaz de reter 4 valores do tipo            <stmt>boolean</stmt> e inicia todos eles com o valor <stmt>false</stmt>.</introducao>		<resposta valor="f">Observe o emprego do parênteses em vez            de colchetes.</resposta>	</questao>	<questao id="722" objetivo="1.1">		<introducao>Após a execução de <stmt>String [] strs = new            String[2];</stmt> haverá pelo menos três objetos no            <it>heap</it>. Um correspondente ao <it>array</it> criado,            cuja referência é armazenada em <stmt>strs</stmt> e outros            dois correspondentes ao objeto <stmt>String</stmt> em            <stmt>strs[0]</stmt> e outro em <stmt>strs[1]</stmt>.</introducao>		<resposta valor="f">Apenas o objeto <stmt>strs</stmt> é            criado. Nenhuma <stmt>String</stmt> é criada.</resposta>	</questao>	<questao id="723" objetivo="4.4">		<introducao>			<stmt>thread</stmt> é palavra reservada de Java.</introducao>		<resposta valor="f"/>	</questao>	<questao id="724" objetivo="4.4">		<introducao>			<stmt>Thread</stmt> não é palavra reservada mas não pode ser            utilizada como identificador em Java.</introducao>		<resposta valor="f"/>	</questao>	<questao id="725" objetivo="4.4">		<introducao>			<stmt>thread</stmt> não é palavra reservada mas não pode ser            utilizada como identificador em Java.</introducao>		<resposta valor="f"/>	</questao>	<questao id="726" objetivo="4.4">		<introducao>			<stmt>construct</stmt> é palavra reservada em Java.</introducao>		<resposta valor="f"/>	</questao>	<questao id="727" objetivo="4.4">		<introducao>			<stmt>create</stmt> é palavra reservada em Java.</introducao>		<resposta valor="f"/>	</questao>	<questao id="728" objetivo="4.4">		<introducao>			<stmt>instantiate</stmt> é palavra reservada em Java.</introducao>		<resposta valor="f"/>	</questao>	<questao id="729" objetivo="4.4">		<introducao>			<stmt>Object</stmt> é palavra reservada em Java.</introducao>		<resposta valor="f"/>	</questao>	<questao id="730" objetivo="1.1">		<introducao>A compilação do código abaixo falha.<java><![CDATA[public class ArrayTest {    public static void main(String[] args) {        int Object[][][];        Object = new int[2][2][2];        Object[0][0][0] = 1;    }}]]></java>		</introducao>		<resposta valor="f"/>	</questao>	<questao id="731" objetivo="1.1">		<introducao>A sentença <stmt>Object strs[] = new String[5];</stmt>		</introducao>		<resposta valor="v"/>	</questao>	<questao id="732" objetivo="1.1">		<introducao>A compilação do código abaixo falha.<java><![CDATA[public class Array3 {    public static void main(String[] args) {        Object[] strs = new String[5];        strs[0] = new Boolean(true);    }}]]></java>		</introducao>		<resposta valor="f"/>	</questao>	<questao id="733" objetivo="2.4">		<introducao>A execução do código abaixo gera uma exceção: <stmt>ArrayStoreException</stmt>.<java><![CDATA[public class Array {    public static void main(String[] args) {        Object[] strs = new String[5];        strs[0] = new Boolean(true);    }}]]></java>		</introducao>		<resposta valor="v"/>	</questao>	<questao id="734" objetivo="4.6">		<introducao>Números inteiros em Java podem ser representados            usando três bases distintas: a base 10 (decimal), a base 8            (octal) e a base 16 (hexadecimal).</introducao>		<resposta valor="v"/>	</questao>	<questao id="735" objetivo="4.6">		<introducao>Literais na notação hexadecimal e octal são            permitidas exclusivamente para a representação de números            inteiros, o que exclui literais ponto-flutuante.</introducao>		<resposta valor="v"/>	</questao>	<questao id="736" objetivo="4.6">		<introducao>O compilação do código abaixo falha.<java><![CDATA[public class Literal {    public static void main(String[] args) {        long int x = 10;        short int y = 10;        System.out.println(x + y);    }}]]></java>		</introducao>		<resposta valor="v">			<stmt>long int</stmt> e <stmt>short int</stmt> não são tipos            primitivos da linguagema Java.</resposta>	</questao>	<questao id="737" objetivo="4.6">		<introducao>A compilação do código abaixo falha.<java><![CDATA[public class Literal {    public static void main(String[] args) {        int x = 10L;        int y = 10L;        System.out.println(x + y);    }}]]></java>		</introducao>		<resposta valor="v">Há possível perda de precisão ao se            tentar depositar um valor do tipo <stmt>long</stmt> em uma            variável do tipo <stmt>int</stmt>.</resposta>	</questao>	<questao id="738" objetivo="4.6">		<introducao>O código abaixo exibe o resultado <stmt>20</stmt>,            quando executado.<java><![CDATA[public class Literal {    public static void main(String[] args) {        int x = 10L;        int y = 10L;        System.out.println(x + y);    }}]]></java>		</introducao>		<resposta valor="f">O código não compila. O compilador emite a mensagem "Possível perda de precisão".</resposta>	</questao>	<questao id="739" objetivo="4.6">		<introducao>A compilação do código abaixo falha.<java><![CDATA[public class Literal {    public static void main(String[] args) {        float x = 010f;        float y = 010;        System.out.println(x + y);    }}]]></java>		</introducao>		<resposta valor="f"/>	</questao>	<questao id="740" objetivo="4.6">		<introducao>O código abaixo exibe o resultado <stmt>20</stmt>,            quando executado.<java><![CDATA[public class Literal {    public static void main(String[] args) {        float x = 010f;        float y = 010;        System.out.println(x + y);    }}]]></java>		</introducao>		<resposta valor="f">Quando executado o código gera "18.0".</resposta>	</questao>	<questao id="741" objetivo="4.6">		<introducao>O código abaixo exibe o resultado <stmt>16</stmt>,            quando executado.<java><![CDATA[public class Literal {    public static void main(String[] args) {        float x = 010f;        float y = 010;        System.out.println(x + y);    }}]]></java>		</introducao>		<resposta valor="f">Quando executado o código gera "18.0".</resposta>	</questao>	<questao id="742" objetivo="4.6">		<introducao>O código abaixo exibe o resultado <stmt>18</stmt>,            quando executado.<java><![CDATA[public class Literal {    public static void main(String[] args) {        float x = 010f;        float y = 010;        System.out.println(x + y);    }}]]></java>		</introducao>		<resposta valor="v"/>	</questao>	<questao id="743" objetivo="4.6">		<introducao>A declaração <stmt>float f = 010;</stmt> deposita na            variável do tipo primitivo <stmt>float</stmt> o valor            decimal 8.</introducao>		<resposta valor="v">Observe a representação octal            empregada pela literal inteira.</resposta>	</questao>	<questao id="744" objetivo="4.6">		<introducao>A declaração <stmt>int i = (int)010f;</stmt> causa            um erro de compilação.</introducao>		<resposta valor="f"/>	</questao>	<questao id="745" objetivo="4.6">		<introducao>A declaração <stmt>int i = (int)010f;</stmt>            deposita na variável <stmt>i</stmt> o valor decimal 10.</introducao>		<resposta valor="v"/>	</questao>	<questao id="746" objetivo="4.6">		<introducao>A declaração <stmt>long l = (long)010d;</stmt>            deposita na variável <stmt>l</stmt> o valor decimal 10.</introducao>		<resposta valor="v"/>	</questao>	<questao id="747" objetivo="4.6">		<introducao>A declaração <stmt>byte b = (byte)020;</stmt>            deposita na variável <stmt>b</stmt> o valor decimal 16.</introducao>		<resposta valor="v"/>	</questao>	<questao id="748" objetivo="4.6">		<introducao>A declaração <stmt>short s = (short)012f;</stmt>            deposita na variável <stmt>s</stmt> o valor decimal 10.</introducao>		<resposta valor="f">A variável s armazena o valor "12".</resposta>	</questao>	<questao id="749" objetivo="4.6">		<introducao>A declaração <stmt>short s = (short)012f;</stmt>            deposita na variável <stmt>s</stmt> o valor decimal 12.</introducao>		<resposta valor="v"/>	</questao>	<questao id="750" objetivo="4.6">		<introducao>Em Java, uma literal com o prefixo <stmt>d</stmt>,            <stmt>D</stmt>, <stmt>f</stmt> ou <stmt>F</stmt> é uma            literal em ponto-flutuante. Isto significa que a literal            está, necessariamente, escrita na base decimal.</introducao>		<resposta valor="v"/>	</questao>	<questao id="751" objetivo="4.6">		<introducao>A compilação do código abaixo falha.<java><![CDATA[public class Test {    public static void main(String[] args) {        float x = 010f;        float y = 010;        int i = x + y;        System.out.println(i);    }}]]></java>		</introducao>		<resposta valor="v">A terceira declaração tenta            depositar um valor do tipo <stmt>float</stmt> em uma            variável do tipo <stmt>int</stmt>.</resposta>	</questao>	<questao id="752" objetivo="4.6">		<introducao>A compilação do código abaixo falha.<java><![CDATA[public class Teste {    public static void main(String[] args) {        int x = 010;        int y = 010;        int i = x + y/2.0;        System.out.println(i);    }}]]></java>		</introducao>		<resposta valor="v">Na terceira declaração, a expressão            resultante é do tipo <stmt>double</stmt>. </resposta>	</questao>	<questao id="753" objetivo="4.6">		<introducao>A compilação do código abaixo falha.<java><![CDATA[public class Teste {    public static void main(String[] args) {        int x = 010;        int y = 010;        int i = x + y/2;        System.out.println(i);    }}]]></java>		</introducao>		<resposta valor="f"/>	</questao>	<questao id="754" objetivo="4.6">		<introducao>A execução deste código exibe o valor <stmt>12</stmt>.<java><![CDATA[public class Teste {    public static void main(String[] args) {        int x = 010;        int y = 010;        int i = x + y/2.0;        System.out.println(i);    }}]]></java>		</introducao>		<resposta valor="v"/>	</questao>	<questao id="755" objetivo="4.6">		<introducao>O código abaixo imprime o resultado <stmt>191.0</stmt>.<java><![CDATA[public class Soma {    public static void main(String[] args) {        long x = 010L;        int y = 10;        double z = 0xaD;        System.out.println(x + y + z);    }}]]></java>		</introducao>		<resposta valor="v"/>	</questao>	<questao id="756" objetivo="4.6">		<introducao>A compilação do código abaixo falha.<java><![CDATA[public class Soma {    public static void main(String[] args) {        long x = 010L;        int y = 10;        float z = 0xaD;        System.out.println(x + y + z);    }}]]></java>		</introducao>		<resposta valor="f"/>	</questao>	<questao id="757" objetivo="4.6">		<introducao>A compilação do código abaixo falha.<java><![CDATA[public class Soma {    public static void main(String[] args) {        long x = 010L;        int y = 10;        float z = 0xad;        System.out.println(x + y + z);    }}]]></java>		</introducao>		<resposta valor="f"/>	</questao>	<questao id="758" objetivo="5.2">		<introducao>A declaração <stmt>boolean b = (boolean)0;</stmt> é inválida.</introducao>		<resposta valor="v"/>	</questao>	<questao id="759" objetivo="5.2">		<introducao>A declaração <stmt>boolean b = (boolean)1;</stmt>            declara a variável <stmt>b</stmt> do tipo            <stmt>boolean</stmt> e a inicia com o valor <stmt>true</stmt>.</introducao>		<resposta valor="f"/>	</questao>	<questao id="760" objetivo="1.1">		<introducao>Quando um <it>array</it> é construído,            necessariamente o tamanho deve ser fornecido.</introducao>		<resposta valor="v"/>	</questao>	<questao id="761" objetivo="1.1">		<introducao>A compilação da sentença <stmt>int [] a = new            int[];</stmt> falha.</introducao>		<resposta valor="v">Falta o tamanho do <it>array</it>.</resposta>	</questao>	<questao id="762" objetivo="1.1">		<introducao>Além da possibilidade de criação de um            <it>array</it> com <stmt>new</stmt>, também pode-se empregar            uma sintaxe  que cria o <it>array</it> e, ao mesmo tempo,            são fornecidos valores iniciais para os elementos deste, ao            contrário dos valores <it>default</it>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="763" objetivo="4.4">		<introducao>É possível criar objetos sem o emprego da palavra reservada<stmt>new</stmt>.</introducao>		<resposta valor="v">Criação de <it>array</it> é um exemplo.</resposta>	</questao>	<questao id="764" objetivo="1.1">		<introducao>O código <stmt>int[][] matriz = new int[][];</stmt>            provoca um erro de compilação.</introducao>		<resposta valor="v"/>	</questao>	<questao id="765" objetivo="1.1">		<introducao>O código <stmt>int[][] matriz = new int[5][];</stmt>            provoca um erro de compilação.</introducao>		<resposta valor="f"/>	</questao>	<questao id="766" objetivo="1.1">		<introducao>Em Java, <it>arrays</it> de mais de uma dimensão são            tratados como <it>arrays</it> de <it>arrays</it>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="767" objetivo="1.1">		<introducao>O código abaixo, quando executado, exibe a média das            notas fornecidas no <it>array</it>.<java><![CDATA[public class Array {    public static void main(String[] args) {        float[] notas = { 3.2, 4.6, 7.8, 9.3 };        float soma = 0.0;        for (int i = 0; i < notas.length; i++)            soma += notas[i];        System.out.println(soma/notas.length);    }}]]></java>		</introducao>		<resposta valor="f">Não compila.</resposta>	</questao>	<questao id="768" objetivo="1.1">		<introducao>O código abaixo, quando executado, exibe a média das            notas fornecidas no <it>array</it>.<java><![CDATA[public class Array {    public static void main(String[] args) {        double[] notas = { 3.2, 4.6, 7.8, 9.3 };        double soma;        for (int i = 0; i < notas.length; i++)            soma += notas[i];        System.out.println(soma/notas.length);    }}]]></java>		</introducao>		<resposta valor="f">Variável <stmt>soma</stmt> não foi iniciada.</resposta>	</questao>	<questao id="769" objetivo="1.1">		<introducao>O código abaixo, quando executado, exibe a média das            notas fornecidas no <it>array</it>.<java><![CDATA[public class Array {    public static void main(String[] args) {        double[] notas = { 3.2, 4.6, 7.8, 9.3 };        double soma = 0.0;        for (int i = 0; i <= notas.length; i++)            soma += notas[i];        System.out.println(soma/notas.length);    }}]]></java>		</introducao>		<resposta valor="f">Gera exceção em tempo de execução: <stmt>ArrayIndexOutOfBoundsException</stmt>.</resposta>	</questao>	<questao id="770" objetivo="1.1">		<introducao>O código abaixo, quando executado, exibe a média dos            elementos do <it>array</it>.<java><![CDATA[public class Array {    public static void main(String[] args) {        double[] notas = { 3.2, 4.6, 7.8f, 9.3 };        double soma = 0;        for (int i = 0; i < notas.length; i++)            soma += notas[i];        System.out.println(soma/notas.length);    }}]]></java>		</introducao>		<resposta valor="v"/>	</questao>	<questao id="771" objetivo="1.1">		<introducao>O resultado exibido pelo código abaixo é <stmt>3</stmt>.<java><![CDATA[public class Array {    public static void main(String[] args) {        int[][] array = new int[1][0];        array[0] = new int[10];        array[0][0] = 1;        array[0][1] = 2;        System.out.println(array[0][0] + array[0][1]);    }}]]></java>		</introducao>		<resposta valor="v"/>	</questao>	<questao id="772" objetivo="1.1">		<introducao>O código abaixo não compila.<java><![CDATA[public class Array {    public static void main(String[] args) {        int[][] array = new int[1][0];        array[0] = new int[10];        array[0][0] = 1;        array[0][1] = 2;        System.out.println(array[0][0] + array[0][1]);    }}]]></java>		</introducao>		<resposta valor="f"/>	</questao>	<questao id="773" objetivo="1.1">		<introducao>O código abaixo gera uma exceção em tempo de execução.<java><![CDATA[public class Array {    public static void main(String[] args) {        int[][] array = new int[1][0];        array[0] = new int[10];        array[0][0] = 1;        array[0][1] = 2;        System.out.println(array[0][0] + array[0][1]);    }}]]></java>		</introducao>		<resposta valor="f"/>	</questao>	<questao id="774" objetivo="1.1">		<introducao>Iniciar um <it>array</it> significa depositar            elementos nele, ou valores primitivos ou referências para objetos.</introducao>		<resposta valor="v"/>	</questao>	<questao id="775" objetivo="1.1">		<introducao>Não se deposita um objeto em um <it>array</it> mas a            referência para um objeto.</introducao>		<resposta valor="v"/>	</questao>	<questao id="776" objetivo="1.1">		<introducao>Quando se diz  que um <it>array</it> de            <stmt>String</stmt> está-se, na verdade, fazendo referência            a um <it>array</it> de referências para <stmt>String</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="777" objetivo="1.1">		<introducao>Elementos de um <it>array</it> podem ser obtidos por            meio de um índice.</introducao>		<resposta valor="v"/>	</questao>	<questao id="778" objetivo="1.1">		<introducao>Um <it>array</it> de X elementos possui como índices            válidos qualquer valor no intervalo de 1 a X, inclusive.</introducao>		<resposta valor="f"/>	</questao>	<questao id="779" objetivo="1.1">		<introducao>Um <it>array</it> de X elementos possui como índices            válidos qualquer valor no intervalo de 0 a (X-1), inclusive.</introducao>		<resposta valor="v"/>	</questao>	<questao id="780" objetivo="1.1">		<introducao>O valor impresso pelo código abaixo é <stmt>0</stmt>.<java><![CDATA[class Numero {    int n;    int getN() {        return n;    }}public class Array {    public static void main(String[] args) {        Numero[] aN = new int[2];        System.out.println(aN[0].getN() + aN[1].getN());    }}]]></java>		</introducao>		<resposta valor="f">Não compila.</resposta>	</questao>	<questao id="781" objetivo="1.1">		<introducao>O valor impresso pelo código abaixo é <stmt>0</stmt>.<java><![CDATA[class Numero {    int n;    int getN() {        return n;    }}public class Array {    public static void main(String[] args) {        Numero[] aN = new Numero(2);        System.out.println(aN[0].getN() + aN[1].getN());    }}]]></java>		</introducao>		<resposta valor="f">Não compila.</resposta>	</questao>	<questao id="782" objetivo="1.1">		<introducao>O valor impresso pelo código abaixo é <stmt>0</stmt>.<java><![CDATA[class Numero {    int n;    int getN() {        return n;    }}public class Array {    public static void main(String[] args) {        Numero[] aN = new Numero[2];        System.out.println(aN[0].getN() + aN[1].getN());    }}]]></java>		</introducao>		<resposta valor="f">Gera exceção <stmt>NullPointerException</stmt>.</resposta>	</questao>	<questao id="783" objetivo="1.1">		<introducao>O código abaixo gera uma exceção.<java><![CDATA[class Numero {    int n;    int getN() {        return n;    }}public class Array {    public static void main(String[] args) {        Numero[] aN = new Numero[2];        aN[0] = new Numero();        aN[1] = new Numero();        System.out.println(aN[0].getN() + aN[1].getN());    }}]]></java>		</introducao>		<resposta valor="f"/>	</questao>	<questao id="784" objetivo="1.1">		<introducao>O código abaixo imprime o valor 0 quando executado.<java><![CDATA[class Numero {    int n;    int getN() {        return n;    }}public class Array {    public static void main(String[] args) {        Numero[] aN = new Numero[2];        aN[0] = new Numero();        aN[1] = new Numero();        System.out.println(aN[0].getN() + aN[1].getN());    }}]]></java>		</introducao>		<resposta valor="v"/>	</questao>	<questao id="785" objetivo="1.1">		<introducao>A execução do código abaixo imprime os valores 2 e 2.<java><![CDATA[public class Array {    public static void main(String[] args) {        byte[][] b = new byte[2][2];        byte[] aux = new byte[1];        int soma = 0;        b[0][0] = 1;        b[0][1] = 1;        for (int i = 0; i < b.length; i++)            soma += b[0][i];        System.out.println(soma);        b[0] = aux;        for (int i = 0; i < b.length; i++)            soma += b[0][i];        System.out.println(soma);    }}]]></java>		</introducao>		<resposta valor="f"/>	</questao>	<questao id="786" objetivo="1.1">		<introducao>A execução do código abaixo imprime os valores 2 e 4            (nesta ordem).<java><![CDATA[public class Array {    public static void main(String[] args) {        byte[][] b = new byte[2][2];        byte[] aux = new byte[1];        int soma = 0;        b[0][0] = 1;        b[0][1] = 1;        for (int i = 0; i < b.length; i++)            soma += b[0][i];        System.out.println(soma);        b[0] = aux;        for (int i = 0; i < b.length; i++)            soma += b[0][i];        System.out.println(soma);    }}]]></java>		</introducao>		<resposta valor="f"/>	</questao>	<questao id="787" objetivo="1.1">		<introducao>A execução do código abaixo imprime os valores 2 e 0            (nesta ordem).<java><![CDATA[public class Array {    public static void main(String[] args) {        byte[][] b = new byte[2][2];        byte[] aux = new byte[1];        int soma = 0;        b[0][0] = 1;        b[0][1] = 1;        for (int i = 0; i < b.length; i++)            soma += b[0][i];        System.out.println(soma);        b[0] = aux;        for (int i = 0; i < b.length; i++)            soma += b[0][i];        System.out.println(soma);    }}]]></java>		</introducao>		<resposta valor="f"/>	</questao>	<questao id="788" objetivo="1.1">		<introducao>O código abaixo não compila.<java><![CDATA[public class Array {    public static void main(String[] args) {        byte[][] b = new byte[2][2];        byte[] aux = new byte[1];        int soma = 0;        b[0][0] = 1;        b[0][1] = 1;        for (int i = 0; i < b.length; i++)            soma += b[0][i];        System.out.println(soma);        b[0] = aux;        for (int i = 0; i < b.length; i++)            soma += b[0][i];        System.out.println(soma);    }}]]></java>		</introducao>		<resposta valor="f"/>	</questao>	<questao id="789" objetivo="1.1">		<introducao>O código abaixo gera a exceção <stmt>ArrayIndexOutOfBoundsException</stmt>.<java><![CDATA[public class Array {    public static void main(String[] args) {        byte[][] b = new byte[2][2];        byte[] aux = new byte[1];        int soma = 0;        b[0][0] = 1;        b[0][1] = 1;        for (int i = 0; i < b.length; i++)            soma += b[0][i];        System.out.println(soma);        b[0] = aux;        for (int i = 0; i < b.length; i++)            soma += b[0][i];        System.out.println(soma);    }}]]></java>		</introducao>		<resposta valor="v"/>	</questao>	<questao id="790" objetivo="1.1">		<introducao>Pode-se criar um <it>array</it> de duas dimensões            onde os elementos de uma dimensão são do tipo            <stmt>int</stmt> e da outra dimensão do tipo <stmt>float</stmt>.</introducao>		<resposta valor="f">Todos os elementos de um <it>array</it>            são do mesmo tipo.</resposta>	</questao>	<questao id="791" objetivo="1.1">		<introducao>Para acrescentar 5 elementos no <it>array</it>			<stmt>Array</stmt>do tipo <stmt>int</stmt> de 3 elementos,            basta redefinir o tamanho deste como <stmt>Array.length += 5;</stmt>.</introducao>		<resposta valor="f"/>	</questao>	<questao id="792" objetivo="1.1">		<introducao>O código abaixo imprime o valor 0.<java><![CDATA[public class Array {    public static void main(String[] args) {        int[] a;        System.out.println(a.length);    }}]]></java>		</introducao>		<resposta valor="f"/>	</questao>	<questao id="793" objetivo="1.1">		<introducao>O código abaixo gera a exceção <stmt>NullPointerException</stmt>.<java><![CDATA[public class Array {    public static void main(String[] args) {        int[] a;        System.out.println(a.length);    }}]]></java>		</introducao>		<resposta valor="f"/>	</questao>	<questao id="794" objetivo="1.1">		<introducao>O código abaixo não compila.<java><![CDATA[public class Array {    public static void main(String[] args) {        int[] a;        System.out.println(a.length);    }}]]></java>		</introducao>		<resposta valor="v"/>	</questao>	<questao id="795" objetivo="1.1">		<introducao>O código abaixo não compila.<java><![CDATA[public class Array {    static int[] a;    public static void main(String[] args) {        System.out.println(a.length);    }}]]></java>		</introducao>		<resposta valor="f"/>	</questao>	<questao id="796" objetivo="1.1">		<introducao>O código abaixo imprime o valor 0.<java><![CDATA[public class Array {    static int[] a;    public static void main(String[] args) {        System.out.println(a.length);    }}]]></java>		</introducao>		<resposta valor="f"/>	</questao>	<questao id="797" objetivo="1.1">		<introducao>O código abaixo gera a exceção <stmt>NullPointerException</stmt>.<java><![CDATA[public class Array {    static int[] a;    public static void main(String[] args) {        System.out.println(a.length);    }}]]></java>		</introducao>		<resposta valor="v"/>	</questao>	<questao id="798" objetivo="1.1">		<introducao>O código abaixo gera a exceção <stmt>NullPointerException</stmt>.<java><![CDATA[public class Array {    static int[] a;    public static void main(String[] args) {        a.length = 2;        a[0] = 1;        a[1] = 2;        System.out.println(a[0] + a[1]);    }}]]></java>		</introducao>		<resposta valor="f"/>	</questao>	<questao id="799" objetivo="1.1">		<introducao>O código abaixo imprime o valor 3.<java><![CDATA[public class Array {    static int[] a;    public static void main(String[] args) {        a.length = 2;        a[0] = 1;        a[1] = 2;        System.out.println(a[0] + a[1]);    }}]]></java>		</introducao>		<resposta valor="f"/>	</questao>	<questao id="800" objetivo="1.1">		<introducao>O código abaixo gera uma exceção.<java><![CDATA[public class Array {    static int[] a;    public static void main(String[] args) {        a.length = 2;        a[0] = 1;        a[1] = 2;        System.out.println(a[0] + a[1]);    }}]]></java>		</introducao>		<resposta valor="f"/>	</questao>	<questao id="801" objetivo="1.1">		<introducao>O código abaixo não compila.                            <java>public class Array {    static int[] a;    public static void main(String[] args) {        a.length = 2;        a[0] = 1;        a[1] = 2;        System.out.println(a[0] + a[1]);    }}</java>		</introducao>		<resposta valor="v">Vetores em Java não podem ter seu tamanho definido da maneira acima (a.length = 2).</resposta>	</questao>	<questao id="802" objetivo="1.1">		<introducao>O código abaixo gera a exceção <stmt>NullPointerException</stmt>.            <java>public class Array {    static int[] a;    public static void main(String[] args) {        a = new int[2];        a[0] = 1;        a[1] = 2;        System.out.println(a[0] + a[1]);    }}</java>		</introducao>		<resposta valor="f"/>	</questao>	<questao id="803" objetivo="1.1">		<introducao>O código abaixo gera a exceção <stmt>NullPointerException</stmt>.            <java>public class Array {    static int[] a;    public static void main(String[] args) {        a = new int[4];        a[0] = 1;        a[1] = 2;        System.out.println(a[0] + a[1]);    }}</java>		</introducao>		<resposta valor="f">Mesmo que se tentasse acessar os índices 2 e 3, não haveria problema, pois os elementos de um vetor de inteiros são inicializados com zero.</resposta>	</questao>	<questao id="804" objetivo="1.1">		<introducao>A sentença <stmt>int[] notas = { 9, 9, 8, 10            };</stmt> declara uma variável do tipo referência para um <it>array</it> de elementos do tipo primitivo                     <stmt>int</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="805" objetivo="1.1">		<introducao>A sentença <stmt>int[] notas = { 9, 9, 8, 10            };</stmt> cria um <it>array</it> de 4 elementos do tipo            primitivo <stmt>int</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="806" objetivo="1.1">		<introducao>A sentença <stmt>int[] notas = { 9, 9, 8, 10            };</stmt> cria um <it>array</it> de 4 elementos do tipo            primitivo <stmt>int</stmt> e os inicia com os valores 9, 9,            8 e 10, respectivamente nas posições 0, 1, 2 e 3 do <it>array</it>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="807" objetivo="1.1">		<introducao>A sentença <stmt>int[] notas = { 9, 9, 8, 10            };</stmt> atribui o objeto <it>array</it> criado à variável            do tipo referência <stmt>notas</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="808" objetivo="1.1">		<introducao>A sentença <stmt>int[] notas = { 9, 9, 8, 10            };</stmt> é funcionalmente equivalente ao código abaixo.                        <java>int[] notas;notas = new int[4];notas[0] = 9;notas[1] = notas[0];notas[2] = 8;notas[3] = 10;</java>		</introducao>		<resposta valor="v"/>	</questao>	<questao id="809" objetivo="1.1">		<introducao>O código abaixo imprime o valor 0.                       <java>public class Array {    public static void main(String[] args) {        int[] valores = {}        System.out.println(valores.length);    }}</java>		</introducao>		<resposta valor="f">Há um erro no código: está faltando um sinal de ponto-e-vírgula depois do sinal de fecha-chaves, na inicialização do vetor. Se não fosse isto, a resposta seria verdadeira.</resposta>	</questao>	<questao id="810" objetivo="1.1">		<introducao>O código abaixo não compila.                        <java>public class Array {    public static void main(String[] args) {        int[] valores = {}        System.out.println(valores.length);    }}</java>		</introducao>		<resposta valor="v">Há um erro no código: está faltando um sinal de ponto-e-vírgula depois do sinal de fecha-chaves, na inicialização do vetor.</resposta>	</questao>	<questao id="811" objetivo="1.1">		<introducao>O código abaixo imprime o valor 0.                   <java>public class Array {    public static void main(String[] args) {        int[] valores = {};        System.out.println(valores.length);    }}</java>		</introducao>		<resposta valor="v"/>	</questao>	<questao id="812" objetivo="1.1">		<introducao>O código abaixo gera a exceção <stmt>NullPointerException</stmt>.                                  <java>public class Array {    public static void main(String[] args) {        int[] valores = {};        System.out.println(valores.length);    }}</java>		</introducao>		<resposta valor="f"/>	</questao>	<questao id="813" objetivo="1.1">		<introducao>O código abaixo imprime os valores 0 e 50, nesta ordem.                  <java>public class Array {    public static void main(String[] args) {        int[] valores = {};        System.out.println(valores.length);        valores = new int[50];        System.out.println(valores.length);    }}</java>		</introducao>		<resposta valor="v"/>	</questao>	<questao id="814" objetivo="1.1">		<introducao>O código abaixo não compila.                                    <java>public class Array {    public static void main(String[] args) {        int[] valores = {};        System.out.println(valores.length);        valores = new int[50];        System.out.println(valores.length);    }}</java>		</introducao>		<resposta valor="f"/>	</questao>	<questao id="815" objetivo="1.1">		<introducao>Em tempo de execução, o código abaixo gera uma exceção.                                    <java>public class Array {    public static void main(String[] args) {        int[] valores = {};        System.out.println(valores.length);        valores = new int[50];        System.out.println(valores.length);    }}</java>		</introducao>		<resposta valor="f"/>	</questao>	<questao id="816" objetivo="1.1">		<introducao>A sentença                         <stmt>int[][] x = { { 1 }, { 2, 3 }, { 4,                5, 6 } };</stmt> gera um erro de compilação.</introducao>		<resposta valor="f"/>	</questao>	<questao id="817" objetivo="1.1">		<introducao>A sentença                        <stmt>int[][] x = { { 1 }, { 2, 3 }, { 4,                5, 6 } };</stmt> declara uma variável do tipo referência            denominada  <stmt>x</stmt>.</introducao>		<resposta valor="f"/>	</questao>	<questao id="818" objetivo="1.1">		<introducao>A sentença  <stmt>int[][] x = { { 1 }, { 2, 3 }, { 4,                5, 6 } };</stmt> cria um único objeto no <it>heap</it>.</introducao>		<resposta valor="f"/>	</questao>	<questao id="819" objetivo="1.1">		<introducao>A sentença <stmt>int[][] x = { { 1 }, { 2, 3 }, { 4,                5, 6 } };</stmt> cria 4 (quatro) objetos no <it>heap</it>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="820" objetivo="1.1">		<introducao>A sentença  <stmt>int[][] x = { { 1 }, { 2, 3 }, { 4,                5, 6 } };</stmt> cria um  <it>array</it> de <it>arrays</it> de elementos do tipo <stmt>int</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="821" objetivo="1.1">		<introducao>A sentença <stmt>int[][] x = { { 1 }, { 2, 3 }, { 4,                5, 6 } };</stmt> cria um <it>array</it> contendo três            referências para outros três objetos (referências para <it>arrays</it> de inteiros).</introducao>		<resposta valor="v"/>	</questao>	<questao id="822" objetivo="1.1">		<introducao>A sentença <stmt>int[][] x = { { 1 }, { 2, 3 }, { 4,                5, 6 } };</stmt> faz com que o segundo elemento de <stmt>x</stmt> seja uma referência para um objeto, que é um <it>array</it> contendo dois elementos, onde o segundo deles é <stmt>2</stmt>.</introducao>		<resposta valor="f">O primeiro é o 2.</resposta>	</questao>	<questao id="823" objetivo="1.1">		<introducao>Em Java, os <it>arrays</it> de múltiplas dimensões            não precisam ser compostos por elementos que possuem os            mesmos tamanhos. Por exemplo, <stmt>short[][] Short;</stmt>            declara a variável do tipo referência <stmt>Short</stmt> que            é um <it>array</it> de <it>arrays</it>. Cada um dos <it>arrays</it>, <stmt>Short[0]</stmt>, <stmt>Short[1]</stmt> e assim por diante, pode ter uma  quantidade de elementos diferente dos demais.</introducao>		<resposta valor="v"/>	</questao>	<questao id="824" objetivo="1.1">		<introducao>Para a sentença <stmt>byte b[][] = { { -1, 20, -30,                3}, {}, { 1, 2, 1 }, { 3, 4, 5 }};</stmt> a condição <stmt>b[0][0] == -1</stmt> é verdadeira.</introducao>		<resposta valor="v"/>	</questao>	<questao id="825" objetivo="1.1">		<introducao>Para a sentença <stmt>byte b[][] = { { -1, 20, -30,                3}, {}, { 1, 2, 1 }, { 3, 4, 5 }};</stmt> a condição <stmt>b[1] == null</stmt> é verdadeira.</introducao>		<resposta valor="f">O símbolos {}, na inicialização, criam um vetor de tamanho zero.</resposta>	</questao>	<questao id="826" objetivo="1.1">		<introducao>A sentença <stmt>System.out.println((new            int[]{1}).length);</stmt> não compila.</introducao>		<resposta valor="f"/>	</questao>	<questao id="827" objetivo="1.1">		<introducao>A sentença <stmt>System.out.println((new            int[]{2}).length);</stmt> imprime o valor 1.</introducao>		<resposta valor="v"/>	</questao>	<questao id="828" objetivo="1.1">		<introducao>A declaração da variável <stmt>i</stmt> via a sentença <stmt>int i = (new int[]{}).length;</stmt> deposita em <stmt>i</stmt> o valor inicial 0.</introducao>		<resposta valor="v"/>	</questao>	<questao id="829" objetivo="1.1">		<introducao>A sentença <stmt>int i = (new            int[1]{2}).length;</stmt> não compila.</introducao>		<resposta valor="v">Java não permite inicialização dessa forma, quando o tamanho do array é especificado.</resposta>	</questao>	<questao id="830" objetivo="1.1">		<introducao>Se <stmt>a</stmt> é uma variável do tipo referência            para um <it>array</it> de inteiros, então <stmt>a</stmt>            pode receber a referência de qualquer outro objeto que é um <it>array</it> de inteiros, independente do tamanho deste.</introducao>		<resposta valor="v"/>	</questao>	<questao id="831" objetivo="1.1">		<introducao>A compilação do código abaixo não falha.            <java>byte b[] = new byte[10];        int i[] = b;</java>		</introducao>		<resposta valor="f">Os tipos são incompatíveis.</resposta>	</questao>	<questao id="832" objetivo="1.1">		<introducao>O código abaixo gera um exceção em tempo de execução.            		       <java>byte b[] = new byte[10];        int i[] = b;</java>		</introducao>		<resposta valor="f">Gera em tempo de compilação.</resposta>	</questao>	<questao id="833" objetivo="6.1">		<introducao>Se a classe <stmt>A</stmt> é derivada de <stmt>B</stmt>, então uma variável do tipo referência para um <it>array</it> de <stmt>B</stmt> pode receber a referência de um objeto <it>array</it> cujo elemento é<stmt>A</stmt>.</introducao>		<resposta valor="v">Já que subclasses de B, possuem, no mínimo a mesma interface de B.</resposta>	</questao>	<questao id="834" objetivo="6.1">		<introducao>Se a classe <stmt>A</stmt> é derivada de <stmt>B</stmt>, então uma variável do tipo referência para um <it>array</it> de <stmt>A</stmt> pode receber a            referência de um objeto <it>array</it> cujo elemento é<stmt>B</stmt>.</introducao>		<resposta valor="f"/>	</questao>	<questao id="835" objetivo="6.1">		<introducao>Um <it>array</it> declarado como de um tipo interface pode referenciar qualquer <it>array</it> de qualquer tipo que implementa a interface.</introducao>		<resposta valor="v"/>	</questao>	<questao id="836" objetivo="4.1">		<introducao>Variável local é declarada no interior de um método            ou na lista de argumentos de um método.</introducao>		<resposta valor="v"/>	</questao>	<questao id="837" objetivo="4.1">		<introducao>Variável de instância é declarada no interior de uma            classe, mas fora de qualquer método ou construtor.</introducao>		<resposta valor="v"/>	</questao>	<questao id="838" objetivo="5.1">		<introducao>Atribuições entre referências para <it>arrays</it>exigem, para que possam ser realizadas satisfatoriamente, que necessariamente possuam a mesma quantidade de dimensões (não é tamanho).</introducao>		<resposta valor="v"/>	</questao>	<questao id="839" objetivo="4.1">		<introducao>A compilação do código abaixo falha.            			   <java>        byte b[] = new byte[10];        byte bb[][] = new byte[2][];        bb[0] = b;        bb = b;        bb[0][0] = b;</java>		</introducao>		<resposta valor="v">"bb = b" não é permitido pois as dimensões são diferentes. "bb[0][0] = b" é inválido, já que bb[0][0] espera apenas uma valor byte, não um vetor.</resposta>	</questao>	<questao id="840" objetivo="4.1">		<introducao>No código abaixo, duas sentenças provacam erros de compilação.            <java>        byte b[] = new byte[10];        byte bb[][] = new byte[2][];        bb[0] = b;        bb = b;        bb[0][0] = b;</java>		</introducao>		<resposta valor="v">Sim, as duas últimas.</resposta>	</questao>	<questao id="841" objetivo="4.1">		<introducao>Variáveis localis também são chamadas de <it>stack</it>, temporárias, automáticas ou variáveis de métodos.</introducao>		<resposta valor="f"/>	</questao>	<questao id="842" objetivo="4.1">		<introducao>É possível criar aplicações em Java em que pelo            menos uma variável local não é inicializada e a compilação            não falha.</introducao>		<resposta valor="v"/>	</questao>	<questao id="843" objetivo="4.1">		<introducao>Variável local não iniciada e que se tenta fazer uso            gera um erro em tempo de execução.</introducao>		<resposta valor="f">Gera em tempo de compilação.</resposta>	</questao>	<questao id="844" objetivo="4.1">		<introducao>Variável local não iniciada e que se tenta fazer uso            gera um erro em tempo de compilação.</introducao>		<resposta valor="v"/>	</questao>	<questao id="845" objetivo="4.1">		<introducao>Variáveis de instância também são chamadas de            membros e são declaradas no nível de classe.</introducao>		<resposta valor="v"/>	</questao>	<questao id="846" objetivo="1.2">		<introducao>Variáveis de instâncias que não são<stmt>static</stmt> recebem seus respectivos valores cada            vez que uma instância da classe é criada.</introducao>		<resposta valor="v"/>	</questao>	<questao id="847" objetivo="4.1">		<introducao>Variáveis locais não recebem automaticamente valores                        <it>default</it> em qualquer que seja a situação. É preciso,            antes de empregá-las, explicitamente fornecer um valor inicial.</introducao>		<resposta valor="v"/>	</questao>	<questao id="848" objetivo="5.1">		<introducao>A declaração <stmt>String str = null;</stmt> é            similar à declaração <stmt>String str = "";</stmt>.</introducao>		<resposta valor="f">"" equivale a uma string vazia. null significa ausência de valor.</resposta>	</questao>	<questao id="849" objetivo="4.5">		<introducao>A compilação do código abaixo não falha.                        <java>public class Restaurante {    private String nome;    public static void main(String[] args) {        Restaurante obj = new Restaurante();        String nome = obj.getNome();        System.out.println(nome.toLowerCase());    }    public String getNome() {        return nome;    }}</java>		</introducao>		<resposta valor="v">Acontece erro em tempo de compilação.</resposta>	</questao>	<questao id="850" objetivo="4.5">		<introducao>A execução do código abaixo gera uma exceção.                        <java>public class Restaurante {    private String nome;    public static void main(String[] args) {        Restaurante obj = new Restaurante();        String nome = obj.getNome();        System.out.println(nome.toLowerCase());    }    public String getNome() {        return nome;    }}</java>		</introducao>		<resposta valor="v">A variável "nome" não foi inicializada.</resposta>	</questao>	<questao id="851" objetivo="4.5">		<introducao>Quando executado, o código abaixo imprime <stmt>NULL</stmt>.                                    <java>public class Restaurante {    private String nome;    public static void main(String[] args) {        Restaurante obj = new Restaurante();        String nome = obj.getNome();        System.out.println(nome.toUpperCase());    }    public String getNome() {        return nome;    }}</java>		</introducao>		<resposta valor="f">Não, é gerada uma exceção em tempo de execução.</resposta>	</questao>	<questao id="852" objetivo="4.5">		<introducao>Se uma referência para um determinado tipo possui o valor               <stmt>null</stmt>, então qualquer tentativa de fazer            uso da variável que contém esta referência, por exemplo,            para se ter acesso a um método do tipo, irá provocar a            exceção  <stmt>NullPointerException</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="853" objetivo="4.5">		<introducao>Se o tipo classe <stmt>Aluno</stmt> possui um membro            público do tipo <stmt>String</stmt> cuja variável é                      <stmt>nome</stmt>, então tentar o acesso a este membro            através de  <stmt>a.nome.toUpperCase();</stmt>, por exemplo,            imediatamente após <stmt>Aluno a = null</stmt> irá gerar a            exceção                      <stmt>NullReferenceException</stmt>.</introducao>		<resposta valor="v">questoes.impl.StmtImpl@13785d3         </resposta>	</questao>	<questao id="854" objetivo="1.1">		<introducao>Uma variável de instância do tipo <it>array</it> que            não foi explicitamente iniciada terá o valor <stmt>null</stmt> fornecido como             <it>default</it>, assim            como qualquer outra variável de instância do tipo referência.</introducao>		<resposta valor="v"/>	</questao>	<questao id="855" objetivo="1.1 (corrigir a pergunta)">		<introducao>Elementos de um             <it>array</it> sempre, após a            criação do mesmo, iniciados com o valor             <it>default</it> correspondente.</introducao>		<resposta valor="v">Apenas se esta criação significar, também, instanciação.</resposta>	</questao>	<questao id="856" objetivo="1.1">		<introducao>Após a sentença <stmt>boolean[] b = new            boolean[10];</stmt>, todos os elementos de <stmt>b</stmt>            contém o valor correspondente à literal                         <stmt>false</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="857" objetivo="4.5">		<introducao>Variáveis locais, quando se deseja fazer uso delas,            sempre devem ser iniciadas.</introducao>		<resposta valor="v"/>	</questao>	<questao id="858" objetivo="4.5">		<introducao>Não é fornecido um valor                        <it>default</it> para            variáveis locais em Java.</introducao>		<resposta valor="v"/>	</questao>	<questao id="859" objetivo="4.1">		<introducao>Pode-se declarar uma variável local e não fornecer            um valor inicial para ela, desde que também ela não seja            utilizada. Embora sem utilidade prática, o compilador não reclama.</introducao>		<resposta valor="v"/>	</questao>	<questao id="860" objetivo="4.1">		<introducao>A declaração da variável de instância                         <stmt>String            str;</stmt> faz com que <stmt>str</stmt> receba o valor             <stmt>null</stmt> quando uma instância da classe em questão            é criada.</introducao>		<resposta valor="v"/>	</questao>	<questao id="861" objetivo="4.5">		<introducao>A declaração da variável local <stmt>String            str;</stmt> faz com que a condição <stmt>str != null</stmt>,            imediatamente em uma sentença que segue a declaração, gere            um erro em tempo de compilação.</introducao>		<resposta valor="v">str deve ser inicializada antes.</resposta>	</questao>	<questao id="862" objetivo="4.5">		<introducao>Uma referência <stmt>null</stmt> é o mesmo que uma            referência não iniciada.</introducao>		<resposta valor="f">Java não permite o acesso à variáveis não iniciadas, mas permite o acesso à variáveis com valor null.</resposta>	</questao>	<questao id="863" objetivo="11">		<introducao>O método <stmt>main</stmt> é o método chamado pela            máquina virtual Java quando se executa uma aplicação em Java.</introducao>		<resposta valor="v"/>	</questao>	<questao id="864" objetivo="11">		<introducao>O método <stmt>main</stmt> chamado pela máquina            virtual Java necessariamente possui um único argumento: um <it>array</it> do tipo             <stmt>String</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="865" objetivo="11">		<introducao>O nome do argumento do método             <stmt>main</stmt>            invocado pela máquina virtual Java necessariamente deve se            chamar <stmt>args</stmt>.</introducao>		<resposta valor="f">         Tanto faz o nome do argumento, o que importa é o tipo dele.</resposta>	</questao>	<questao id="866" objetivo="4.4">		<introducao>			<stmt>main</stmt> é palavra reservada de Java.</introducao>		<resposta valor="f"/>	</questao>	<questao id="867" objetivo="4.5">		<introducao>A compilação do código abaixo falha.                        <java>final public class main {    static final public void main(final String $s[]) {}}</java>		</introducao>		<resposta valor="f">A palavra "main" pode ser utilizada para nome de classe, método ou variável. E o fato de o método main() ser "final" não importa para a JVM.</resposta>	</questao>	<questao id="868" objetivo="11">		<introducao>O código abaixo não correspondente a uma aplicação            em Java, visto que o método <stmt>main</stmt> necessário em            toda aplicação Java não é fornecido.                        <java>public class Teste {    static final public void main(final String $s[]) {}}</java>		</introducao>		<resposta valor="f">O fato do método main() e do argumento serem "final" não importa para a JVM.</resposta>	</questao>	<questao id="869" objetivo="4.1">		<introducao>O programa abaixo adequadamente percorre e imprime            todos os argumentos fornecidos na linha de comando quando            uma aplicação é chamada. Em particular, se nenhum argumento            é fornecido, então a aplicação imprime uma mensagem compatível.                        <java>public class main {    public static void main(String[] args) {        if (args.length == 0) {            System.out.println("Nenhum argumento fornecido.");        }        for (int i = 0; i &lt; args.length; i++) {            System.out.println(i + ": " + args[i]);        }    }}</java>		</introducao>		<resposta valor="v"/>	</questao>	<questao id="870" objetivo="4.1">		<introducao>A compilação do código abaixo falha.                        <java>public class main {    private static int n = -1;    public static void main(String[] args) {        if (n == -1) {            n = args.length;        }        if (n == 0) {            return;        }        int vez = n;        n = n - 1;        main(args);        System.out.println(args[vez-1]);    }}</java>		</introducao>		<resposta valor="f"/>	</questao>	<questao id="871" objetivo="4.1">		<introducao>O código abaixo, quando executado, entra em um laço            infinito (não pára).                        <java>public class main {    private static int n = -1;    public static void main(String[] args) {        if (n == -1) {            n = args.length;        }        if (n == 0) {            return;        }        int vez = n;        n = n - 1;        main(args);        System.out.println(args[vez-1]);    }}</java>		</introducao>		<resposta valor="f">Isto não acontece, já que há um controle antes da chamada recursiva que impõem um fim às chamadas, a saber, quando "n = 0".</resposta>	</questao>	<questao id="872" objetivo="4.1">		<introducao>O código abaixo exibe os argumentos fornecidos na            linha de comando na ordem em que foram fornecidos.                        <java>public class main {    private static int n = -1;    public static void main(String[] args) {        if (n == -1) {            n = args.length;        }        if (n == 0) {            return;        }        int vez = n;        n = n - 1;        main(args);        System.out.println(args[vez-1]);    }}</java>		</introducao>		<resposta valor="v"/>	</questao>	<questao id="873" objetivo="4.1">		<introducao>O código abaixo necessariamente imprime a mensagem <stmt>fim</stmt> quando executado.                        <java>public class main {    private static int n = -1;    public static void main(String[] args) {        System.out.println(args[0]);        System.out.println("fim");            }}</java>		</introducao>		<resposta valor="f">         Apenas quando for passado algum parâmetro de prompt de comando.</resposta>	</questao>	<questao id="874" objetivo="1.2">		<introducao>Um método declarado <stmt>public</stmt> pode ser            chamado de qualquer outro ponto da aplicação em questão.</introducao>		<resposta valor="f">Ele pode não ser visto em outro pacote, caso a classe não seja também "public".</resposta>	</questao>	<questao id="875" objetivo="1.2">		<introducao>Um método declarado <stmt>private</stmt> só pode ser            chamado de alguma posição no interior da classe na qual este            é declarado.</introducao>		<resposta valor="v"/>	</questao>	<questao id="876" objetivo="4.1">		<introducao>Só pode existir uma classe declarada <stmt>public</stmt> por arquivo contendo código fonte em Java.</introducao>		<resposta valor="v"/>	</questao>	<questao id="877" objetivo="4.1">		<introducao>O nome de um arquivo deve ser o mesmo da classe            declarada <stmt>public</stmt> neste arquivo.</introducao>		<resposta valor="v"/>	</questao>	<questao id="878" objetivo="4.1">		<introducao>Se uma classe faz parte de um <stmt>package</stmt>,            então a declaração do pacote deve ser a primeira sentença do            arquivo fonte.</introducao>		<resposta valor="v"/>	</questao>	<questao id="879" objetivo="4.1">		<introducao>Se um arquivo contém sentenças <stmt>import</stmt>,            então estas sentenças devem vir após a declaração <stmt>package</stmt>, caso o código deste arquivo faça parte de um pacote.</introducao>		<resposta valor="v"/>	</questao>	<questao id="880" objetivo="4.1">		<introducao>Se um código em Java não faz parte de um <stmt>package </stmt>, então sentenças            <stmt>import</stmt> podem ser as primeiras do arquivo em questão.</introducao>		<resposta valor="v"/>	</questao>	<questao id="881" objetivo="4.1">		<introducao>A sentença <stmt>package</stmt> e as sentenças <stmt>import</stmt> eventualmente existentes em um arquivo aplicam-se a todas as classes contidas neste arquivo.</introducao>		<resposta valor="v"/>	</questao>	<questao id="882" objetivo="4.1">		<introducao>O "esqueleto" da declaração de uma classe            é <stmt>public class NomeClasse {}</stmt>.</introducao>		<resposta valor="f">Apenas "class NomeClasse {}".</resposta>	</questao>	<questao id="883" objetivo="4.1">		<introducao>O código <stmt>public class Teste {}</stmt> compila            satisfatoriamente, gerando um arquivo de nome <it>Teste.class</it>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="884" objetivo="4.1">		<introducao>Antes da declaração de uma classe podem seguir            modificadores, que incluem: <stmt>public</stmt>, <stmt>protected</stmt>, <stmt>private</stmt>, <stmt>strictfp</stmt>, <stmt>final</stmt> e <stmt>abstract</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="885" objetivo="1.2">		<introducao>Em Java existem 4 (quatro) níveis de controle de acesso.</introducao>		<resposta valor="v"/>	</questao>	<questao id="886" objetivo="1.2">		<introducao>Em Java existem 4 (quatro) níveis de controle de            acesso e apenas 3 (três) modificadores de acesso.</introducao>		<resposta valor="v"/>	</questao>	<questao id="887" objetivo="1.2">		<introducao>Os modificadores de acesso são: <stmt>public</stmt>, <stmt>protected</stmt> e <stmt>private</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="888" objetivo="1.2">		<introducao>Quando nenhum dos três modificadores de acesso é            empregado, então o nível de acesso é o nível <it>default</it> ou de <it>package</it> (pacote).</introducao>		<resposta valor="v"/>	</questao>	<questao id="889" objetivo="1.2">		<introducao>Em Java, toda classe, método e variável de instância            tem um controle de acesso, estabelecido explicitamente ou não.</introducao>		<resposta valor="v"/>	</questao>	<questao id="890" objetivo="1.2">		<introducao>Uma classe só pode ser declarada, da perspectiva de            controle de acesso, como <stmt>public</stmt> ou de controle            de acesso <it>default</it>. Os outros dois níveis de            controle de acesso não fazem sentido para uma classe.</introducao>		<resposta valor="f">Classes que são membros de outras classes, podem utilizar os modificadores "private" e "protected".</resposta>	</questao>	<questao id="891" objetivo="1.2">		<introducao>Controle de acesso significa visibilidade e, de            fato, quando se diz que uma classe <stmt>A</stmt> tem acesso            a uma classe <stmt>B</stmt>, significa que <stmt>A</stmt> ou            pode criar instância da classe <stmt>B</stmt>, ou estender a            classe <stmt>B</stmt> (herança) ou ter acesso a métodos ou            variáveis  que fazem parte da classe <stmt>B</stmt>,            conforme o controle de acesso destes métodos e variáveis.</introducao>		<resposta valor="v"/>	</questao>	<questao id="892" objetivo="1.2">		<introducao>Uma classe cujo controle de acesso é <it>default</it> não é precedida por modificador de acesso quando declarada.</introducao>		<resposta valor="v"/>	</questao>	<questao id="893" objetivo="1.2">		<introducao>Se não é fornecido um controle de acesso para uma            classe, então o controle é o <it>default</it>, que é            estabelecido quando nenhum outro modificador é            explicitamente fornecido.</introducao>		<resposta valor="v"/>	</questao>	<questao id="894" objetivo="1.2">		<introducao>Uma classe com o controle de acesso <it>default</it>            pode ser <it>vista</it> somente por classes que fazem parte            do mesmo pacote.</introducao>		<resposta valor="v"/>	</questao>	<questao id="895" objetivo="1.2">		<introducao>Se as classes <stmt>A</stmt> e <stmt>B</stmt> fazem            parte de pacotes distintos e o nível de controle de acesso            delas é o <it>default</it>, então nenhuma delas é visível a outra.</introducao>		<resposta valor="v"/>	</questao>	<questao id="896" objetivo="1.2">		<introducao>Se a classe <stmt>Leite</stmt> faz parte do pacote <stmt>agropecuaria</stmt> e a classe          <stmt>Resfriador</stmt> faz parte do pacote <stmt>industria</stmt>, então nenhuma            destas classes é visível a outra, em outras palavras, é como            se para cada uma delas a outra simplesmente não existisse.</introducao>		<resposta valor="f">Não necessariamente. Caso uma delas seja "public", a outra poderá "enxergá-la".</resposta>	</questao>	<questao id="897" objetivo="1.2 (corrigir pergunta - &quot;classe&quot; está errado)">		<introducao>Se uma classe em construção e que faz parte do            pacote <stmt>A</stmt> tenta herdar uma classe do pacote <stmt>B</stmt>, cuja declaração é <stmt>classe Raiz {}</stmt>, então a compilação desta tentativa de criar uma            subclasse falha.</introducao>		<resposta valor="v"/>	</questao>	<questao id="898" objetivo="1.2">		<introducao>A compilação de uma classe de um pacote<stmt>X</stmt>, que tenta fazer acesso a uma classe  cujo controle de acesso é <it>default</it> e faz parte de um            pacote <stmt>Y</stmt>, falha.</introducao>		<resposta valor="v"/>	</questao>	<questao id="899" objetivo="1.2">		<introducao>Uma classe declarada como <stmt>public</stmt> é            visível em todas as classes, quaisquer que sejam os pacotes            que estas classes pertençam.</introducao>		<resposta valor="v"/>	</questao>	<questao id="900" objetivo="1.2">		<introducao>Todas as classes do universo Java têm acesso às            classes declaradas como <stmt>public</stmt>.</introducao>		<resposta valor="v">Sim, qualquer classe, em qualquer pacote, pode acessar classes public.</resposta>	</questao>	<questao id="900" objetivo="1.2">		<introducao>Todas as classes do universo Java têm acesso às            classes declaradas como <stmt>public</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="901" objetivo="1.2">		<introducao>Se uma classe declarada como <stmt>public</stmt>            pertence a um pacote diferente de uma classe que faz uso            desta classe declarada como <stmt>public</stmt>, então a            classe que faz uso deve conter a sentença            <stmt>import</stmt> para importar a classe declarada como <stmt>public</stmt>.</introducao>		<resposta valor="v">Outra maneira de acessar a <stmt>classe</stmt> seria através do uso do nome da da própria <stmt>classe</stmt> totalmente qualificado.		</resposta>	</questao>	<questao id="902" objetivo="1.2">		<introducao>Para que uma classe seja visível em todas as classes            de todos os pacotes, esta deve ser declarada como <stmt>public</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="903" objetivo="1.2">		<introducao>Se uma classe <stmt>B</stmt> não é declarada            <stmt>final</stmt> e não pode ser herdada por uma classe            <stmt>A</stmt>, então o controle de acesso de <stmt>B</stmt>            é <it>default</it> e o pacote ao qual a classe            <stmt>A</stmt> pertence é diferente daquele que            <stmt>B</stmt> pertence.</introducao>		<resposta valor="v"/>	</questao>	<questao id="904" objetivo="1.2">		<introducao>Da perspectiva de um dado pacote, todas as classes            ali contidas ou são visíveis exclusivamente no interior do            pacote, o que é estabelecido quando não se emprega o            modificador de acesso <stmt>public</stmt> quando da            declaração da classe, ou esta é declarada como            <stmt>public</stmt> e todas as demais do universo Java            possuem acesso a ela.</introducao>		<resposta valor="v"/>	</questao>	<questao id="905" objetivo="1.2">		<introducao>A declaração de uma classe pode ser modificada, além            do emprego de algum modificador de acesso, através das            palavras reservadas <stmt>final</stmt>,            <stmt>abstract</stmt> ou <stmt>strictfp</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="906" objetivo="1.2">		<introducao>Uma classe pode ser declarada <stmt>public</stmt> e <stmt>final</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="907" objetivo="1.2">		<introducao>A declaração <stmt>final public class B {}</stmt> é válida.</introducao>		<resposta valor="v"/>	</questao>	<questao id="908" objetivo="1.2">		<introducao>Uma classe pode ser declarada <stmt>abstract</stmt>            e <stmt>final</stmt>.</introducao>		<resposta valor="f">Se uma <stmt>classe</stmt> é declarada como <stmt>abstract</stmt>, espera-se que a implementação seja fornecida por uma sub-classe. Entretanto, com o modificador <stmt>final</stmt> isso não é possível.		</resposta>	</questao>	<questao id="909" objetivo="1.2">		<introducao>Uma classe pode ser declarada <stmt>abstract</stmt>            pode possuir uma subclasse declarada  <stmt>final</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="910" objetivo="1.2">		<introducao>Uma classe pode ser declarada <stmt>strictfp</stmt>            e <stmt>final</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="911" objetivo="1.2">		<introducao>Uma classe pode ser declarada <stmt>strictfp</stmt>            e <stmt>abstract</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="912" objetivo="1.2">		<introducao>A compilação de <stmt>abstract strictfp public class                C {}</stmt> falha.</introducao>		<resposta valor="f"/>	</questao>	<questao id="913" objetivo="1.2">		<introducao>A compilação de <stmt>abstract public strictfp                class C {}</stmt> falha.</introducao>		<resposta valor="f"/>	</questao>	<questao id="914" objetivo="1.2">		<introducao>A compilação de <stmt>strictfp abstract public class                C {}</stmt> falha.</introducao>		<resposta valor="f"/>	</questao>	<questao id="915" objetivo="1.2">		<introducao>			<stmt>strictfp</stmt> pode ser empregada para modificar uma variável.</introducao>		<resposta valor="f">			<stmt>strictfp</stmt> só é usado para modificar classes.		</resposta>	</questao>	<questao id="916" objetivo="1.2">		<introducao>			<stmt>strictfp</stmt> pode ser empregada para modificar um método.</introducao>		<resposta valor="f"/>	</questao>	<questao id="917" objetivo="1.2">		<introducao>			<stmt>strictfp</stmt> pode ser empregada para modificar uma classe.</introducao>		<resposta valor="v"/>	</questao>	<questao id="918" objetivo="1.2">		<introducao>Uma variável nunca pode ser declarada <stmt>strictfp</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="919" objetivo="1.2">		<introducao>Declarar uma classe como <stmt>strictf</stmt>            significa que todo método da classe irá seguir as regras do            padrão IEEE 754 para operações em ponto-flutuante.</introducao>		<resposta valor="v"/>	</questao>	<questao id="920" objetivo="1.2">		<introducao>Se uma classe não é declarada <stmt>strictfp</stmt>,            então operações em ponto-flutuante podem se comportar de            forma depentende de plataforma.</introducao>		<resposta valor="v"/>	</questao>	<questao id="921" objetivo="1.2">		<introducao>Mesmo que uma classe não seja declarada            <stmt>strictfp</stmt>, ela pode apresentar o mesmo            comportamento se fosse declarada <stmt>strictfp</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="922" objetivo="1.2">		<introducao>Declarar uma classe como <stmt>strictfp</stmt> é o            mesmo que declarar todos os seus métodos como <stmt>strictfp</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="923" objetivo="1.2">		<introducao>O código abaixo compila satisfatoriamente.<java><![CDATA[strictfp abstract public class C {    strictfp float f() { return 1.0f; }}]]></java>		</introducao>		<resposta valor="v"/>	</questao>	<questao id="924" objetivo="8.5">		<introducao>O código abaixo compila satisfatoriamente.<java><![CDATA[strictfp abstract public class C {    float f() { return 1.0; }}]]></java>		</introducao>		<resposta valor="f">A literal <stmt>1.0</stmt> não é do tipo <stmt>float</stmt>.</resposta>	</questao>	<questao id="925" objetivo="1.2">		<introducao>Quando usada na declaração de uma classe, a palavra            reservada <stmt>final</stmt> significa que a classe em            questão não pode possuir descendente (subclasse).</introducao>		<resposta valor="v"/>	</questao>	<questao id="926" objetivo="4.4">		<introducao>			<stmt>extend</stmt> é palavra reservada.</introducao>		<resposta valor="f"/>	</questao>	<questao id="927" objetivo="1.2">		<introducao>A declaração <stmt>class D extends C {}</stmt> é            válida se a classe <stmt>C</stmt> é declarada como <stmt>final</stmt>.</introducao>		<resposta valor="f"/>	</questao>	<questao id="928" objetivo="1.2">		<introducao>Se há dependência específica e imprescindível da            implementação de métodos de uma classe, então a declaração            da classe como <stmt>final</stmt> garante que estas            implementações não serão alteradas (<it>overridden</it>).</introducao>		<resposta valor="v"/>	</questao>	<questao id="929" objetivo="1.2">		<introducao>A classe que contém o método <stmt>main</stmt> a ser            executado quando da execução da aplicação em questão deve,            necessariamente, ser declarada <stmt>public</stmt>.</introducao>		<resposta valor="f"/>	</questao>	<questao id="930" objetivo="1.2">		<introducao>A compilação do código abaixo falha.<java><![CDATA[strictfp public class C {    public static void main(String[] args) {        System.out.println("main C");    }}class D extends C {    public static void main(String[] args) {        System.out.println("main D");    }}]]></java>		</introducao>		<resposta valor="f"/>	</questao>	<questao id="931" objetivo="1.2">		<introducao>A tentativa de execução da classe <stmt>D</stmt>            gera uma exceção.<java><![CDATA[strictfp public class C {    public static void main(String[] args) {        System.out.println("main C");    }}class D extends C {}]]></java>		</introducao>		<resposta valor="f"/>	</questao>	<questao id="932" objetivo="1.2">		<introducao>Ao fornecer a classe <stmt>D</stmt> para que a            máquina virtual Java a execute, a mensagem <stmt>main            C</stmt> é impressa.<java><![CDATA[strictfp public class C {    public static void main(String[] args) {        System.out.println("main C");    }}class D extends C {}]]></java>		</introducao>		<resposta valor="v"/>	</questao>	<questao id="933" objetivo="1.2">		<introducao>O motivo da existência de uma classe            <stmt>abstract</stmt> é ser herdada.</introducao>		<resposta valor="v"/>	</questao>	<questao id="934" objetivo="1.2">		<introducao>Não se pode criar instância(s) de uma classe <stmt>abstract</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="935" objetivo="1.2">		<introducao>Não se pode criar instância(s) de uma classe            diretamente derivada de uma classe <stmt>abstract</stmt>.</introducao>		<resposta valor="f"/>	</questao>	<questao id="936" objetivo="1.2">		<introducao>A compilação do código abaixo falha.<java><![CDATA[public abstract class E {}class F extends E {}]]></java>		</introducao>		<resposta valor="f"/>	</questao>	<questao id="937" objetivo="1.2">		<introducao>Uma classe declarada <stmt>abstract</stmt> deve            possuir pelo menos um método <stmt>abstract</stmt>.</introducao>		<resposta valor="f"/>	</questao>	<questao id="938" objetivo="1.2">		<introducao>Uma classe que possui pelo menos um método            <stmt>abstract</stmt> deve ser declarada <stmt>abstract</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="939" objetivo="1.2">		<introducao>A compilação do código abaixo falha.<java><![CDATA[public abstract class E {    abstract void ok();}class F extends E {}]]></java>		</introducao>		<resposta valor="v">Observe que a classe <stmt>F</stmt>            não implementa o método <stmt>ok</stmt> e, portanto, deve            ser declarada <stmt>abstract</stmt>.</resposta>	</questao>	<questao id="940" objetivo="1.2">		<introducao>A classe que implementa o método <stmt>main</stmt>            chamado pela máquina virtual Java pode ser declarada <stmt>abstract</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="941" objetivo="1.2">		<introducao>Uma variável de instância pode ser daclarada <stmt>abstract</stmt>.</introducao>		<resposta valor="f"/>	</questao>	<questao id="942" objetivo="1.2">		<introducao>Um método declarado <stmt>abstract</stmt> não pode            possuir um corpo (bloco de código).</introducao>		<resposta valor="v"/>	</questao>	<questao id="943" objetivo="1.2">		<introducao>A declaração do método <stmt>abstract void ok()            {}</stmt> falha.</introducao>		<resposta valor="v"/>	</questao>	<questao id="944" objetivo="1.2">		<introducao>A classe abaixo gera um erro de compilação.<java><![CDATA[public abstract class E {    abstract void ok();}abstract class F extends E {    public static void main(String[] args) {        System.out.println("main F");    }}]]></java>		</introducao>		<resposta valor="f"/>	</questao>	<questao id="945" objetivo="1.2">		<introducao>A declaração de um método termina com            ponto-e-vírgula quando este é declarado <stmt>abstract</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="946" objetivo="1.2">		<introducao>Quando o método de uma classe não é declarado            <stmt>abstract</stmt>, sua declaração deve terminar,            necessariamente, por <stmt>}</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="947" objetivo="1.2">		<introducao>Se a declaração de um método de uma classe termina            com ponto-e-vírgula, então o método e a classe devem ser            declarados como <stmt>abstract</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="948" objetivo="1.2">		<introducao>Se um único método é declarado            <stmt>abstract</stmt>, então a classe deve ser declarada <stmt>abstract</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="949" objetivo="1.2">		<introducao>Uma classe <stmt>abstract</stmt> pode possuir            métodos que não são <stmt>abstract</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="950" objetivo="1.2">		<introducao>Uma classe <stmt>abstract</stmt> deve ser herdada,            enquanto uma classe <stmt>final</stmt> não pode ser herdada.</introducao>		<resposta valor="v"/>	</questao>	<questao id="951" objetivo="1.2">		<introducao>Uma classe declarada <stmt>abstract</stmt> pode            possuir métodos declarados <stmt>final</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="952" objetivo="1.2">		<introducao>A compilação da classe abaixo falha.<java><![CDATA[public abstract class E {    abstract void ok();    final void ok(int i) {}}]]></java>		</introducao>		<resposta valor="f"/>	</questao>	<questao id="953" objetivo="1.2">		<introducao>Métodos e variáveis de instância (não locais) de uma            classe são chamados de membros.</introducao>		<resposta valor="v"/>	</questao>	<questao id="954" objetivo="1.2">		<introducao>Uma classe pode ser declarada, da perspectiva de            controle de acesso, apenas como <stmt>public</stmt> ou,            alternativamente e de forma implícita, <it>default</it>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="955" objetivo="1.2">		<introducao>Uma classe não pode ser declarada            <stmt>protected</stmt> ou <stmt>private</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="956" objetivo="1.2">		<introducao>Todos os quatro níveis de controle de acesso podem            ser aplicados aos membros de uma classe.</introducao>		<resposta valor="v"/>	</questao>	<questao id="957" objetivo="1.2">		<introducao>Uma variável de instância pode ser declarada como            <stmt>public</stmt>, <stmt>protected</stmt>,            <stmt>private</stmt> ou <it>default</it>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="958" objetivo="1.2">		<introducao>Um método de uma classe pode ser declarado como            <stmt>public</stmt>, <stmt>protected</stmt>,            <stmt>private</stmt> ou <it>default</it>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="959" objetivo="1.2">		<introducao>O controle de acesso <it>default</it> é obtido            quando não é fornecido nenhuma das palavras reservadas que            explicitamente define o controle de acesso. Ou seja,            <stmt>public</stmt>, <stmt>protected</stmt> ou <stmt>private</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="960" objetivo="1.2">		<introducao>Se uma classe <stmt>A</stmt> tem acesso so membros            de uma classe <stmt>B</stmt>, então os membros de            <stmt>B</stmt> são visíveis à classe <stmt>A</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="961" objetivo="1.2">		<introducao>Quando uma classe não tem acesso a um membro de uma            outra classe, o compilador informa que há uma tentativa de            de ser acesso a alguma coisa que supostamente a classe            requisitante não deveria sequer saber que existe.</introducao>		<resposta valor="v"/>	</questao>	<questao id="962" objetivo="1.2">		<introducao>Para que uma classe faça uso de um método de outra            classe, é necessário empregar o operador <stmt>.</stmt> para            chamar o método desejado da instância em questão.</introducao>		<resposta valor="v"/>	</questao>	<questao id="963" objetivo="1.2">		<introducao>Nem sempre os métodos de uma superclasse são            herdados pela subclasse.</introducao>		<resposta valor="v"/>	</questao>	<questao id="964" objetivo="1.2">		<introducao>Se uma classe <stmt>A</stmt> não está acessível a            uma classe <stmt>B</stmt>, então nenhum método de            <stmt>A</stmt> está acessível da classe <stmt>B</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="965" objetivo="1.2">		<introducao>Quando um método ou variável de instância de            determinada classe é declarado <stmt>public</stmt>, este            membro está acessível a todas as classes nas quais a classe            que contém o membro está acessível.</introducao>		<resposta valor="v"/>	</questao>	<questao id="966" objetivo="1.2">		<introducao>Se um método ou variável de instância está acessível            sem o emprego do operador <stmt>.</stmt> significa que o            membro em questão pertence à classe na qual o acesso pode            ser realizado.</introducao>		<resposta valor="v"/>	</questao>	<questao id="967" objetivo="1.2">		<introducao>Membros declarados <stmt>private</stmt> não são            visíveis a qualquer código além daquele que é parte da            classe na qual são declarados.</introducao>		<resposta valor="v"/>	</questao>	<questao id="968" objetivo="1.2">		<introducao>Se um determinado membro de uma classe            <stmt>A</stmt>é acessível de uma classe <stmt>B</stmt>,            então este membro pode ter sido declarado <stmt>private</stmt>.</introducao>		<resposta valor="f"/>	</questao>	<questao id="969" objetivo="1.2">		<introducao>Um membro declarado <stmt>private</stmt> é visível            apenas pelo código da classe da qual é membro.</introducao>		<resposta valor="v"/>	</questao>	<questao id="970" objetivo="1.2">		<introducao>Um membro declarado <stmt>private</stmt> não pode            ser herdado.</introducao>		<resposta valor="v"/>	</questao>	<questao id="971" objetivo="1.2">		<introducao>Uma subclasse de uma classe que possui um membro            <stmt>private</stmt> não pode &quot;ver&quot;,  fazer uso,            sobrepor (<it>override</it>) ou sobrecarregar            (<it>overload</it>) este membro.</introducao>		<resposta valor="v"/>	</questao>	<questao id="972" objetivo="1.2">		<introducao>Um método declarado <stmt>private</stmt> não pode            ser sobreposto (<it>overrided</it>) por método de uma sublcasse.</introducao>		<resposta valor="v"/>	</questao>	<questao id="973" objetivo="1.2">		<introducao>Sobreposição (<it>override</it>) depende de herança.            Como membro <stmt>private</stmt> não pode ser herdado,            conclui-se que método <stmt>private</stmt> não pode ser            sobreposto (<it>overriden</it>).</introducao>		<resposta valor="v"/>	</questao>	<questao id="974" objetivo="1.2">		<introducao>Um membro declarado <stmt>protected</stmt> é            acessível, por meio de herança, por subclasse mesmo que esta            encontre-se em um <stmt>package</stmt> distinto daquele da            classe herdada.</introducao>		<resposta valor="v"/>	</questao>	<questao id="975" objetivo="1.2">		<introducao>Um membro declarado com o modificador de acesso            <it>default</it>, ou seja, sem o emprego de um modificador            explícito como <stmt>public</stmt>, <stmt>protected</stmt>            ou <stmt>private</stmt>, é acessível apenas pelas classes            que pertencem ao mesmo <stmt>package</stmt> da classe onde é declarado.</introducao>		<resposta valor="v"/>	</questao>	<questao id="976" objetivo="1.2">		<introducao>A diferença entre um membro declarado            <stmt>protected</stmt> ou <it>default</it> (ou controle de            acesso de <stmt>package</stmt>) diferem apenas quanto a subclasses.</introducao>		<resposta valor="v"/>	</questao>	<questao id="977" objetivo="1.2">		<introducao>Se um membro é declarado <stmt>protected</stmt>,            então qualquer subclasse da classe que contém este membro,            mesmo que parte de um <stmt>package</stmt> distinto, tem            acesso ao membro.</introducao>		<resposta valor="v"/>	</questao>	<questao id="978" objetivo="1.2">		<introducao>O modificador de controle de acesso <it>default</it>            pode ser interpretado como &quot;restrição de <stmt>package</stmt>&quot;.</introducao>		<resposta valor="v"/>	</questao>	<questao id="979" objetivo="1.2">		<introducao>Quando se pensa em <stmt>protected</stmt>, uma            perspectiva é acesso <it>default</it> acrescido de subclasses.</introducao>		<resposta valor="v"/>	</questao>	<questao id="980" objetivo="1.2">		<introducao>O modificador de controle de acesso <it>default</it>            é mais restritivo que o modificador <stmt>protected</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="981" objetivo="1.2">		<introducao>Um membro declarado <stmt>protected</stmt> de uma            classe de um <stmt>package</stmt> é acessível via referência            contida em outra classe de outro <stmt>package</stmt>.</introducao>		<resposta valor="f"/>	</questao>	<questao id="982" objetivo="1.2">		<introducao>Um membro declarado <stmt>protected</stmt> e herdado            por uma subclasse pode ser empregado por esta subclasse como            se fosse <stmt>public</stmt>.</introducao>		<resposta valor="f">Exceto se as classes pertencerem a um            mesmo <stmt>package</stmt>.</resposta>	</questao>	<questao id="983" objetivo="1.2">		<introducao>Uma subclasse tem acesso a um membro            <stmt>protected</stmt> da superclasse apenas por meio de herança.</introducao>		<resposta valor="v"/>	</questao>	<questao id="984" objetivo="1.2">		<introducao>Um membro declarado <stmt>protected</stmt>            encontra-se acessível a uma subclasse da classe na qual é            declarado apenas por meio de herança.</introducao>		<resposta valor="v"/>	</questao>	<questao id="985" objetivo="1.2">		<introducao>Se uma classe <stmt>A</stmt> contém um membro            <stmt>mA</stmt>declarado <stmt>protected</stmt> e é herdada            por uma classe <stmt>B</stmt> declarada em outro            <stmt>package</stmt>, então a sentença <stmt>iA.mA</stmt>,            onde <stmt>iA</stmt> é uma instância da classe            <stmt>A</stmt>, compila sem falha.</introducao>		<resposta valor="f">Membro declarado <stmt>protected</stmt>            só é acessível ao código de uma subclasse de outro            <stmt>package</stmt> por meio de herança.</resposta>	</questao>	<questao id="986" objetivo="1.2">		<introducao>Subclasse em um <stmt>package</stmt> distinto da            superclasse herda os membros <stmt>protected</stmt> da superclasse.</introducao>		<resposta valor="v"/>	</questao>	<questao id="987" objetivo="1.2">		<introducao>Subclasse de <stmt>package</stmt> distinto daquele            da superclasse não tem acesso aos membros            <stmt>protected</stmt> da superclasse através de uma            referência para esta.</introducao>		<resposta valor="v"/>	</questao>	<questao id="988" objetivo="1.2">		<introducao>A classe abaixo            <java><![CDATA[package modificador.outro;public class A {    private int x = 1;}]]></java>            é herdada pela classe <stmt>G</stmt>, conforme            segue.<java><![CDATA[package modificador;import modificador.outro.A;public class G extends A {    public static void main(String[] args) {        System.out.println(x);    }}]]></java>A            compilação da classe <stmt>A</stmt> não falha, o contrário            do resultado da compilação da classe <stmt>G</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="989" objetivo="1.2">		<introducao>A classe abaixo            <java><![CDATA[package modificador.outro;public class A {    private int x = 1;}]]></java>            é herdada pela classe <stmt>G</stmt>, conforme            segue.<java><![CDATA[package modificador;import modificador.outro.A;public class G extends A {    public static void main(String[] args) {        A a = new A();        System.out.println(a.x);    }}]]></java>A            compilação da classe <stmt>A</stmt> não falha, o contrário            do resultado da compilação da classe <stmt>G</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="990" objetivo="1.2">		<introducao>A classe <stmt>B</stmt>			<java><![CDATA[package modificador.outro;public class B {    protected int x = 2;}]]></java>herdada            pela classe <stmt>H</stmt>			<java><![CDATA[package modificador;import modificador.outro.B;public class H extends B {    public static void main(String[] args) {        System.out.println(x);    }}]]></java>compila            satisfatoriamente, enquanto a compilação da classe            <stmt>H</stmt> falha.</introducao>		<resposta valor="v"/>	</questao>	<questao id="991" objetivo="1.2">		<introducao>A classe <stmt>B</stmt>			<java><![CDATA[package modificador.outro;public class B {    protected int x = 2;}]]></java>herdada            pela classe <stmt>H</stmt>			<java><![CDATA[package modificador;import modificador.outro.B;public class H extends B {    public static void main(String[] args) {        System.out.println(new H().x);    }}]]></java>compila            satisfatoriamente, enquanto a compilação da classe            <stmt>H</stmt> falha.</introducao>		<resposta valor="f"/>	</questao>	<questao id="992" objetivo="1.2">		<introducao>A classe <stmt>C</stmt>			<java><![CDATA[package modificador.outro;public class C {    public int x = 3;}]]></java>herdada            pela classe <stmt>I</stmt>			<java><![CDATA[package modificador;import modificador.outro.C;public class I extends C {    public static void main(String[] args) {        System.out.println(x);    }}]]></java>compila            sem falhas, ao contrário da compilação da classe <stmt>I</stmt>.</introducao>		<resposta valor="v"/>	</questao>	<questao id="993" objetivo="1.2">		<introducao>A classe <stmt>C</stmt>			<java><![CDATA[package modificador.outro;public class C {    public int x = 3;}]]></java>herdada            pela classe <stmt>I</stmt>			<java><![CDATA[package modificador;import modificador.outro.C;public class I extends C {    public static void main(String[] args) {        System.out.println(new C().x);    }}]]></java>compila            sem falhas, ao contrário da compilação da classe <stmt>I</stmt>.</introducao>		<resposta valor="f"/>	</questao>	<questao id="994" objetivo="1.2">		<introducao>A classe <stmt>J</stmt>			<java><![CDATA[package modificador;public class J extends I {    public static void main(String[] args) {        System.out.println(new J().x);    }}]]></java>            estende (herda) da classe <stmt>I</stmt>			<java><![CDATA[package modificador;import modificador.outro.C;public class I extends C {    public static void main(String[] args) {        System.out.println(new C().x);    }}]]></java>que            herda da classe <stmt>C</stmt> em outro            <stmt>package</stmt>.<java><![CDATA[package modificador.outro;public class C {    public int x = 3;}]]></java>Todas            estas classes compilam satisfatoriamente.</introducao>		<resposta valor="v"/>	</questao>	<questao id="995" objetivo="1.2">		<introducao>A classe <stmt>B</stmt>			<java><![CDATA[package modificador.outro;public class B {    protected static int x = 2;}]]></java>é            herdada pela classe <stmt>H</stmt>			<java><![CDATA[package modificador;import modificador.outro.B;public class H extends B {    public static void main(String[] args) {        System.out.println(x);    }}]]></java>que            é herdada pela classe <stmt>K</stmt>			<java><![CDATA[package modificador;public class K extends H {    public static void main(String[] args) {        System.out.println(x);    }}]]></java>Nenhuma            compilação destas classes falha.</introducao>		<resposta valor="v"/>	</questao>	<questao id="996" objetivo="1.2">		<introducao>A classe <stmt>B</stmt>			<java><![CDATA[package modificador.outro;public class B {    protected static int x = 2;}]]></java>é            herdada pela classe <stmt>H</stmt>			<java><![CDATA[package modificador;import modificador.outro.B;public class H extends B {    public static void main(String[] args) {        System.out.println(x);    }}]]></java>que            é herdada pela classe <stmt>K</stmt>			<java><![CDATA[package modificador;public class K extends H {    public static void main(String[] args) {        System.out.println(new K().x = 2);    }}]]></java>Nenhuma            compilação destas classes falha.</introducao>		<resposta valor="v"/>	</questao>	<questao id="997" objetivo="1.2">		<introducao>A classe <stmt>B</stmt>			<java><![CDATA[package modificador.outro;public class B {    protected static int x = 2;}]]></java>é            herdada pela classe <stmt>H</stmt>			<java><![CDATA[package modificador;import modificador.outro.B;public class H extends B {    public static void main(String[] args) {        System.out.println(x);    }}]]></java>e            <stmt>H</stmt> é usada pela classe <stmt>K</stmt>			<java><![CDATA[package modificador;public class K {    public static void main(String[] args) {        System.out.println(new H().x = 2);    }}]]></java>Nenhuma            compilação destas classes falha.</introducao>		<resposta valor="f"/>	</questao>	<questao id="998" objetivo="1.2">		<introducao>A classe <stmt>B</stmt>			<java><![CDATA[package modificador.outro;public class B {    protected int x = 2;}]]></java>é            herada pela classe <stmt>H</stmt>			<java><![CDATA[package modificador;import modificador.outro.B;public class H extends B {    public static void main(String[] args) {        System.out.println(new B().x);    }}]]></java>cuja            compilação falha.</introducao>		<resposta valor="v">Membro <stmt>protected</stmt> é            visível a subclasse de outro <stmt>package</stmt> via herança.</resposta>	</questao>	<questao id="999" objetivo="1.2">		<introducao>A classe <stmt>B</stmt>			<java><![CDATA[package modificador.outro;public class B {    protected int x = 2;}]]></java>é            herada pela classe <stmt>H</stmt>			<java><![CDATA[package modificador;import modificador.outro.B;public class H extends B {    public static void main(String[] args) {        System.out.println(new H().x);    }}]]></java>cuja            compilação falha.</introducao>		<resposta valor="f"/>	</questao>	<questao id="1000" objetivo="1.2">		<introducao>A classe <stmt>B</stmt> declara um membro            <stmt>protected</stmt>.<java><![CDATA[package modificador.outro;public class B {    protected int x = 2;}]]></java>A            classe <stmt>H</stmt> herda da classe <stmt>B</stmt> e faz            uso do membro <stmt>protected</stmt> corretamente. Contudo,            a classe <stmt>Uso</stmt> provoca um erro de compilação ao            tentar fazer uso do membro <stmt>protected</stmt> herdado            pela classe <stmt>H</stmt>.</introducao>		<resposta valor="v">Membro <stmt>protected</stmt>            herdado só é visível a outras classes por meio de herança.</resposta>	</questao></Avaliacao>