Reorganização (Fábio Nogueira de Lucena)

= Introdução = 

A presente página e outras correspondentes foram elaboradas
sobre o conteúdo do capítulo 1 do livro _Refactoring: Improving the Design of
Existing Code_, Martin Fowler, Addion-Wesley, 1999. Isto significa que os
créditos do exemplo são do livro citado e ilustram a habilidade do
correspondente autor, Martin Fowler. *Tanto os modelos quanto o 
código, exceto quando dito o contrário, seguem as versões originais fornecidas no livro supracitado.* Há, contudo, várias diferenças.

Esta e demais páginas têm propósito similar ao do capítulo referenciado, ou
seja, introduzir o assunto _refactoring_ por meio de exemplos. Aqui é
empregado o termo _reorganização_ com a acepção de _refactoring_. A
alternativa ao texto aqui criada não tem o propósito de substituir a
anterior. Experiências com o ensino, contudo, revelam que algumas explanações
adicionais, aqui fornecidas, são relevantes para o entendimento, o que motiva
este texto e o torna único.

= O problema =

Software para calcular a "situação" de um cliente de uma vídeo locadora. Por
situação entenda quanto deve ser pago pelo cliente da vídeo locadora para um
conjunto de vídeos alugados, cada um deles por determinado período. O cálculo
também leva em consideração o tipo do vídeo e determina a quantidade de pontos
que o cliente recebe, o que depende do filme ser uma novidade ou não.

Abaixo segue o diagrama que ilustra este modelo. 

http://exemplos.googlecode.com/svn/tags/refactoring-v0/images/v0.png

A implementação inicial de cada uma destas classes também se encontra disponível: [http://exemplos.googlecode.com/svn/tags/refactoring-v0/src/Movie.java Movie.java], [http://exemplos.googlecode.com/svn/tags/refactoring-v0/src/Customer.java Customer.java] e [http://exemplos.googlecode.com/svn/tags/refactoring-v0/src/Rental.java Rental.java].

Conforme Martin Fowler descreve, o código fornecido por estas classes certamente não é orientado a objeto e, convém ressaltar, não há nenhum problema com ele dado que se trata de um _software_ de aplicação muito restrita. Contudo, se esta é uma parte representativa de um sistema, então existem problemas reais com este código. 

Uma dificuldade com este código fica clara com o contexto onde os clientes desejam, por exemplo, que a situação de um cliente também seja fornecida em HTML (*mudança 1*). Percebe-se que, conforme está, haverá significativa duplicação de código para simplesmente transformar a sentença corrente em uma versão HTML correspondente. Neste caso, observe que, quando uma mudança ocorrer na estratégia de comercialização, teremos que efetuar mudanças correspondentes em mais de um único local. 

Uma outra mudança (*mudança 2*) é alterar a forma de classificação dos filmes. Clientes ainda não possuem claramente o que deverá ser alterado, mas já se sabe que teremos alteração na forma em que os filmes serão classificados.

Estas duas mudanças irão repercutir no método {{{statement()}}}. Antes das mudanças, contudo, é preciso dispor de testes de unidade, para assegurar que mudanças não introduziram erros. 

A página de [refactorTestes testes] introduz os testes de unidade.

= Primeira mudança =
O método {{{statement()}}} é muito longo, conseqüência das várias atividades que desempenha. Dividi-lo, portanto, não é um começo ruim. Não é difícil perceber que o {{{switch}}} é um candidato forte e será este o principal corpo do método a ser criado {{{amountFor()}}}. Veja o resultado desta alteração em [http://exemplos.googlecode.com/svn/tags/refactoring-v1/src/Customer.java Customer.java].

Após a alteração a primeira orientação é para a execução dos testes de unidade que, neste caso, ressaltam uma falha. A falha pode ser identificada sem muita dificuldade. O método {{{amountFor()}}} define a variável {{{thisAmount}}} com o tipo {{{int}}}, enquanto o correto é o tipo {{{double}}}. Ao fazer esta alteração temos código que, após a modificação, passa nos testes criados. Veja a versão resultante da classe {{{Customer}}} após as mudanças em [http://exemplos.googlecode.com/svn/tags/refactoring-v2/src/Customer.java Customer.java].

= Segunda mudança =
Alguns identificadores empregados no método {{{amountFor()}}} podem ser mais claros. Por exemplo, {{{each}}} é menos preciso que {{{aRental}}}, assim como {{{thisAmount}}} não é tão esclarecedor quanto {{{result}}}. Estas alterações conduzem à nova versão disponível em [http://exemplos.googlecode.com/svn/tags/refactoring-v3/src/Customer.java Customer.java].

Conforme Martin Fowler ressalta na página 15, "Qualquer tolo pode escrever código que um computador pode compreender. Bons programadores escrevem código que seres humanos podem compreender".


= Terceira mudança =
Quando se observa o método {{{amountFor()}}} em [http://exemplos.googlecode.com/svn/tags/refactoring-v3/src/Customer.java Customer.java], nota-se que nenhuma informação pertinente a cliente é empregada por este método. Esta é uma sugestão de que talvez o método esteja em classe errada. Todas as informações empregadas por este método encontram-se na classe {{{Rental}}} e, portanto, é para lá que este método será movido. 

Para mover este método, primeiro faça a cópia do mesmo para o local de destino. Aproveite para renomeá-lo para {{{getCharge()}}}. Conforme ilustrado, o argumento também foi removido. Após estas alterações, verifique se o novo método criado funciona. Ou seja, substitua o corpo do método {{{amountFor(Rental aRental)}}} por {{{return aRental.getCharge()}}}.