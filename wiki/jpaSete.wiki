#summary Definição de campos/atributos a serem persistidos. (Fábio Nogueira de Lucena)

=== Onde obter ===
[http://exemplos.googlecode.com/svn/trunk/ejb3/jpaSete/]

Exemplos ([http://code.google.com/p/exemplos/wiki/ejbPersistence série]): [http://code.google.com/p/exemplos/wiki/jpaSeis ANTERIOR] e [http://code.google.com/p/exemplos/wiki/jpaOito PRÓXIMO].

= Introdução =

Como evitar que um campo seja persistido pelo _persistence provider_? Observe a classe Pessoa abaixo e o cenário onde *rua* e *numero* deve ser persistido, enquanto *nome* não deve ser persistido. Provavelmente este não é um cenário real, mas há muitos casos onde não se tem a intenção de persistir determinado campo. 

{{{
public class Pessoa {
    private String nome;
    private String rua;
    private int numero;
	
    public Pessoa(String nome) {
	this.nome = nome;
    }
	
    public String toString() {
	return nome;
    }

    // Métodos get/set para rua e numero omitidos (por simplicidade)
}
}}}

= Mapear a classe em questão =
A classe Pessoa, mapeada conforme a restrição fornecida acima, é fornecida abaixo.

{{{
package sete;

import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;
import javax.persistence.Transient;

@Entity
public class Pessoa {
    @Id
    @GeneratedValue
    private Long id;

    // Propriedades persistidas por padrão (sem anotação)
    private String rua;
    private int numero;

    // Ignora propriedade (não será persistida)
    @Transient
    private String nome;

    public Pessoa() {}

    public Pessoa(String nome, String rua, int numero) {
	this.nome = nome;
	this.rua = rua;
	this.numero = numero;
    }

    public String toString() {
	return nome + " " + rua + " " + numero;
    }
	
    public Long getId() { 
	return id;
    }
}
}}}

A anotação *@Entity* indica que objetos desta classe podem ser unicamente identificados. Esta identificação é estabelecida pelo campo marcado com a anotação *@Id*. Também foi estabelecido que o valor para este campo será fornecido pelo _persistence provider_, conforme a anotação *@!GeneratedValue*. 

As propriedades *rua* e *numero* seguem sem anotações. Por padrão, serão persistidas. O mesmo ocorreria com a propriedade *nome* se esta não tivesse sido anotada com *@Transient*.

= Compilar a classe mapeada =
A compilação também não sofre alterações. 

{{{
ant compile
}}}

= Iniciar o SGBD =
Para iniciar o SGBD precisamos do comando abaixo. 

{{{
ant db-start
}}}

Convém ressaltar que cada SGBD possui modo próprio para iniciá-lo. O comando acima executa todas as operações necessários para o HSQLDB. Consulte o arquivo *build.xml* para detalhes.

= Criar o esquema no SGBD =

{{{
ant schema
}}}

Para verificar a criação do esquema, comando acima, pode ser executado um cliente com acesso à base de dados em questão, conforme abaixo.

{{{
ant db-client
}}}


= Criar um programa que requisita serviços oferecidos pela JPA API =
O programa abaixo mantém a mesma simplicidade do exemplo anterior. Contudo, duas linhas foram acrescentadas para fornecer detalhes pertinentes às propriedades *rua* e *numero*.

{{{
package dois;

import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.EntityTransaction;
import javax.persistence.Persistence;

public class PessoaAplicacaoJpa {
    public static void main(String[] args) {
	EntityManagerFactory emf = Persistence.createEntityManagerFactory("jpaDois");
	EntityManager em = emf.createEntityManager();
	EntityTransaction tx = em.getTransaction();
	tx.begin();
		
	Pessoa p = new Pessoa("Outro nome próprio");
        p.setRua("Rua das Camélias");
        p.setNumero(321);
		
	em.persist(p);
	tx.commit();
	em.close();
    }
}

}}}


= Configurar o persistence provider =
A configuração do _persistence provider_ é modificado em apenas uma informação: o identificador da unidade de persistência. Neste caso, foi substituído o valor anterior "jpaUm" por "jpaDois". Nenhuma outra alteração foi realizada. Observe que exemplos posteriores irão explorar esta configuração em detalhes. 

{{{
<?xml version="1.0" encoding="UTF-8"?>
<persistence xmlns="http://java.sun.com/xml/ns/persistence"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.0"
	xsi:schemaLocation="http://java.sun.com/xml/ns/persistence
		http://java.sun.com/xml/ns/persistence/persistence_1_0.xsd">

	<persistence-unit name="jpaDois">
		<description>
			Exemplo simples de persistência usando JPA. 
		</description>
		
		<provider>org.hibernate.ejb.HibernatePersistence</provider>
		<class>um.Pessoa</class>
		
		<properties>
			<property name="hibernate.archive.autodetetion"	value="class"/>
			
			<property name="hibernate.dialect"
				value="org.hibernate.dialect.HSQLDialect" />
			<property name="hibernate.connection.driver_class"
				value="org.hsqldb.jdbcDriver" />
			<property name="hibernate.connection.username" value="sa" />
			<property name="hibernate.connection.password" value="" />
			<property name="hibernate.connection.url"
				value="jdbc:hsqldb:hsql://localhost/kyrios-teste" />
			<property name="" value="" />
		</properties>
	</persistence-unit>
</persistence>
}}}

=Compilar e executar o programa criado no passo anterior=

{{{
ant compile
}}}

O comando para a execução da classe que usufrui da API também é a mesma:

{{{
ant run -Dclasse=dois.PessoaAplicacaoJpa
}}}

Após a execução deste comando, uma instância adicional deve estar disponível no SGBD. A execução da consulta _select * from pessoa_ por meio de um cliente do SGBD poderá indicar que, de fato, uma instância adicional foi inserida no SGBD.

*Execução a partir do ambiente Eclipse*. Não se esqueça de incluir no _classpath_ o diretório *etc*, pois é no _classpath_ que será procurado o diretório *META-INF*, empregado para a configuração do _persistence provider_. 

= Visão geral de todos os artefatos empregados =
Em tempo, todos os artefatos do exemplo podem ser obtidos em [http://exemplos.googlecode.com/svn/trunk/ejb3/jpaDois/]. O conteúdo dos artefatos também é o mesmo, exceto para as mudanças identificadas acima.

= Considerações finais = 
O exemplo acima também é simples. O objetivo foi reforçar um processo comum para a persistência empregando JPA, aumentar a familiaridade com as ferramentas empregadas e, especialmente, ressaltar que o emprego de JPA tenta ser tão menos intrusivo quanto possível. Este último item é claro ao observar que o acréscimo de duas novas propriedades não exigiram que o mapeamento fosse alterado. Naturalmente, isto só foi possível porque o padrão oferecido pelo JPA é suficiente, para este caso.  