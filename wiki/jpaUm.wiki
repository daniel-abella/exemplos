#summary Persistindo uma instância com JPA (Fábio Nogueira de Lucena)

=== Onde obter ===
[http://exemplos.googlecode.com/svn/trunk/ejb3/jpaUm/]

= Introdução =

O que é preciso para persistir instâncias de uma classe (como aquela abaixo)?

{{{
public class Pessoa {
    private String nome;
	
    public Pessoa(String nome) {
	this.nome = nome;
    }
	
    public String toString() {
	return nome;
    }
}
}}}


= Resumo de atividades para persistir instâncias de uma classe =
 * _Mapear a classe em questão_. Isto significa informar ao _persistence provider_ como cada classe deve ser persistida em uma tabela. Em boa parte, valores automaticamente fornecidos são suficientes. 
 * _Iniciar o SGBD_. Um SGBD deve estar disponível para uso. 
 * _Criar o esquema no SGBD_. O mapeamento anteriormente realizado define o esquema a ser empregado pelo _persistence provider_ para persistir um objeto da classe mapeada no SGBD empregado. 
 * _Criar e executar um programa que requisita a persistência de instância da classe mapeada_.


=== Mapear a classe em questão ===
A classe anterior, após modificada para conter o mapeamento necessário, é exibida abaixo.

{{{
package um;

import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;

@Entity
public class Pessoa {
    @Id @GeneratedValue
    private Long id;
	
    private String nome;
	
    public Pessoa() {}
	
    public Pessoa(String nome) {
	this.nome = nome;
    }
	
    public String toString() {
	return nome;
    }
}
}}}

Várias são as diferenças. *@Entity* é empregada para indicar que a classe em questão é uma entidade (_EJB entity_). *@Id* e *@!GeneratedValue* indicam que a propriedade em questão, *id*, será empregada como chave na tabela onde instâncias da classe Pessoa forem persistidas. Em particular, o valor desta chave será automaticamente gerado. A outra diferença é a existência do construtor padrão (sem argumentos). Este construtor é obrigatório. Tal construtor será empregado pelo _persistence provider_ para a criação de instâncias que forem recuperadas do SGBD. 

Para este simples exemplo, as poucas modificações comentadas acima são suficientes. 

Convém ressaltar que várias bibliotecas são necessárias para a compilação do código acima.  Várias bibliotecas também serão necessárias durante a execução. Para cada *import* fornecido acima, localize a biblioteca correspondente fornecida pelo Hibernate (_persistence provider_ empregado nestes exemplos). Naturalmente, se outro _persistence provider_ é fornecido, outra biblioteca será esperada em diretório distinto. 

=== Iniciar o SGBD ===
É preciso ter um SGBD disponível para persistir objetos. Neste caso é empregado o HSQLDB. Para iniciá-lo, na linha de comandos, execute 

{{{
ant db-start
}}}

Este comando deve ser executado do diretório onde se encontra o arquivo *build.xml*. Este arquivo é fornecido juntamente com todos os demais necessários para a execução deste exemplo no link fornecido no início desta página.

Não há nenhum passo de mágica. Embora o HSQLDB seja simples, várias operações estão encapsuladas no comando acima. Caso empregue outro SGBD, lembre-se de que, além de simplesmente iniciar o SGBD, uma base de dados terá que ser criada, um usuário com a devida permissão e eventualmente outras operações. Administração de um SGBD, contudo, está bem além do escopo deste exemplo. 

=== Criar o esquema no SGBD ===
Novamente será empregada a ferramenta Ant e a configuração fornecida no arquivo *build.xml*. O comando a ser executado é

{{{
ant schema
}}}

Isto criará o esquema obtido do mapeamento anteriormente realizado. Após esta operação, o esquema encontra-se disponível no SGBD (na base também criada no passo anterior). O comando acima, portanto, encapsula duas operações principais: a definição do esquema a partir do mapeamento realizado e, posteriormente, a criação deste esquema na base de dados criada no SGBD. Novamente, há muitos detalhes omitidos, mas que não comprometem o entendimento do processo. 

Você poderá verificar se esta operação foi realizada satisfatoriamente por meio de um cliente do SGBD. Para tal, neste exemplo, basta executar o comando abaixo

{{{
ant db-client
}}}

Este comando iniciará o cliente padrão do HSQLDB já para a base também criada. Em um outro SGBD, após iniciar o cliente, será necessário localizar a base de interesse e efetuar a conexão correspondente, onde provavelmente será requisitado um usuário devidamente autorizado. Novamente, todas estas ações foram realizadas pelo comando acima, embora afastadas da visão do usuário. 

=== Criar e executar um programa que requisita a persistência de instância da classe mapeada ===

O programa abaixo faz uso da JPA API. É por meio desta API que aplicações em Java se comunicam com o _persistence provider_ para requisitar, explicitamente, a criação, recuperação, remoção e outros serviços. 

{{{
package um;

import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.EntityTransaction;
import javax.persistence.Persistence;

public class PessoaAplicacaoJpa {
    public static void main(String[] args) {
	EntityManagerFactory emf = Persistence.createEntityManagerFactory("jpaUm");
	EntityManager em = emf.createEntityManager();
	EntityTransaction tx = em.getTransaction();
	tx.begin();
		
	Pessoa p = new Pessoa("Pedro Silva Souza da Silva");
		
	em.persist(p);
	tx.commit();
	em.close();
    }
}

}}}

No exemplo acima é fornecido o mínimo para requisitar o acesso a um gerenciador de entidades e a criação de uma transação no interior da qual uma instância de Pessoa é persistida. 

Após executar o programa acima, verifique no SGBD (por meio de um cliente), a existência de um registro correspondente à instância persistida. 

Caso execute o programa acima de um ambiente como o Eclipse, certifique-se de acrescentar ao classpath do comando de execução o diretório *etc*. É neste diretório que a unidade de persistência *jpaUm* está definida. Lembre-se que esta configuração é fornecida pelo arquivo *persistence.xml*, fornecido no diretório *META-INF*. É o diretório *META-INF* que deve estar no classpath para a execução satisfatória. Neste caso, o classpath deverá conter o diretório *etc*. 

= Considerações finais = 
O exemplo acima é simples. O objetivo é fornecer uma visão geral do processo envolvido no emprego de JPA. 