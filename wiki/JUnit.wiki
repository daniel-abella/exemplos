Introdução ao JUnit 4

= Introdução =

Em _Pragmatica Unit Testing: In Java with JUnit_, Andrew Hunt e David Thomas definem teste de unidade como "código escrito por um desenvolvedor que exercita um trecho de código pequeno e de uma área específica da funcionalidade do código que está sendo testado". Eles ainda acrescentam que testes de unidade são desenvolvidos para provar que um trecho de código faz o que o desenvolvedor imagina que deveria fazer.

Nesta breve introdução são fornecidos os passos básicos para uso do JUnit para a confecção de testes de unidade (em Java). 

= Onde obter? =
Em http://www.junit.org você poderá obter a versão mais recente, assim como tutoriais acerca do emprego do JUnit. No momento em que este texto é escrito, a versão mais recente é a versão 4.4, fornecido pelo arquivo *junit4.4.zip*.

= Instalação =
Obtenha o arquivo *junit4.4.zip* ou versão mais recente no endereço fornecido acima. Descomprima este arquivo. Será criado o diretório *junit4.4*. Neste diretório criado encontra-se o arquivo *junit-4.4.jar*. Este arquivo *.jar* é empregado tanto para compilar quanto para executar testes de unidade usando o JUnit.  

= Primeiro exemplo =
Abaixo segue uma classe trivial contendo uma única propriedade e três (3) métodos públicos. O método {{{adiciona(int valor)}}} deve acrescentar ao valor da instância aquele fornecido como argumento.

{{{
public class Valor {
    private int valor;

    public int getValor() {
        return valor;
    }

    public void setValor(int valor) {
        this.valor = valor;
    }
	
    public void adiciona(int valor) {
        this.valor += valor;
    }
}
}}}

O teste que verifica se o método {{{adiciona(int valor)}}} faz o que deveria estar fazendo é fornecido abaixo. Neste código há duas sentenças {{{import}}}. A primeira permite o uso da chamada {{{assertEquals}}} no corpo do método de teste ({{{testAdiciona()}}}. A outra sentença importa declara a anotação {{{Test}}}. É o emprego desta anotação que identifica, na classe {{{ValorTest}}}, os métodos que executam os testes de unidade. Neste caso apenas o método {{{testAdiciona()}}}.

{{{
import static org.junit.Assert.*;
import org.junit.Test;

public class ValorTest {

    @Test
    public void testAdiciona() {
        Valor v1 = new Valor();
	v1.setValor(1);
	assertEquals(3,v1.adiciona(2).getValor());
    }
}
}}}

O método {{{assertEquals(int,int)}}} empregado apenas verifica se o valor esperado {{{3}}} é aquele retornado pela operação {{{v1.adiciona(2).getValor()}}}. Todos os métodos de teste devem possuir esta assinatura, ou seja, devem ser públicos, retornar {{{void}}} e não recebem nenhum valor como argumento. Naturalmente, a classe {{{ValorTest}}} pode possuir muitos outros métodos sem estas restrições.

Abaixo segue apenas um trecho do código fornecido acima. Isto é feito para permitir que alguns itens sejam discutidos em detalhes.

{{{
@Test
public void testAdiciona() {
    Valor v1 = new Valor();
    v1.setValor(1);
    Valor v2 = new Valor();
    v2.setValor(2);
    assertEquals(3,v1.getValor() + v2.getValor());
}
}}}

O trecho acima inicia-se com {{{@Test}}}. Isto indica que o método que segue é um teste de unidade, qualquer que seja o nome do método. Contudo, deve ser público, retorna {{{void}}} e não recebe nenhum valor como argumento. É o conteúdo deste método que exercita o código a ser testado e, adicionalmente, verifica se o resultado obtido é o esperado. No exemplo acima, duas instâncias de {{{Valor}}} são criadas, respectivamente com o valor {{{1}}} e {{{2}}}. Em conseqüência, é esperado que a soma destes dois valores resulte em {{{3}}}, conforme o método {{{assertEquals}}}. Não faz muito sentido a execução do teste acima. Contudo, o teste do método {{{adiciona(int valor}}} já é representativa de casos típicos.

{{{
@Test
public void testAdicionaNulo() {
    Valor v = new Valor();
    assertEquals(0, v.adiciona(0));
}
}}}

Embora ainda muito simples, o teste acima verifica se a adição de zero a uma instância de {{{Valor}}}, recém-criada, produz como resultado o valor {{{0}}}.

Até agora simplemente criamos os testes, mas não foi mostrado como testá-los. O que é feito a seguir.

= Como executar os testes? =
Será necessário compilar a classe {{{Valor}}} e a classe {{{ValorTest}}}. Notou o sufixo {{{Test}}}? Não é necessário, mas uma convenção simples que pode facilitar a localização de classes de teste. Assumindo que os arquivos {{{Valor.java}}} e {{{ValorTest.java}}} estão disponíveis no diretório corrente, então o comando abaixo é suficiente para compilar tais classes.

{{{
javac *.java
}}}

Para executar os testes é necessário executar o comando seguinte

{{{
java org.junit.runner.JUnitCore basico.ValorTest
}}}

O comando acima requisita que a máquina virtual Java execute a classe {{{org.junit.runner.JUnitCore}}} com o argumento {{{basico.ValorTest}}}. Este argumento é o nome da classe que contém um ou mais testes de unidade. 

*OBSERVAÇÃO:* tanto a execução do compilador quanto da máquina virtual Java, conforme os comandos acima, só irá funcionar caso a variável *CLASSPATH* inclua o arquivo *junit-4.4.jar*. Se este não for o caso, também é possível fornecer o arquivo como argumento da opção *-cp*, conforme abaixo, assumindo que *junit-4.4.jar* está disponível no diretório *dir*.

Para compilar:
{{{
javac -cp dir/junit-4.4.jar:. *.java
}}}

Para executar:
{{{
java -cp dir/junit-4.4.jar:.. org.junit.runner.JUnitCore basico.ValorTest
}}}

Nos comandos acima, tanto o compilador irá tratar o arquivo *junit-4.4.jar* como parte do _classpath_, juntamente com o diretório corrente. 

= Considerações finais =
Este breve texto introduziu elementos básicos do desenvolvimento e execução de testes de unidade empregando a ferramenta JUnit. Vários outros recursos estão disponíveis, além daqueles apresentados acima. Consulte a documentação disponíveis tão logo esteja dominando  o conteúdo apresentado neste texto. 