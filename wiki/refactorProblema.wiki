Reorganização (Fábio Nogueira de Lucena)

= Introdução = 

A presente página e outras correspondentes foram elaboradas
sobre o conteúdo do capítulo 1 do livro _Refactoring: Improving the Design of
Existing Code_, Martin Fowler, Addion-Wesley, 1999. Isto significa que os
créditos do exemplo são do livro citado e ilustram a habilidade do
correspondente autor, Martin Fowler. *Tanto os modelos quanto o 
código, exceto quando dito o contrário, seguem as versões originais fornecidas no livro supracitado.* Há, contudo, várias diferenças.

Esta e demais páginas têm propósito similar ao do capítulo referenciado, ou
seja, introduzir o assunto _refactoring_ por meio de exemplos. Aqui é
empregado o termo _reorganização_ com a acepção de _refactoring_. A
alternativa ao texto aqui criada não tem o propósito de substituir a
anterior. Experiências com o ensino, contudo, revelam que algumas explanações
adicionais, aqui fornecidas, são relevantes para o entendimento, o que motiva
este texto e o torna único.

= O problema =

Software para calcular a "situação" de um cliente de uma vídeo locadora. Por
situação entenda quanto deve ser pago pelo cliente da vídeo locadora para um
conjunto de vídeos alugados, cada um deles por determinado período. O cálculo
também leva em consideração o tipo do vídeo e determina a quantidade de pontos
que o cliente recebe, o que depende do filme ser uma novidade ou não.

Abaixo segue o diagrama que ilustra este modelo. 

http://exemplos.googlecode.com/svn/tags/refactoring-v0/images/v0.png

A implementação inicial de cada uma destas classes também se encontra disponível: [http://exemplos.googlecode.com/svn/tags/refactoring-v0/src/Movie.java Movie.java], [http://exemplos.googlecode.com/svn/tags/refactoring-v0/src/Customer.java Customer.java] e [http://exemplos.googlecode.com/svn/tags/refactoring-v0/src/Rental.java Rental.java].

Conforme Martin Fowler descreve, o código fornecido por estas classes certamente não é orientado a objeto e, convém ressaltar, não há nenhum problema com ele dado que se trata de um _software_ de aplicação muito restrita. Contudo, se esta é uma parte representativa de um sistema, então existem problemas reais com este código. 

Uma dificuldade com este código fica clara com o contexto onde os clientes desejam, por exemplo, que a situação de um cliente também seja fornecida em HTML (*mudança 1*). Percebe-se que, conforme está, haverá significativa duplicação de código para simplesmente transformar a sentença corrente em uma versão HTML correspondente. Neste caso, observe que, quando uma mudança ocorrer na estratégia de comercialização, teremos que efetuar mudanças correspondentes em mais de um único local. 

Uma outra mudança (*mudança 2*) é alterar a forma de classificação dos filmes. Clientes ainda não possuem claramente o que deverá ser alterado, mas já se sabe que teremos alteração na forma em que os filmes serão classificados.

Estas duas mudanças irão repercutir no método {{{statement()}}}. Antes das mudanças, contudo, é preciso dispor de testes de unidade, para assegurar que mudanças não introduziram erros. 

A página de [refactorTestes testes] introduz os testes de unidade.

= Primeira mudança =
O método {{{statement()}}} é muito longo, conseqüência das várias atividades que desempenha. Dividi-lo, portanto, não é um começo ruim. Não é difícil perceber que o {{{switch}}} é um candidato forte e será este o principal corpo do método a ser criado {{{amountFor()}}}. Veja o resultado desta alteração em [http://exemplos.googlecode.com/svn/tags/refactoring-v1/src/Customer.java Customer.java].