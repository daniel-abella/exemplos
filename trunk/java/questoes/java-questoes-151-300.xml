<?xml version="1.0" encoding="UTF-8"?>
<!-- edited with XMLSPY v5 U (http://www.xmlspy.com) by raquel (ufg) -->
<?xml-stylesheet type="text/xsl" href="questoes.xsl"?>
<Avaliacao xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="questoes.xsd">
	<identificacao>
		<titulo>Linguagem de Programação Java</titulo>
		<copyright>Fábio Nogueira de Lucena</copyright>
		<versao>1.0</versao>
	</identificacao>
	<historico>
		<evento data="2003-10-07">
			<comentario>Atingido o total de 2071 questões!</comentario>
		</evento>
		<evento data="2003-09-01">
			<comentario>Atingida a marca de 1540 questões em Java.</comentario>
		</evento>
		<evento data="2003-08-09">
			<comentario>Ultrapassado o total de 1000 questões em Java.
                Há motivo para comemorar!</comentario>
		</evento>
		<evento data="2003-07-22">
			<pagina>55</pagina>
			<comentario>Várias mudanças pequenas foram efetuadas no
                esquema: questoes.xsd. Trabalho futuro deverá contemplar
                o emprego de links para figuras, por exemplo, para
                ilustrar código em Java e diagramas UML associados a uma questão.</comentario>
		</evento>
		<evento data="2003-07-16">
			<comentario>Criação do arquivo XSLT para geração de HTML a
                partir de um arquivo de base de questões. Também foi
                utilizado um processador FOP para geração de arquivo PDF
                correspondente. Alguns pequenos ajustes foram feitos no
                Schema do arquiv XML.</comentario>
		</evento>
		<evento data="2003-07-15">
			<pagina>42</pagina>
		</evento>
		<evento data="2003-07-07">
			<pagina>35</pagina>
			<comentario>Primeiras questões pós a definição parcial do
                Schema para as questões.</comentario>
		</evento>
		<evento data="2003-07-06">
			<comentario>Criação do XML Schema para questões. Versão Inicial.</comentario>
		</evento>
		<evento data="2003-07-05">
			<pagina>28</pagina>
			<comentario/>
		</evento>
		<evento data="2003-06-09">
			<pagina>23</pagina>
		</evento>
		<evento data="2003-06-08">
			<pagina>20</pagina>
		</evento>
		<evento data="2003-06-02">
			<pagina>14</pagina>
		</evento>
		<evento data="2003-06-01">
			<pagina>8</pagina>
		</evento>
		<evento data="2003-05-31">
			<pagina>1</pagina>
			<comentario>Criação do arquivo</comentario>
		</evento>
	</historico>
	<questao id="151" qi="1" tipo="lógica" objetivo="4.6">
		<introducao>Uma literal ponto-flutuante é do tipo double se não
            possui o sufixo ASCII f ou F.</introducao>
		<resposta valor="v">É opcional vir com d ou D.</resposta>
	</questao>
	<questao id="152" qi="1" tipo="lógica" objetivo="4.6">
		<introducao>Uma literal ponto-flutuante é do tipo double se
            possui possui o sufixo ASCII d ou D.</introducao>
		<resposta valor="v">É opcional.</resposta>
	</questao>
	<questao id="153" qi="1" tipo="lógica" objetivo="4.6">
		<introducao>Um erro em tempo de compilação é gerado se uma
            literal ponto-flutuante é muito grande e não é um valor no
            conjunto daqueles permitidos para o tipo em questão.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="154" qi="1" tipo="lógica" objetivo="4.6">
		<introducao>Uma literal ponto-flutuante muito grande, quando
            convertida para uma representação interna, torna-se o valor
            infinito (IEEE 754).</introducao>
		<resposta valor="v">Quando o valor é resultado de um processamento em tempo de execução.</resposta>
	</questao>
	<questao id="155" qi="1" tipo="lógica" objetivo="4.6">
		<introducao>O valor infinito (IEEE 754) pode ser fornecido a uma
            variável ponto-flutuante, sem gerar um erro em tempo de
            compilação ou execução, através das expressões constantes
            como 1f/0f ou -1d/0d.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="156" qi="1" tipo="lógica" objetivo="4.6">
		<introducao>O valor infinito (IEEE 754) pode ser introduzido em
            uma variável através das constantes pré-definidas
            POSITIVE_INFINITY e NEGATIVE_INFINITY. Estas constantes
            estão pré-definidas nas classes Float e Double.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="157" qi="1" tipo="lógica" objetivo="4.6">
		<introducao>A constante que não representa um número
            (Not-a-Number), conforme IEEE 754, é definida nas classes
            <stmt>Float</stmt> e <stmt>Double</stmt> pelas constantes
            pré-definidas <stmt>Float.NaN</stmt> e <stmt>Double.NaN</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="158" qi="1" tipo="lógica" objetivo="4.6">
		<introducao>São literais, 1e1f  e 2.f, ambas do tipo <stmt>float</stmt>.</introducao>
		<resposta valor="v">Para ser uma literal do tipo ponto-flutuante tem que ter um ponto decimal(.), um expoente(e) ou sufixo.</resposta>
	</questao>
	<questao id="159" qi="1" tipo="lógica" objetivo="4.6">
		<introducao>São literais, .3 e 2., ambas do tipo <stmt>double</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="160" qi="1" tipo="lógica" objetivo="4.6">
		<introducao>Exemplos de literais ponto-flutuante incluem: 1e1, 0
            e 1e1d.</introducao>
		<resposta valor="f">0 não é ponto-flutuante.</resposta>
	</questao>
	<questao id="161" qi="1" tipo="lógica" objetivo="4.6">
		<introducao>Literais ponto-flutuante podem ser expressas em
            bases diferentes da base decimal.</introducao>
		<resposta valor="f"> Usando o método IntBitsToFloat da classe float e o método LongBitsToDouble pode se expressar valores de ponto flutuante em termos de hexadecimal ou octal.</resposta>
	</questao>
	<questao id="162" qi="1" tipo="lógica" objetivo="4.6">
		<introducao>São literais ponto-flutuante, 0xFFD e 2.d, ambas do
            tipo double.<stmt>double</stmt>.</introducao>
		<resposta valor="f">0xFFD é inteiro.</resposta>
	</questao>
	<questao id="163" qi="1" tipo="lógica" objetivo="4.6">
		<introducao>São literais ponto-flutuante, 0777D e .2d, ambas do
            tipo <stmt>double</stmt>.</introducao>
		<resposta valor="f">0777D é inteiro.</resposta>
	</questao>
	<questao id="164" qi="1" tipo="lógica" objetivo="4.6">
		<introducao>Todas as literais do tipo <stmt>boolean</stmt>
            resumem-se em <stmt>true</stmt> e <stmt>false</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="165" qi="1" tipo="lógica" objetivo="4.6">
		<introducao>A literal <stmt>boolean </stmt>
			<stmt>false</stmt> do tipo boolean equivale a qualquer valor inteiro
            diferente de zero.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="166" qi="1" tipo="lógica" objetivo="4.6">
		<introducao>A literal <stmt>true</stmt> do tipo boolean equivale a qualquer valor inteiro
            diferente de zero.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="167" qi="1" tipo="lógica" objetivo="4.6">
		<introducao>A literal <stmt>false</stmt> 
			do tipo boolean equivale ao valor inteiro 0.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="168" qi="1" tipo="lógica" objetivo="4.6">
		<introducao>Uma literal caractere (character) é expressa como um
            caractere ou através de uma escape sequence, entre aspas
            simples ASCII.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="169" qi="1" tipo="lógica" objetivo="4.6">
		<introducao>É um erro gerado em tempo de compilação encontrar um
            fim de linha após uma aspas simples e antes da aspas simples
            que define um caractere.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="170" qi="1" tipo="lógica" objetivo="4.6">
		<introducao>Exemplos de caracteres incluem: 'a', '\t', '\'',
            '\uFFFF', '@'.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="171" qi="1" tipo="lógica" objetivo="4.6">
		<introducao>Nao é correto fazer uso da literal '\u000a' porque
            uma das primeiras análises realizadas em um código fonte em
            Java irá converter tal caractere em 'LF' (fim de linha) e,
            portanto, '\u000a' não é uma literal válida.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="172" qi="1" tipo="lógica" objetivo="4.6">
		<introducao>
			<stmt>String</stmt>s em Java possuem valores constantes, ou
            seja, não podem ser alterados.</introducao>
		<resposta valor="v">Quando modifica o valor da string, cria-se uma nova instância.</resposta>
	</questao>
	<questao id="173" qi="1" tipo="lógica" objetivo="4.6">
		<introducao>Uma literal <stmt>String</stmt> consiste de um ou
            mais caracteres delimitados por aspas duplas.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="174" qi="1" tipo="lógica" objetivo="4.6">
		<introducao>Uma literal <stmt>String</stmt> é sempre do tipo <stmt>String</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="175" qi="1" tipo="lógica" objetivo="4.6">
		<introducao>Exemplos de literais <stmt>String</stmt>s incluem:
            &quot;&quot;, &quot;\&quot;&quot;, &quot;A vida é
            bela&quot;, &quot;O &quot; + &quot;melhor&quot; + &quot;
            jogador é Pelé&quot;.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="176" qi="1" tipo="lógica" objetivo="4.6">
		<introducao>Toda literal <stmt>String</stmt> é uma referência
            para uma instância da classe <stmt>String</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="177" qi="1" tipo="lógica" objetivo="4.6">
		<introducao>Objetos <stmt>String</stmt> possuem valores
            constantes, que não podem ser alterados.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="178" qi="1" tipo="lógica" objetivo="4.6">
		<introducao>Para que objetos <stmt>String</stmt> possam
            compartilhar instâncias de literais <stmt>String</stmt>, o
            método 'intern' deve ser empregado.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="179" qi="1" tipo="lógica" objetivo="4.6">
		<introducao>Literais <stmt>String</stmt> em uma mesma classe
            representam referências para o mesmo objeto <stmt>String</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="180" qi="1" tipo="lógica" objetivo="4.6">
		<introducao>Literais <stmt>String</stmt> em classes distintas em
            um mesmo package representam referências para o mesmo objeto <stmt>String</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="181" qi="1" tipo="lógica" objetivo="4.6">
		<introducao>Literais <stmt>String</stmt> em classes distintas de
            packages distintos representam referências para o mesmo
            objeto <stmt>String</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="182" qi="1" tipo="lógica" objetivo="4.6">
		<introducao>
			<stmt>String</stmt>s obtidas de expressões constantes
            obtidas em tempo de compilação são tratadas como se fossem literais.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="183" qi="1" tipo="lógica" objetivo="4.6">
		<introducao>Objetos <stmt>String</stmt> criados em tempo de
            execução são distintos, mesmo que as literais associadas a
            estes sejam as mesmas.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="184" qi="1" tipo="lógica" objetivo="4.6">
		<introducao>O resultado de internalizar (intern) um objeto
            <stmt>String</stmt> dá origem a um objeto
            <stmt>String</stmt> que é o mesmo de uma literal
            <stmt>String</stmt> pré-existente com o mesmo conteúdo.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="185" qi="1" tipo="lógica" objetivo="4.6">
		<introducao>Sabendo-se que o valor UNICODE \u0009 equivale a
            sequence escape \t, pode-se afirmar que as literais
            &quot;tab\t\ttab&quot; e &quot;tab\u0009\u0009tab&quot;
            produzem o mesmo efeito quando enviadas para a saída padrão
            através de System.out.println.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="186" qi="1" tipo="lógica" objetivo="4.6">
		<introducao>Sabendo-se que o valor UNICODE \u0027 equivale a
            sequence escape \', aspas simples, e \u0022 às aspas duplas,
            pode-se afirmar que \u0027\u0022\u0027 representa o
            caractere &quot;.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="187" qi="1" tipo="lógica" objetivo="4.6">
		<introducao>A linguagem Java é um exemplo de linguagem strongly
            typed. Noutras palavras, todas as variáveis e expressões
            possuem um tipo que é conhecido em tempo de compilação.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="188" qi="1" tipo="lógica" objetivo="4.6">
		<introducao>Há duas categorias de tipos em Java: tipos
            primitivos e tipos de referência.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="189" qi="1" tipo="lógica" objetivo="4.6">
		<introducao>Os tipos primitivos de Java incluem o tipo
            <stmt>boolean</stmt> e os tipos numéricos. Estes últimos
            incluem: byte, short, int, long e char, além dos tipos em
            ponto-flutuante float e double.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="190" qi="1" tipo="lógico" objetivo="4.6">
		<introducao>Os tipos referência em Java são os tipos de classes,
            tipos de interfaces e os tipos de <stmt>array</stmt>s.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="191" qi="1" tipo="lógica" objetivo="4.6">
		<introducao>Em Java, <stmt>null</stmt> é um tipo especial, o
            tipo <stmt>null</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="192" qi="1" tipo="lógica" objetivo="6.3">
		<introducao>Um objeto, em Java, é uma instância criada
            dinamicamente de um tipo de classe ou <stmt>array</stmt>
            criado dinamicamente.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="193" qi="1" tipo="lógico" objetivo="4.6">
		<introducao>Os valores dos tipos referência são referências para objetos.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="194" qi="1" tipo="lógica" objetivo="6.1">
		<introducao>Todos os objetos em Java, inclusive os
            <stmt>array</stmt>s, oferecem suporte aos métodos da classe <stmt>Object</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="195" qi="1" tipo="lógica" objetivo="4.1">
		<introducao>Uma variavel representa um local de armazenamento de informação.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="196" qi="1" tipo="lógico" objetivo="4.1">
		<introducao>Uma variável de um tipo primitivo sempre armazena um
            valor deste tipo.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="197" qi="1" tipo="lógico" objetivo="6.1">
		<introducao>Uma variável de um tipo de classe T pode reter
            apenas uma referência <stmt>null</stmt> ou uma referência
            para uma instância da classe de T.</introducao>
		<resposta valor="f">Observe que pode também reter uma
            referência para uma subclasse de T.</resposta>
	</questao>
	<questao id="198" qi="1" tipo="lógico" objetivo="6.1">
		<introducao>A variável de um tipo interface pode reter apenas
            uma referência para qualquer instância de qualquer classe
            que implementa a interface.</introducao>
		<resposta valor="f">Pode reter também a referência <stmt>null</stmt>.</resposta>
	</questao>
	<questao id="199" qi="1" tipo="lógico" objetivo="4.1">
		<introducao>Se T é um tipo primitivo, então uma variável do tipo
            &quot;<stmt>array</stmt> de T&quot; pode reter uma
            referência <stmt>null</stmt> ou uma referência para qualquer
            <stmt>array</stmt> do tipo &quot;<stmt>array</stmt> de T&quot;.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="200" qi="1" tipo="lógico" objetivo="6.1">
		<introducao>Se T é um tipo de referência, então uma variável do
            tipo &quot;<stmt>array</stmt> de T&quot; pode reter a
            referência <stmt>null</stmt> ou uma referência para qualquer
            <stmt>array</stmt> do tipo &quot;<stmt>array</stmt> de
            S&quot; onde uma variável do tipo S pode ter seu valor
            atribuído a uma variável do tipo T.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="201" qi="1" tipo="lógico" objetivo="5.1">
		<introducao>Uma variável do tipo <stmt>Object</stmt> pode reter
            a referência <stmt>null</stmt> ou uma referência para
            qualquer objeto, seja uma instância de classe ou <stmt>array</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="202" qi="1" tipo="lógico" objetivo="4.6">
		<introducao>Há dois tipos de &quot;tipos&quot; em Java: os tipos
            primitivos e os tipos de referência.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="203" qi="1" tipo="lógico" objetivo="4.6">
		<introducao>Há dois tipos de valores que podem ser armazenados
            em variáveis da linguagem de programação Java: os valores
            primitivos, correspondentes aos tipos primitivos e os
            valores de referência, correspondentes aos tipos de referência.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="204" qi="1" tipo="lógico" objetivo="4.6">
		<introducao>Em Java, <stmt>null</stmt> é um tipo especial, que
            não possui nome e que representa o tipo de expressões
            <stmt>null</stmt>. Embora considerada um tipo, não é
            possível criar uma variável do tipo <stmt>null</stmt> ou
            realizar uma operação de conversão (cast) com o tipo
            <stmt>null</stmt>, por exemplo.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="205" qi="1" tipo="lógico" objetivo="4.6">
		<introducao>A referência <stmt>null</stmt> sempre pode ser
            convertida (cast) para qualquer tipo de referência. Embora
            considerada um tipo, pode-se tratar <stmt>null</stmt> como
            uma simples literal especial que pode ser de qualquer tipo
            de referência.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="206" qi="1" tipo="lógico" objetivo="4.6">
		<introducao>O valor de um variável de um tipo primitivo só pode
            ser alterado por uma operação de atribuição naquela variável.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="207" qi="1" tipo="lógico" objetivo="4.6">
		<introducao>Os tipos ditos inteiros são byte, short, int e long
            que, respectivamente representam valores de 8 bits, 16 bits,
            32 bits e 64 bits com sinal usando a notação de complemento
            de dois. O tipo char também é considerado um tipo inteiro e
            seus valores são de 16 bits. Ao contrário dos anteriores,
            contudo, estes valores representam caracteres UNICODE e são
            todos sem sinal.</introducao>
		<resposta valor="v">Uma variável char pode armazenar uma única letra minúscula, uma única letra maiúscula, um único dígito ou um único caracter especial como X, $, 7, * e seqüência de escape.</resposta>
	</questao>
	<questao id="208" qi="1" tipo="lógico" objetivo="4.6">
		<introducao>O tipo <stmt>boolean</stmt> é, entre os tipos
            primitivos, aquele cujo domínio de valores é menor. Apenas
            dois valores existem para variáveis do tipo
            <stmt>boolean</stmt>: verdadeiro e falso, que são
            representados, respectivamente, pelas literais
            <stmt>true</stmt> e <stmt>false</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="209" qi="1" tipo="lógico" objetivo="4.6">
		<introducao>Os tipos primitivos em ponto-flutuamente incluem
            float e double, respectivamente valores de 32 e 64 bits
            conforme a especificação IEEE 754.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="210" qi="1" tipo="lógico" objetivo="5.1">
		<introducao>Os operadores de comparação, &lt;, &lt;=, > e >=,
            quando aplicados a valores inteiros produzem como resultado
            um valor do tipo <stmt>boolean</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="211" qi="1" tipo="lógico" objetivo="5.1">
		<introducao>Os operadores numéricos, quando aplicados a
            operandos do tipo inteiro, resultam em valor do tipo
            <stmt>int</stmt> ou <stmt>long</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="212" qi="1" tipo="lógico" objetivo="5.1">
		<introducao>O + e o - unários são operadores numéricos.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="213" qi="1" tipo="lógico" objetivo="5.1">
		<introducao>O +, -, *, / e % são operadores numéricos.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="214" qi="1" tipo="lógico" objetivo="5.1">
		<introducao>São operadores numéricos: ++ e --, ambos prefixados
            e pós-fixados.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="215" qi="1" tipo="lógico" objetivo="5.1">
		<introducao>Os operadores de deslocamento com e sem sinal são
            operadores numéricos: &lt;&lt;, >> e >>>.</introducao>
		<resposta valor="v">O primeiro operador gera deslocamento para direita com sinal e o operador >>> gera deslocamento para direira sem sinal. </resposta>
	</questao>
	<questao id="216" qi="1" tipo="lógico" objetivo="5.1">
		<introducao>O operador ~ representa o complemento bit a bit
            (bitwise) além de exemplo de operador numérico.</introducao>
		<resposta valor="v">~4 é igual a: (-4)-1 = -5.</resposta>
	</questao>
	<questao id="217" qi="1" tipo="lógico" objetivo="5.1">
		<introducao>Os operadores bit a bit (bitwise) &amp;, | e ^ são
            ditos numéricos e representam operações bit a bit</introducao>
		<resposta valor="v">Para &amp; o valor do resultado é verdade se ambos operadores forem verdadeiros. Para o operador | o resultado é falso se ambos os operadores forem falsos e para o operador ^ o resultado é verdadeiro se os operandos forem diferentes. </resposta>
	</questao>
	<questao id="218" qi="1" tipo="lógico" objetivo="5.1">
		<introducao>O operador condicional ? : é considerado um operador numérico.</introducao>
		<resposta valor="v">É o único operador ternário em Java e ele tem três operandos. </resposta>
	</questao>
	<questao id="219" qi="1" tipo="lógico" objetivo="5.1">
		<introducao>O operador de conversão (cast) pode converter um
            valor inteiro em qualquer valor numérico.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="220" qi="1" tipo="lógico" objetivo="5.1">
		<introducao>O operador + quando envolver uma <stmt>String</stmt>
            e um operando inteiro, converterá o operando inteiro em uma
            <stmt>String</stmt> que representa o valor na forma decimal
            e então produzirá uma nova <stmt>String</stmt> que é a
            concatenação da <stmt>String</stmt> existente com aquela
            criada pela conversão.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="221" qi="1" tipo="lógico" objetivo="5.1">
		<introducao>Se um operador inteiro que não seja o operador de
            deslocamento tenha pelo menos um operando do tipo long,
            então a operação será realizada utilizando-se uma precisão
            de 64 bits e o resultado do operador é do tipo long.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="222" qi="1" tipo="lógico" objetivo="5.1">
		<introducao>Se um dos operandos de um operador numérico é long e
            o outro não é do tipo primitivo ponto flutuante, entao o operando que não é do tipo long é
            expandido (promovido) para um valor do tipo long antes que a
            operação seja realizada.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="223" qi="1" tipo="lógico" objetivo="5.1">
		<introducao>Se nenhum dos operandos de um operador numérico é do
            tipo long, então a operação é realizada empregando-se um
            precisão de 32 bits e o resultado do operador numérico é do
            tipo int. Neste caso, o operando que não for do tipo int tem
            seu valor promovido para um do tipo int.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="224" qi="1" tipo="lógico" objetivo="2.4">
		<introducao>Os operadores inteiros não geram exceção que
            represente overflow.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="225" qi="1" tipo="lógico" objetivo="2.4">
		<introducao>Os operadores inteiros não gera exceção que
            represente underflow.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="226" qi="1" tipo="lógico" objetivo="2.4">
		<introducao>Os únicos operadores numéricos que geram exceção são
            os operadores inteiros / e % quando o operando da direita é
            zero. Nestes casos, a exceção ArithmeticException é gerada.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="227" qi="1" tipo="lógico" objetivo="5.1">
		<introducao>Qualquer valor de um tipo inteiro pode ser
            convertido (cast) para outro de qualquer tipo numérico.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="228" qi="1" tipo="lógico" objetivo="5.1">
		<introducao>Não existe nenhum tipo de conversão entre os tipos
            inteiros e o tipo <stmt>boolean</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="229" qi="1" tipo="lógico" objetivo="11">
		<introducao>Uma máquina virtual é um software que executa
            código. Em particular, a máquina virtual Java, ou JVM,
            executa código escrito em <it>bytecode</it>s, geralmente
            obtido através da compilação de código fonte em Java.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="230" qi="1" tipo="lógico" objetivo="10">
		<introducao>Pode-se afirmar que a programação dita procedural
            enfatiza a ordenação temporal (seqüencia) de passos
            executados pelo código, ao passo que a programação orientada
            a objetos orienta-se para a criação de objetos que trocam
            mensagens entre eles.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="231" qi="1" tipo="lógico" objetivo="3.1">
		<introducao>Objetos que não mais possuem referências para eles
            podem ser removidos da memória automaticamente pelo garbage collector.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="232" qi="1" tipo="lógico" objetivo="11">
		<introducao>A máquina virtual Java executa código em Java.</introducao>
		<resposta valor="f">Uma JVM executa código em
            <it>bytecode</it>s, obtidos através do processo de
            compilação de código fonte em Java.</resposta>
	</questao>
	<questao id="233" qi="1" tipo="lógico" objetivo="12">
		<introducao>Um applet reside em um servidor Web. A execução de
            um applet, por outro lado, ocorre em um cliente, que executa
            um browser, através do qual provavelmente ocorreu o download
            do applet.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="234" qi="1" tipo="lógico" objetivo="11">
		<introducao>A linguagem de programação Java é dita
            &quot;independente de plataforma&quot; porque permite a
            criação de programas que podem ser executados em várias plataformas.</introducao>
		<resposta valor="v">Um programa escrito em Java pode
            ser executado em várias plataformas. A rigor, tantas quantas
            forem as implementações disponíveis do ambiente de execução Java.</resposta>
	</questao>
	<questao id="235" qi="1" tipo="lógico" objetivo="10">
		<introducao>Pode-se dizer que Java baseia-se, em parte, nas
            construções da linguagem de programação C++.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="236" qi="1" tipo="lógico" objetivo="6.1">
		<introducao>Toda classe que se escreve em Java possui uma superclasse.</introducao>
		<resposta valor="v">Observe que toda classe em Java é
            descendente da classe <stmt>Object</stmt>.</resposta>
	</questao>
	<questao id="237" qi="1" tipo="lógico" objetivo="4.6">
		<introducao>O atributo de um objeto pode ser uma referência para
            outro objeto ou para o próprio objeto que contém o atributo.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="238" qi="1" tipo="lógico" objetivo="1.2">
		<introducao>Um objeto é uma instância de uma classe.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="239" qi="1" tipo="lógico" objetivo="4.1">
		<introducao>A linguagem de programação Java é dita &quot;case
            sensitive&quot;, ou seja, uma linguagem cujos
            identificadores consideram a existência de letras maiúsculas
            e minúsculas como letras distintas. Por exemplo, os
            identificadores &quot;A&quot; e &quot;a&quot; são
            identificadores distintos, da mesma forma que
            &quot;soldo&quot; e &quot;Soldo&quot;.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="240" qi="1" tipo="lógico" objetivo="1.2">
		<introducao>Em Java, se uma classe pública é definida, então
            esta classe deve estar descrita em um arquivo cujo nome é
            formado pelo identificador desta classe pública com a
            extensão &quot;.java&quot;.</introducao>
		<resposta valor="v">As definições de classe que iniciam com a palavra-chave public devem ser armazenadas em um arquivo que tem exatamente o mesmo nome que a classe e termina com a extensão .java. Em cada arquivo só pode existir uma única public class.</resposta>
	</questao>
	<questao id="241" qi="1" tipo="lógico" objetivo="4.6">
		<introducao>Comentários em Java devem ser escritos sempre que se
            desejar que o código correspondente seja executado com mais eficiência.</introducao>
		<resposta valor="f">Comentários em Java são tratados pelo
            compilador como um espaço em branco e, portanto, não possuem
            nenhuma função semântica.</resposta>
	</questao>
	<questao id="242" qi="1" tipo="lógico" objetivo="4.1">
		<introducao>Todo programa em Java inicia-se por um método
            especial chamado main.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="243" qi="1" tipo="lógico" objetivo="4.1">
		<introducao>Uma sintaxe válida do método especial main é
            &quot;public static void main(<stmt>String</stmt> [] args)&quot;.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="244" qi="1" tipo="lógico" objetivo="4.1">
		<introducao>Uma sintaxe válida do método especial main é
            &quot;static public void main(<stmt>String</stmt> args[])&quot;.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="245" qi="1" tipo="lógico" objetivo="4.1">
		<introducao>Uma sintaxe válida do método especial main é
            &quot;static public void main(<stmt>String</stmt> []$i)&quot;.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="246" qi="1" tipo="lógico" objetivo="4.1">
		<introducao>Existem várias sintaxes válidas para o método
            especial main através do qual a JVM inicia a execução de um
            programa em Java. Apesar de alguma flexibilidade,
            necessariamente tal método deve possuir como identificador
            &quot;main&quot;; o retorno deve ser &quot;void&quot;; o
            argumento é um <stmt>array</stmt> de <stmt>String</stmt> e,
            por último, deve possuir dois modificadores:
            &quot;public&quot; e &quot;static&quot;.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="247" qi="1" tipo="lógico" objetivo="4.1">
		<introducao>Um único método especial main através do qual uma
            aplicação em Java é iniciada deve estar disponível em um programa.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="248" qi="1" tipo="lógico" objetivo="1.2">
		<introducao>Variáveis em Java são empregadas por vários motivos.
            Entre eles, reter um valor ou uma referência para um objeto,
            por exemplo.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="249" qi="1" tipo="lógico" objetivo="4.6">
		<introducao>Valores são armazenados, empregando-se a linguagem
            de programação Java, principalmente através do emprego de
            tipos primitivos. Existem oito tipos primitivos em Java:
            <stmt>byte</stmt>, <stmt>short</stmt>, <stmt>int</stmt>,
            <stmt>long</stmt>, <stmt>float</stmt>, <stmt>double</stmt>,
            <stmt>char</stmt> e <stmt>boolean</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="250" objetivo="4.6">
		<introducao>Valores são armazenados, empregando-se a linguagem
            de programação Java, principalmente através do emprego de
            tipos primitivos. Existem nove tipos primitivos em Java:
            <stmt>byte</stmt>, <stmt>short</stmt>, <stmt>int</stmt>,
            <stmt>long</stmt>, <stmt>float</stmt>, <stmt>double</stmt>,
            <stmt>char</stmt>, <stmt>boolean</stmt> e <stmt>void</stmt>.</introducao>
		<resposta valor="f">A palavra reservada &quot;void&quot; não
            é um tipo primitivo. Representa a ausência de valor.</resposta>
	</questao>
	<questao id="251" objetivo="4.6">
		<introducao>Todos os tipos primitivos de Java dão origem a
            variáveis que ocupam um número múltiplo de 8 bits.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="252" objetivo="4.1">
		<introducao>Variáveis em Java devem necessariamente ser
            declaradas antes de utilizadas.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="253" objetivo="4.1">
		<introducao>Variáveis locais (declaradas no interior de um
            método) devem necessariamente ser iniciadas explicitamente
            antes de utilizadas.</introducao>
		<resposta valor="v">As variáveis de instância são sempre iniciadas com um valor padrão (default), diferentes das variáveis locais que devem ser iniciadas explicitamente.</resposta>
	</questao>
	<questao id="254" objetivo="3.1">
		<introducao>Heap é uma área da memória usada para alocação
            dinâmica de memória por um programa. Em geral, blocos de
            memória de tamanhos desconhecidos em tempo de compilação,
            são alocados e liberados em tempo de execução em uma ordem arbitrária.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="255" objetivo="3.1">
		<introducao>
			<it>Stack</it> é uma área da memória usada para armazenar
            informações utilizadas por um &quot;curto&quot; período de
            tempo como as variáveis locais a um método.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="256" objetivo="2.4">
		<introducao>Em uma atribuição envolvendo duas variáveis de tipos
            distintos, onde há perda de precisão, o compilador
            simplesmente não compila o programa que contém a atribuição
            (um erro é gerado).</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="257" objetivo="4.1">
		<introducao>Em Java, os identificadores &quot;salário&quot; e
            &quot;salario&quot; são considerados iguais.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="258" objetivo="4.1">
		<introducao>Em Java, os identificadores &quot;Salario&quot; e
            &quot;salario&quot; são considerados iguais.</introducao>
		<resposta valor="f">Case sensitive.</resposta>
	</questao>
	<questao id="259" objetivo="5.1">
		<introducao>Após a execução da sentença &quot;int a = 0; int b =
            ++a;&quot;, o resultado da soma do valor de a com o valor de
            b é 1.</introducao>
		<resposta valor="f">O valor de a é incrementado de uma
            unidade, tornando-se 1, que é o valor atribuído a b e, dessa
            forma, a + b é igual a 2.</resposta>
	</questao>
	<questao id="260" objetivo="5.1">
		<introducao>Na sentença &quot;Se a ligação ocorre após 22h,
            então o preço é mais baixo. Se for iniciada antes das 22h ou
            às 22h00min a tarifa é normal&quot;, os operadores
            relacionais e lógicos envolvidos, respectivamente, são > e &lt;=.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="261" objetivo="5.2">
		<introducao>Deve-se usar o método &quot;equals&quot; para testar
            se as <stmt>String</stmt>s de duas referências são iguais. O
            operador == quando aplicado a referências, independente do
            tipo, retorna verdadeiro se e somente se as referências são
            de um mesmo objeto.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="262" objetivo="4.1">
		<introducao>Atributos públicos de um objeto não podem ser
            alterados por métodos privados deste objeto.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="263" objetivo="4.1">
		<introducao>Atributos privados de um objeto não podem ser
            alterados por métodos públicos de um objeto.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="264" objetivo="4.1">
		<introducao>O escopo de uma variável refere-se à região de um
            programa em que a variável é visível.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="265" objetivo="6.2">
		<introducao>Construtores podem ser sobrecarregados (<it>overloaded</it>).</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="266" objetivo="4.1">
		<introducao>Final e final são identificadores distintos em Java.</introducao>
		<resposta valor="f">A palavra "final" é palavra-chave e não pode ser usada como identificador.</resposta>
	</questao>
	<questao id="267" objetivo="4.1">
		<introducao>Identificadores em Java podem ser de no máximo 64
            bits (8 bytes).</introducao>
		<resposta valor="f">Identificadores não se confundem com os
            tipos das variáveis aos quais estes estão associados. Em
            Java, um identificador pode ser de tamanho arbitrário.</resposta>
	</questao>
	<questao id="268" objetivo="9.2">
		<introducao>Se uma classe X não sobrepõe (override) o método
            &quot;equals&quot;, então instâncias desta classe não podem
            ser utilizadas como chave em uma hashtable.</introducao>
		<resposta valor="v">Os métodos "equals" e "hasCode" são muitos úteis em <it>hashtables</it> tal como java.util.Hashtable.</resposta>
	</questao>
	<questao id="269" objetivo="4.6">
		<introducao>O padrão IEEE 754 inclui não apenas números
            positivos e negativos mas também um zero positivo, um zero
            negativo, um infinito positivo,um infinito negativo e
            valores especiais Not-a-Number (NaN).</introducao>
		<resposta valor="v">Os valores Not-a-Number são definidos nas classes Float e Double como Float.NaN e Double.NaN, e como constantes pré-definidas POSITIVE-INFINITY e NEGATIVE-INFINITY das classes Float e Double.</resposta>
	</questao>
	<questao id="270" objetivo="4.6">
		<introducao>O valor infinito positivo e o infinito negativo
            representam valores distintos.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="271" objetivo="4.6">
		<introducao>O valor zero positivo e o valor zero negativo
            representam um mesmo valor (zero).</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="272" objetivo="4.6">
		<introducao>Os valores em ponto flutuante estão ordenados, desde
            o menor até o maior. Excetua-se os valores NaN.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="273" objetivo="4.6">
		<introducao>Existe um maior valor em ponto flutuante do tipo <stmt>float </stmt>que é finito.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="274" objetivo="4.6">
		<introducao>Existe o valor em ponto flutuante do tipo <stmt>float </stmt>que representa o valor infinito positivo.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="275" objetivo="4.6">
		<introducao>Existe um menor valor positivo diferente de zero do
            tipo <stmt>float</stmt>. Este valor é representado pela constante Float.MIN_VALUE.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="276" objetivo="4.6">
		<introducao>O valor resultante de 1.0/0.0 representa o infinito positivo.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="277" objetivo="4.6">
		<introducao>O valor resultante de 1.0/-0.0 representa o infinito negativo.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="278" objetivo="5.1">
		<introducao>Os operadores numéricos de comparação &lt;, &lt;=, >
            e >= retornam falso se um ou ambos os operandos são NaN.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="279" objetivo="5.1">
		<introducao>A expressão lógica <stmt>Float.NaN ==
            Float.NaN</stmt> é verdadeira.</introducao>
		<resposta valor="f"> O operador (= =) retorna valor falso entre operandos NaN.</resposta>
	</questao>
	<questao id="280" objetivo="5.1">
		<introducao>A expressão lógica <stmt>Float.NaN >=
            Float.NaN</stmt> é verdadeira.</introducao>
		<resposta valor="f">Valores não definidos não se comparam.</resposta>
	</questao>
	<questao id="281" objetivo="5.1">
		<introducao>A expressão lógica <stmt>Float.NaN !=
            Float.NaN</stmt> é verdadeira.</introducao>
		<resposta valor="v">O operador (!=) retorna verdadeiro entre operandos NaN.</resposta>
	</questao>
	<questao id="282" objetivo="5.1">
		<introducao>O operador de desigualdade != retorna verdadeiro se
            um ou ambos os operandos é ou são NaN.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="283" objetivo="5.1">
		<introducao>A expressão x != x pode ser verdadeira, dependendo
            do valor armazenado em x.</introducao>
		<resposta valor="v">Se x contém um NaN, então a
            desigualdade é verdadeira.</resposta>
	</questao>
	<questao id="284" objetivo="5.1">
		<introducao>A expressão x == x pode ser falsa, dependendo do
            valor armazenado em x.</introducao>
		<resposta valor="v">Por exemplo, se o valor for NaN.</resposta>
	</questao>
	<questao id="285" objetivo="5.1">
		<introducao>Se pelo menos um dos operandos de um operador
            binário é do tipo ponto flutuante, então a operação é uma
            operação de ponto flutuante, mesmo que o outro operando seja
            de um tipo inteiro.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="286" objetivo="5.1">
		<introducao>Se pelo menos um dos operandos de um operador
            numérico é do tipo <stmt>double</stmt>, então a operação é realizada
            utilizando-se a aritimética de ponto flutuante de 64 bits. O
            resultado da operação é do tipo <stmt>double</stmt>. Se um dos operandos
            não é do tipo<stmt>double</stmt>, então este operando é convertido para
            o tipo <stmt>double</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="287" objetivo="5.1">
		<introducao>Se nenhum dos operandos de um operador é do tipo <stmt>double </stmt>e pelo menos um deles é um número ponto flutuante,
            então a operação é realizada utilizando-se a aritmética de
            ponto flutuante de 32 bits. Neste caso, se há um operando
            que não é do tipo <stmt>float</stmt>, então este é primeiro promovido
            para <stmt>float</stmt>, antes que a operação seja realizada.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="288" objetivo="2.4">
		<introducao>Operadores de ponto flutuante não produzem exceções.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="289" objetivo="2.4">
		<introducao>A expressão 1.0/0 não gera exceção.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="290" objetivo="2.4">
		<introducao>A expressão 1/0 gera exceção.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="291" objetivo="5.1">
		<introducao>A moldagem de um valor do tipo <stmt>boolean</stmt>
            só é permitida para o tipo <stmt>boolean</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="292" objetivo="5.1">
		<introducao>Um valor do tipo <stmt>boolean</stmt> pode ser
            convertido para uma <stmt>String</stmt> da mesma forma que
            uma <stmt>String</stmt> pode ser convertida para um valor
            correspondente do tipo <stmt>boolean</stmt>.</introducao>
		<resposta valor="f">O tipo <stmt>boolean</stmt> possui apenas dois valores: True e False.</resposta>
	</questao>
	<questao id="293" objetivo="6.3">
		<introducao>Um objeto é uma instância de uma classe ou um <stmt>array</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="294" objetivo="4.1">
		<introducao>Uma instância de uma interface é um objeto.</introducao>
		<resposta valor="f">Não se pode criar instância de uma
            interface, mas apenas de classes.</resposta>
	</questao>
	<questao id="295" objetivo="4.1">
		<introducao>Um <stmt>array</stmt> é um objeto.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="296" objetivo="4.6">
		<introducao>Uma referência é um valor que identifica um objeto.
            Há uma referência <stmt>null</stmt> que não se refere a
            objeto algum.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="297" objetivo="4.1">
		<introducao>Classe que contém o método <stmt>finalize</stmt>
            necessariamente não é uma classe abstrata.</introducao>
		<resposta valor="f">Toda classe contém o método <stmt>finalize</stmt>, e uma classe abstrata pode ter outros métodos.</resposta>
	</questao>
	<questao id="298" objetivo="4.6">
		<introducao>Qualquer caractere UNICODE pode ser utilizado em um
            comentário em Java.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="299" objetivo="4.1">
		<introducao>Um identificador em Java pode se iniciar pelo
            símbolo <stmt>$</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="300" objetivo="4.1">
		<introducao>Um identificador em Java pode se iniciar pelo
            símbolo <stmt>_</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
</Avaliacao>
