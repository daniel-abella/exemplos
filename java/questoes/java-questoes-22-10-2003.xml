<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="questoes-hide-answer.xslt"?>
<Avaliacao xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="questoes.xsd">
	<identificacao>
		<titulo>Questões sobre Linguagem de Programação Java</titulo>
		<copyright>Fábio Nogueira de Lucena</copyright>
		<versao>0.1 (22/10/2003)</versao>
	</identificacao>
	<historico>
		<evento data="2003-10-07">
			<comentario>Atingido o total de 2071 questões!</comentario>
		</evento>
		<evento data="2003-09-01">
			<comentario>Atingida a marca de 1540 questões em Java.</comentario>
		</evento>
		<evento data="2003-08-09">
			<comentario>Ultrapassado o total de 1000 questões em Java.
                Há motivo para comemorar!</comentario>
		</evento>
		<evento data="2003-07-22">
			<pagina>55</pagina>
			<comentario>Várias mudanças pequenas foram efetuadas no
                esquema: questoes.xsd. Trabalho futuro deverá contemplar
                o emprego de links para figuras, por exemplo, para
                ilustrar código em Java e diagramas UML associados a uma questão.</comentario>
		</evento>
		<evento data="2003-07-16">
			<comentario>Criação do arquivo XSLT para geração de HTML a
                partir de um arquivo de base de questões. Também foi
                utilizado um processador FOP para geração de arquivo PDF
                correspondente. Alguns pequenos ajustes foram feitos no
                Schema do arquiv XML.</comentario>
		</evento>
		<evento data="2003-07-15">
			<pagina>42</pagina>
		</evento>
		<evento data="2003-07-07">
			<pagina>35</pagina>
			<comentario>Primeiras questões pós a definição parcial do
                Schema para as questões.</comentario>
		</evento>
		<evento data="2003-07-06">
			<comentario>Criação do XML Schema para questões. Versão Inicial.</comentario>
		</evento>
		<evento data="2003-07-05">
			<pagina>28</pagina>
			<comentario/>
		</evento>
		<evento data="2003-06-09">
			<pagina>23</pagina>
		</evento>
		<evento data="2003-06-08">
			<pagina>20</pagina>
		</evento>
		<evento data="2003-06-02">
			<pagina>14</pagina>
		</evento>
		<evento data="2003-06-01">
			<pagina>8</pagina>
		</evento>
		<evento data="2003-05-31">
			<pagina>1</pagina>
			<comentario>Criação do arquivo</comentario>
		</evento>
	</historico>
	<questao id="1" qi="1" tipo="lógica">
		<introducao>A linguagem de programação Java foi originalmente
            chamada de Oak.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2" qi="1" tipo="lógica">
		<introducao>Java foi originalmente projetada por James Gosling
            para aplicações embutidas em produtos eletrônicos.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="3" qi="1" tipo="lógica">
		<introducao>Uma aplicação em Java deve computar os mesmos
            resultados em todas as máquinas e em todas as implementações.</introducao>
		<resposta valor="f">Há dependências temporais e outras
            questões não-determinísticas que podem tornar impossível o
            mesmo comportamento mesmo em um mesmo ambiente. Convém
            considerar ainda o fato de que nem todas as máquinas
            ppossuem os mesmos recursos de memória e capacidade de
            processamente, por exemplo.</resposta>
	</questao>
	<questao id="4" qi="1" tipo="lógica">
		<introducao>A linguagem de programação Java é fortemente tipada
                (<it>strongly typed</it>)?</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="5" qi="1" tipo="lógica">
		<introducao>Os tipos de Java estão divididos em tipos primitivos
            e tipos de referência.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="6" qi="1" tipo="lógica">
		<introducao>Os tipos primitivos foram definidos para serem os
            mesmos em todas as máquinas e em todas as implementações.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="7" qi="1" tipo="lógica">
		<introducao>Os tipos de referência estão divididos em: tipos de
            classe, tipos de interface e tipos de <stmt>array</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="8" qi="1" tipo="lógica">
		<introducao>Uma variável de um tipo de referência recebe valores
            que correspondem a objetos que são instâncias de classes ou <stmt>array</stmt>s.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="9" qi="1" tipo="lógica">
		<introducao>Uma variável de um tipo de classe pode reter a
            referência <stmt>null</stmt> ou a referência para um objeto
            cujo tipo é do tipo da classe ou de qualquer subclasse do
            tipo da classe.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="10" qi="1" tipo="lógica">
		<introducao>Uma variável do tipo de uma interface pode reter o
            valor de uma referência <stmt>null</stmt> ou a referência
            para uma instância de qualquer tipo de classe que implementa
            a interface.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="11" qi="1" tipo="lógica">
		<introducao>Uma variável de um tipo de <stmt>array</stmt> pode
            reter uma referência <stmt>null</stmt> ou a referência para
            um <stmt>
				<stmt>array</stmt>
			</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="12" qi="1" tipo="lógica">
		<introducao>Uma variável do tipo de classe <stmt>Object</stmt>
            pode reter uma referência <stmt>null</stmt> ou uma
            referência para qualquer objeto, seja uma instância de uma
            classe ou de um <stmt>array</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="13" qi="1" tipo="lógica">
		<introducao>Conversão de tipo (<it>casting</it>) sobre tipos de
            referência são verificados em tempo de execução (<it>run
            time</it>) para assegurar que a conversão é válida (<it>type safety</it>).</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="14" qi="1" tipo="lógica">
		<introducao>Apenas herança simples é permitida em Java.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="15" qi="1" tipo="lógica">
		<introducao>Toda classe em Java é derivada da classe <stmt>Object</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="16" qi="1" tipo="lógica">
		<introducao>Uma classe <stmt>D</stmt> pode ser derivada de uma
            classe <stmt>B1</stmt> e <stmt>B2</stmt>, ou seja,
                <stmt>class D extends B1, B2</stmt> é uma sentença
            válida em Java.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="17" qi="1" tipo="Lógica">
		<introducao>Uma classe pode conter o método
            <stmt>finalize</stmt>. Neste caso, toda instância desta
            classe, imediatamente antes de ser descartada pelo garbage
            collector, terá este método executado.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="18" qi="1" tipo="lógica">
		<introducao>
			<stmt>finalize</stmt> é uma palavra reservada de Java.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="19" qi="1" tipo="lógica">
		<introducao>Herança múltipla de interface é permitida em Java.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="20" qi="1" tipo="lógica">
		<introducao>
			<stmt>array</stmt>s são objetos criados dinamicamente.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="21" qi="1" tipo="lógica">
		<introducao>Uma variável do tipo de classe <stmt>Object</stmt>
            pode receber uma referência para um <stmt>array</stmt> em
            uma atribuição.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="22" qi="1" tipo="lógica">
		<introducao>Java permite <stmt>array</stmt>s multidimensionais.</introducao>
		<resposta valor="f">Java permite <stmt>array</stmt>s de
            <stmt>array</stmt>s, em vez de <stmt>array</stmt>s multidimensionais.</resposta>
	</questao>
	<questao id="23" qi="1" tipo="lógica">
		<introducao>Java permite <stmt>array</stmt>s de <stmt>array</stmt>s.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="24" qi="1" tipo="lógica">
		<introducao>Há três tipos de exceções (<it>exceptions</it>) em
            Java: exceções verificadas (<it>checked</it>), exceçoes de
            tempo de execução (<it>run-time exceptions</it>) e erros (<it>errors</it>).</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="25" qi="1" tipo="lógica">
		<introducao>Objetos que são instâncias de uma classe
            <stmt>C</stmt> também contêm uma instância de cada
            superclasse da classe <stmt>C</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="26" qi="1" tipo="lógica">
		<introducao>A criação de um objeto envolve a criação recursiva
            das instâncias de toda a hierarquia de classes desde a
            classe cujo objeto é criado até a classe <stmt>Object</stmt>
            (raiz de todas as hierarquias de classe).</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="27" qi="1" tipo="lógica">
		<introducao>Em Java as variáveis locais não são automaticamente
            iniciadas com valores predefinidos.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="28" qi="1" tipo="lógica">
		<introducao>Programas em Java são escritos usando o conjunto de
            caracteres ASCII.</introducao>
		<resposta valor="f">O conjunto de caracteres UNICODE é
            empregado. Veja <link>http://www.unicode.org</link> para detalhes.</resposta>
	</questao>
	<questao id="29" qi="1" tipo="lógica">
		<introducao>A versão de UNICODE empregada para se escrever
            programas em Java é documentada na classe <stmt>Character</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="30" qi="1" tipo="lógica">
		<introducao>Embora um programa em Java seja escrito
            empregando-se o conjunto de caracteres UNICODE, alguns dos
            elementos desta linguagem estão restritos ao conjunto de
            caracteres ASCII (ANSI X3.4).</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="31" qi="1" tipo="lógica">
		<introducao>Os primeiros 128 caracteres do conjunto de
            caracteres UNICODE são caracteres ASCII.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="32" qi="1" tipo="lógica">
		<introducao>
			<stmt>Açaí</stmt>, <stmt>Fábio</stmt> e <stmt>Geléia</stmt>
            são identificadores válidos em Java.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="33" qi="1" tipo="lógica">
		<introducao>Em comentários, embora um programa em Java seja
            escrito empregando o conjunto de caracteres UNICODE, os
            caracteres permitidos formam um subconjunto de UNICODE
            denominado de ASCII.</introducao>
		<resposta valor="f">Qualquer caractere UNICODE pode ser
            empregado em um comentário.</resposta>
	</questao>
	<questao id="34" qi="1" tipo="lógica">
		<introducao>A representação em Java de uma <stmt>String</stmt>
            (seqüência de caracteres) faz uso dos caracteres UNICODE não
            restritos àqueles que também fazem parte do conjunto ASCII.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="35" qi="1" tipo="lógica">
		<introducao>Todo e qualquer programa em Java, mesmo que este
            faça uso dos caracteres UNICODE, é possível de ser escrito
            empregando-se apenas caracteres ASCII no código fonte deste programa.</introducao>
		<resposta valor="v">Convém lembrar, a seqüencia
            <stmt>\uxxxx</stmt> representa o caractere UNICODE cujo
            valor hexadecimal é xxxx.</resposta>
	</questao>
	<questao id="36" qi="1" tipo="lógica">
		<introducao>A seqüencia <stmt>\uxxxx</stmt>, onde xxxx é um
            valor hexadecimal, representa um caractere UNICODE cuja
            codificação é xxxx.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="37" qi="1" tipo="lógica">
		<introducao>Uma seqüencia de caracteres UNICODE, que representa
            um programa em Java, é convertida em uma seqüencia de
            <it>token</it>s correspondente durante o processo de
            compilação de todo e qualquer programa em Java.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="38" qi="1" tipo="lógica">
		<introducao>Espaços em branco e comentários em um programa em
            Java não apresentam nenhuma relevância para o código
            correspondente em <it>bytecode</it>s.</introducao>
		<resposta valor="v">Espaços em branco e comentários são
            excluídos no processo de análise léxica (descartados) e não
            formam <it>token</it>s, que têm relevância sintática e semântica.</resposta>
	</questao>
	<questao id="39" qi="1" tipo="lógica">
		<introducao>Não é tratado como um comentário os elementos
            <stmt>/*</stmt> e <stmt>*/</stmt> quando fornecidos em uma
            linha que se inicia com <stmt>//</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="40" qi="1" tipo="lógica">
		<introducao>Quando <stmt>//</stmt> é fornecido no interior de
            comentários que se iniciam por <stmt>/*</stmt> ou
            <stmt>/**</stmt> estes caracteres provocam um erro de compilação.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="41" qi="1" tipo="lógica">
		<introducao>A literal do tipo <stmt>String</stmt> &quot;A casa
            /* comentario */ é bela&quot; é válida.</introducao>
		<resposta valor="f">Não é permitido o emprego de comentários
            no interior de literais do tipo <stmt>String</stmt>.</resposta>
	</questao>
	<questao id="42" qi="1" tipo="lógica">
		<introducao>Um identificador em Java possui, no máximo, 255 caracteres.</introducao>
		<resposta valor="f">Identificadores em Java são seqüências
            ilimitadas de caracteres.</resposta>
	</questao>
	<questao id="43" qi="1" tipo="lógica">
		<introducao>Não há limite para a quantidade de caracteres que
            podem fazer parte de um identificador em Java.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="44" qi="1" tipo="lógica">
		<introducao>Um identificador em Java deve, necessariamente,
            iniciar-se por uma letra.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="45" qi="1" tipo="lógica">
		<introducao>Palavras reservadas (<it>keyword</it>s) de Java não
            podem ser empregadas como identificadores.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="46" qi="1" tipo="lógica">
		<introducao>Um identificador em Java não pode conincidir com uma
            literal lógica (<stmt>boolean</stmt>).</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="47" qi="1" tipo="lógica">
		<introducao>Um identificador em Java não pode coincidir com a
            literal de referência <stmt>null</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="48" qi="1" tipo="lógica">
		<introducao>Um identificador em Java não pode coincidir com uma
            palavra reservada ou <it>keyword</it>, uma literal lógica
            (<stmt>boolean</stmt>) ou a literal <stmt>null</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="49" qi="1" tipo="lógica">
		<introducao>
			<stmt>strictfp</stmt> é um identificador válido.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="50" qi="1" tipo="lógica">
		<introducao>Um identificador em Java pode conter dígitos
            numéricos descritos pelos caracteres de <stmt>0</stmt> a <stmt>9</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="51" qi="1" tipo="lógica">
		<introducao>As letras que podem fazer parte de um identificador
            em Java podem ser obtidas dentre todas aquelas que pertencem
            ao conjunto de caracteres UNICODE.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="52" qi="1" tipo="lógica">
		<introducao>O caractere $ pode fazer parte de um identificador
            em Java.</introducao>
		<resposta valor="v">Deve ser de uso restrito a código
            fonte gerado mecanicamente ou, raramente, para se ter acesso
            a nomes preexistentes em sistemas legados.</resposta>
	</questao>
	<questao id="53" qi="1" tipo="lógica">
		<introducao>
			<stmt>String</stmt> é um identificador válido.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="54" qi="1" tipo="lógica">
		<introducao>
			<stmt>instanceOf</stmt> é uma palavra reservada
            (<it>keyword</it>) em Java.</introducao>
		<resposta valor="f">Há uma palavra reservada de grafia
            semelhante: <stmt>instanceof</stmt> (com todas as letras
            minúsculas). Ou seja, <stmt>instanceOf</stmt> e
            <stmt>instanceof</stmt> são apenas palavras homógrafas.</resposta>
	</questao>
	<questao id="55" qi="1" tipo="lógica">
		<introducao>Todas as palavras reservadas (<it>keyword</it>s) em
            Java são escritas empregando-se exclusivamente letras minúsculas.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="56" qi="1" tipo="lógica">
		<introducao>
			<stmt>const</stmt> e <stmt>goto</stmt> seriam
            identificadores válidos se não fossem palavras reservadas.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="57" qi="1" tipo="lógica">
		<introducao>Um programa em Java pode definir uma variável do
            tipo <stmt>float</stmt> cujo identificador é <stmt>goto</stmt>.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="58" qi="1" tipo="lógica">
		<introducao>Um programa em Java fazer uso de uma variável do
            tipo <stmt>byte</stmt> cujo identificador é <stmt>const</stmt>.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="59" qi="1" tipo="lógica">
		<introducao>Embora não empregados pela linguagem Java,
            <stmt>const</stmt> e <stmt>goto</stmt> são palavras
            reservadas (<it>keyword</it>s).</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="60" qi="1" tipo="lógica">
		<introducao>
			<stmt>true</stmt> e <stmt>false</stmt> são identificadores válidos.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="61" qi="1" tipo="lógica">
		<introducao>
			<stmt>include</stmt> é palavra reservada de Java.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="62" qi="1" tipo="lógica">
		<introducao>
			<stmt>String</stmt> é palavra reservada de Java.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="63" qi="1" tipo="lógica">
		<introducao>protected é palavra reservada de Java.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="64" qi="1" tipo="lógica">
		<introducao>throw e throws são palavras reservadas de Java.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="65" qi="1" tipo="lógica">
		<introducao>abstract é palavra reservada de Java.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="66" qi="1" tipo="lógica">
		<introducao>
			<stmt>boolean</stmt> é palavra reservada de Java.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="67" qi="1" tipo="lógica">
		<introducao>
			<stmt>break</stmt> é palavra reservada de Java.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="68" qi="1" tipo="lógica">
		<introducao>
			<stmt>byte</stmt> é palavra reservada de Java.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="69" qi="1" tipo="lógica">
		<introducao>
			<stmt>case</stmt> é palavra reservada de Java.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="70" qi="1" tipo="lógica">
		<introducao>
			<stmt>catch</stmt> é palavra reservada de Java.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="71" qi="1" tipo="lógica">
		<introducao>
			<stmt>char</stmt> é palavra reservada de Java.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="72" qi="1" tipo="lógica">
		<introducao>
			<stmt>class</stmt> é palavra reservada de Java.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="73" qi="1" tipo="lógica">
		<introducao>
			<stmt>const</stmt> é palavra reservada de Java.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="74" qi="1" tipo="lógica">
		<introducao>
			<stmt>continue</stmt> é palavra reservada de Java.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="75" qi="1" tipo="lógica">
		<introducao>
			<stmt>default</stmt> é palavra reservada de Java.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="76" qi="1" tipo="lógica">
		<introducao>
			<stmt>do</stmt> é palavra reservada de Java.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="77" qi="1" tipo="lógica">
		<introducao>
			<stmt>double</stmt> é palavra reservada de Java.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="78" qi="1" tipo="lógica">
		<introducao>
			<stmt>else</stmt> é palavra reservada de Java.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="79" qi="1" tipo="lógica">
		<introducao>
			<stmt>extends</stmt> é palavra reservada de Java.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="80" qi="1" tipo="lógica">
		<introducao>
			<stmt>final</stmt> é palavra reservada de Java.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="81" qi="1" tipo="lógica">
		<introducao>
			<stmt>finally</stmt> é palavra reservada de Java.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="82" qi="1" tipo="lógica">
		<introducao>
			<stmt>float</stmt> é palavra reservada de Java.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="83" qi="1" tipo="lógica">
		<introducao>
			<stmt>for</stmt> é palavra reservada de Java.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="84" qi="1" tipo="lógica">
		<introducao>
			<stmt>goto</stmt> é palavra reservada de Java.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="85" qi="1" tipo="lógica">
		<introducao>
			<stmt>if</stmt> é palavra reservada de Java.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="86" qi="1" tipo="lógica">
		<introducao>
			<stmt>implements</stmt> é palavra reservada de Java.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="87" qi="1" tipo="lógica">
		<introducao>
			<stmt>import</stmt> é palavra reservada de Java.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="88" qi="1" tipo="lógica">
		<introducao>
			<stmt>instanceof</stmt> é palavra reservada de Java.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="89" qi="1" tipo="lógica">
		<introducao>
			<stmt>int</stmt> é palavra reservada de Java.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="90" qi="1" tipo="lógica">
		<introducao>
			<stmt>interface</stmt> é palavra reservada de Java.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="91" qi="1" tipo="lógica">
		<introducao>
			<stmt>long</stmt> é palavra reservada de Java.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="92" qi="1" tipo="lógica">
		<introducao>
			<stmt>native</stmt> é palavra reservada de Java.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="93" qi="1" tipo="lógica">
		<introducao>
			<stmt>new</stmt> é palavra reservada de Java.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="94" qi="1" tipo="lógica">
		<introducao>
			<stmt>package</stmt> é palavra reservada de Java.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="95" qi="1" tipo="lógica">
		<introducao>
			<stmt>private</stmt> é palavra reservada de Java.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="96" qi="1" tipo="lógica">
		<introducao>
			<stmt>protected</stmt> é palavra reservada de Java.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="97" qi="1" tipo="lógica">
		<introducao>
			<stmt>public</stmt> é palavra reservada de Java.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="98" qi="1" tipo="lógica">
		<introducao>
			<stmt>return</stmt> é palavra reservada de Java.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="99" qi="1" tipo="lógica">
		<introducao>short é palavra reservada de Java.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="100" qi="1" tipo="lógica">
		<introducao>static é palavra reservada de Java.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="101" qi="1" tipo="lógica">
		<introducao>strictfp é palavra reservada de Java.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="102" qi="1" tipo="lógica">
		<introducao>super é palavra reservada de Java.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="103" qi="1" tipo="lógica">
		<introducao>switch é palavra reservada de Java.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="104" qi="1" tipo="lógica">
		<introducao>synchronized é palavra reservada de Java.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="105" qi="1" tipo="lógica">
		<introducao>this é palavra reservada de Java.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="106" qi="1" tipo="lógica">
		<introducao>throw é palavra reservada de Java.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="107" qi="1" tipo="lógica">
		<introducao>throws é palavra reservada de Java.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="108" qi="1" tipo="lógica">
		<introducao>
			<stmt>transiente</stmt> é palavra reservada de Java.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="109" qi="1" tipo="lógica">
		<introducao>try é palavra reservada de Java.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="110" qi="1" tipo="lógica">
		<introducao>void é palavra reservada de Java.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="111" qi="1" tipo="lógica">
		<introducao>volatile é palavra reservada de Java.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="112" qi="1" tipo="lógica">
		<introducao>while é palavra reservada de Java.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="113" qi="1" tipo="lógica">
		<introducao>protect é palavra reservada de Java.</introducao>
		<resposta valor="f">protected é palavra reservada de Java.</resposta>
	</questao>
	<questao id="114" qi="1" tipo="lógica">
		<introducao>implement é palavra reservada de Java.</introducao>
		<resposta valor="f">
			<stmt>implements</stmt> é palavra reservada de Java. Observe
            a ausência do s em implement.</resposta>
	</questao>
	<questao id="115" qi="1" tipo="lógica">
		<introducao>super não é palavra reservada de Java.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="116" qi="1" tipo="lógica">
		<introducao>char não é palavra reservada de Java.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="117" qi="1" tipo="lógica">
		<introducao>
			<stmt>boolean</stmt> não é palavra reservada de Java.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="118" qi="1" tipo="lógica">
		<introducao>synchronize não é palavra reservada de Java.</introducao>
		<resposta valor="v">Não confunda com synchronized que é
            uma legítima palavra reservada de Java.</resposta>
	</questao>
	<questao id="119" qi="1" tipo="lógica">
		<introducao>continue não é palavra reservada de Java.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="120" qi="1" tipo="lógica">
		<introducao>native não é palavra reservada de Java.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="121" qi="1" tipo="lógica">
		<introducao>break não é palavra reservada de Java.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="122" qi="1" tipo="lógica">
		<introducao>
			<stmt>default</stmt> não é palavra reservada de Java.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="123" qi="1" tipo="lógica">
		<introducao>
			<stmt>transient</stmt> não é palavra reservada de Java.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="124" qi="1" tipo="lógica">
		<introducao>volatile não é palavra reservada de Java.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="125" qi="1" tipo="lógica">
		<introducao>imports não é palavra reservada de Java.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="126" qi="1" tipo="lógica">
		<introducao>Em Java, uma literal é a representação em código
            fonte de um valor de um tipo primitivo, de um valor do tipo
            <stmt>String</stmt> ou o tipo <stmt>null</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="127" qi="1" tipo="lógica">
		<introducao>Um valor do tipo <stmt>String</stmt> é expresso em
            Java através de uma literal.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="128" qi="1" tipo="lógica">
		<introducao>Uma literal inteira é do tipo long se L ou l é o
            sufixo empregado.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="129" qi="1" tipo="lógica">
		<introducao>Um número decimal é um único caractere ASCII 0, cujo
            valor correspondente é zero, ou consiste de um dígito de 1 a
            9 opcionalmente seguido por um ou mais dígitos de 0 a 9, o
            que representa um inteiro positivo.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="130" qi="1" tipo="lógica">
		<introducao>Se uma literal inteira não possui o sufixo L ou l,
            então o valor correspondente é do tipo int.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="131" qi="1" tipo="lógica">
		<introducao>Um numeral hexadecimal consiste dos caracteres ASCII
            0x ou 0X seguidos de um ou mais dígitos hexadecimais e pode
            representar um valor positivo, zero, ou negativo.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="132" qi="1" tipo="lógica">
		<introducao>Dígitos hexadecimais correspondentes aos valores
            decimais de 10 a 15 são representados pelos caracteres de a
            até f ou de A até F, inclusive.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="133" qi="1" tipo="lógica">
		<introducao>Qualquer caractere que representa um dígito
            hexadecimal pode ser representado em maiúscula ou minúscula.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="134" qi="1" tipo="lógica">
		<introducao>Um número na representação octal consiste de um
            dígito ASCII 0 seguido de um ou mais dígito de 0 até 7, inclusive.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="135" qi="1" tipo="lógica">
		<introducao>Um número octal pode representar um valor positivo,
            zero ou negativo.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="136" qi="1" tipo="lógica">
		<introducao>A literal 00 representa um valor decimal.</introducao>
		<resposta valor="f">O único número decimal que se inicia com
            0 é o de valor zero, representado por este único caractere.</resposta>
	</questao>
	<questao id="137" qi="1" tipo="lógica">
		<introducao>A literal 01 representa o valor 1 em decimal.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="138" qi="1" tipo="lógica">
		<introducao>A literal 02 representa o valor 2 em decimal.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="139" qi="1" tipo="lógica">
		<introducao>A literal 03 representa o valor 3 em decimal.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="140" qi="1" tipo="lógica">
		<introducao>A literal 04 representa o valor 4 em decimal.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="141" qi="1" tipo="lógica">
		<introducao>A literal 05 representa o valor 5 em decimal.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="142" qi="1" tipo="lógica">
		<introducao>A literal 06 representa o valor 6 em decimal.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="143" qi="1" tipo="lógica">
		<introducao>A literal 07 representa o valor 7 em decimal.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="144" qi="1" tipo="lógica">
		<introducao>A literal 08 representa o valor 8 em decimal.</introducao>
		<resposta valor="f">08 é uma literal inválida. O decimal 8 é
            representado simplesmente pelo caractere 8. Observe que 8 é
            um caractere inválido para uma literal que representa um
            valor na representação octal.</resposta>
	</questao>
	<questao id="145" qi="1" tipo="lógica">
		<introducao>Qualquer valor em octal é formado por pelo menos
            dois caracteres, sendo que o primeiro deles é 0.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="146" qi="1" tipo="lógica">
		<introducao>As literais 0, 00 e 0x0 representam todas, o valor
            inteiro zero. A primeira na representação decimal, a segunda
            na octal e a terceira na representação hexadecimal.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="147" qi="1" tipo="lógica">
		<introducao>A maior literal decimal do tipo int é 2 elevado a 31
            (2147483648). Qualquer valor entre 0 e 2147483647 pode ser
            empregado onde uma literal do tipo int é esperada.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="148" qi="1" tipo="lógica">
		<introducao>A literal 2 elevado a 31 só pode ser empregada como
            o operando do operador unário de negação (-).</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="149" qi="1" tipo="lógica">
		<introducao>Se uma literal na representação hexadecimal ou octal
            não possível de ser armazenada em 32 bits, então a tentativa
            de atribuição de tal literal a uma variável do tipo int
            provoca um erro em tempo de compilação.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="150" qi="1" tipo="lógica">
		<introducao>Uma literal ponto-flutuante é do tipo float se
            possui o sufixo ASCII f ou F.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="151" qi="1" tipo="lógica">
		<introducao>Uma literal ponto-flutuante é do tipo double se não
            possui o sufixo ASCII f ou F.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="152" qi="1" tipo="lógica">
		<introducao>Uma literal ponto-flutuante é do tipo double se
            possui possui o sufixo ASCII d ou D.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="153" qi="1" tipo="lógica">
		<introducao>Um erro em tempo de compilação é gerado se uma
            literal ponto-flutuante é muito grande e não é um valor no
            conjunto daqueles permitidos para o tipo em questão.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="154" qi="1" tipo="lógica">
		<introducao>Uma literal ponto-flutuante muito grande, quando
            convertida para uma representação interna, torna-se o valor
            infinito (IEEE 754).</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="155" qi="1" tipo="lógica">
		<introducao>O valor infinito (IEEE 754) pode ser fornecido a uma
            variável ponto-flutuante, sem gerar um erro em tempo de
            compilação ou execução, através das expressões constantes
            como 1f/0f ou -1d/0d.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="156" qi="1" tipo="lógica">
		<introducao>O valor infinito (IEEE 754) pode ser introduzido em
            uma variável através das constantes predefinidas
            POSITIVE_INFINITY e NEGATIVE_INFINITY. Estas constantes
            estão predefinidas nas classes Float e Double.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="157" qi="1" tipo="lógica">
		<introducao>A constante que não representa um número
            (Not-a-Number), conforme IEEE 754, é definida nas classes
            <stmt>Float</stmt> e <stmt>Double</stmt> pelas constantes
            predefinidas <stmt>Float.NaN</stmt> e <stmt>Double.NaN</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="158" qi="1" tipo="lógica">
		<introducao>São literais, 1e1f e 2.f, ambas do tipo float.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="159" qi="1" tipo="lógica">
		<introducao>São literais, .3 e 2., ambas do tipo double.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="160" qi="1" tipo="lógica">
		<introducao>Exemplos de literais ponto-flutuante incluem: 1e1, 0
            e 1e1d.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="161" qi="1" tipo="lógica">
		<introducao>Literais ponto-flutuante podem ser expressas em
            bases diferentes da base decimal.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="162" qi="1" tipo="lógica">
		<introducao>São literais ponto-flutuanete, 0xFFD e 2.d, ambas do
            tipo double.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="163" qi="1" tipo="lógica">
		<introducao>São literais ponto-flutuante, 0777D e .2d, ambas do
            tipo double.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="164" qi="1" tipo="lógica">
		<introducao>Todas as literais do tipo <stmt>boolean</stmt>
            resumem-se em <stmt>true</stmt> e <stmt>false</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="165" qi="1" tipo="lógica">
		<introducao>A literal <stmt>boolean</stmt>
			<stmt>false</stmt> equivale a qualquer valor inteiro
            diferente de zero.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="166" qi="1" tipo="lógica">
		<introducao>A literal <stmt>boolean</stmt>
			<stmt>true</stmt> equivale a qualquer valor inteiro
            diferente de zero.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="167" qi="1" tipo="lógica">
		<introducao>A literal <stmt>boolean</stmt>
			<stmt>false</stmt> equivale ao valor inteiro 0.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="168" qi="1" tipo="lógica">
		<introducao>Uma literal caractere (character) é expressa como um
            caractere ou através de uma escape sequence, entre aspas
            simples ASCII.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="169" qi="1" tipo="lógica">
		<introducao>É um erro gerado em tempo de compilação encontrar um
            fim de linha após uma aspas simples e antes da aspas simples
            que define um caractere.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="170" qi="1" tipo="lógica">
		<introducao>Exemplos de caracteres incluem: 'a', '\t', '\'',
            '\uFFFF', '@'.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="171" qi="1" tipo="lógica">
		<introducao>Nao é correto fazer uso da literal '\u000a' porque
            uma das primeiras análises realizadas em um código fonte em
            Java irá converter tal caractere em 'LF' (fim de linha) e,
            portanto, '\u000a' não é uma literal válida.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="172" qi="1" tipo="lógica">
		<introducao>
			<stmt>String</stmt>s em Java possuem valores constantes, ou
            seja, não podem ser alterados.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="173" qi="1" tipo="lógica">
		<introducao>Uma literal <stmt>String</stmt> consiste de um ou
            mais caracteres delimitados por aspas duplas.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="174" qi="1" tipo="lógica">
		<introducao>Uma literal <stmt>String</stmt> é sempre do tipo <stmt>String</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="175" qi="1" tipo="lógica">
		<introducao>Exemplos de literais <stmt>String</stmt>s incluem:
            &quot;&quot;, &quot;\&quot;&quot;, &quot;A vida é
            bela&quot;, &quot;O &quot; + &quot;melhor&quot; + &quot;
            jogador é Pelé&quot;.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="176" qi="1" tipo="lógica">
		<introducao>Toda literal <stmt>String</stmt> é uma referência
            para uma instância da classe <stmt>String</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="177" qi="1" tipo="lógica">
		<introducao>Objetos <stmt>String</stmt> possuem valores
            constantes, que não podem ser alterados.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="178" qi="1" tipo="lógica">
		<introducao>Para que objetos <stmt>String</stmt> possuem
            compartilhar instâncias de literais <stmt>String</stmt>, o
            método 'intern' deve ser empregado.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="179" qi="1" tipo="lógica">
		<introducao>Literais <stmt>String</stmt> em uma mesma classe
            representam referências para o mesmo objeto <stmt>String</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="180" qi="1" tipo="lógica">
		<introducao>Literais <stmt>String</stmt> em classes distintas em
            um mesmo package representam referências para o mesmo objeto <stmt>String</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="181" qi="1" tipo="lógica">
		<introducao>Literais <stmt>String</stmt> em classes distintas de
            packages distintos representam referências para o mesmo
            objeto <stmt>String</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="182" qi="1" tipo="lógica">
		<introducao>
			<stmt>String</stmt>s obtidas de expressões constantes
            obtidas em tempo de compilação são tratadas como se fossem literais.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="183" qi="1" tipo="lógica">
		<introducao>Objetos <stmt>String</stmt> criados em tempo de
            execução são distintos, mesmo que as literais associadas a
            estes sejam as mesmas.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="184" qi="1" tipo="lógica">
		<introducao>O resultado de internalizar (intern) um objeto
            <stmt>String</stmt> dá origem a um objeto
            <stmt>String</stmt> que é o mesmo de uma literal
            <stmt>String</stmt> pré-existente com o mesmo conteúdo.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="185" qi="1" tipo="lógica">
		<introducao>Sabendo-se que o valor UNICODE \u0009 equivale a
            sequence escape \t, pode-se afirmar que as literais
            &quot;tab\t\ttab&quot; e &quot;tab\u0009\u0009tab&quot;
            produzem o mesmo efeito quando enviadas para a saída padrão
            através de System.out.println.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="186" qi="1" tipo="lógica">
		<introducao>Sabendo-se que o valor UNICODE \u0027 equivale a
            sequence escape \', aspas simples, e \u0022 às aspas duplas,
            pode-se afirmar que \u0027\u0022\u0027 representa o
            caractere &quot;.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="187" qi="1" tipo="lógica">
		<introducao>A linguagem Java é um exemplo de linguagem strongly
            typed. Noutras palavras, todas as variáveis e expressões
            possuem um tipo que é conhecido em tempo de compilação.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="188" qi="1" tipo="lógica">
		<introducao>Há duas categorias de tipos em Java: tipos
            primitivos e tipos de referência.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="189" qi="1" tipo="lógica">
		<introducao>Os tipos primitivos de Java incluem o tipo
            <stmt>boolean</stmt> e os tipos numéricos. Estes últimos
            incluem: byte, short, int, long e char, além dos tipos em
            ponto-flutuante float e double.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="190" qi="1" tipo="lógico">
		<introducao>Os tipos referência em Java são os tipos de classes,
            tipos de interfaces e os tipos de <stmt>array</stmt>s.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="191" qi="1" tipo="lógica">
		<introducao>Em Java, <stmt>null</stmt> é um tipo especial, o
            tipo <stmt>null</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="192" qi="1" tipo="lógica">
		<introducao>Um objeto, em Java, é uma instância criada
            dinamicamente de um tipo de classe ou <stmt>array</stmt>
            criado dinamicamente.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="193" qi="1" tipo="lógico">
		<introducao>Os valores dos tipos referência são referências para objetos.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="194" qi="1" tipo="lógica">
		<introducao>Todos os objetos em Java, inclusive os
            <stmt>array</stmt>s, oferecem suporte aos métodos da classe <stmt>Object</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="195" qi="1" tipo="lógica">
		<introducao>Uma variavel representa um local de armazenamento de informação.</introducao>
		<resposta valor="veradeiro"/>
	</questao>
	<questao id="196" qi="1" tipo="lógico">
		<introducao>Uma variável de um tipo primitivo sempre armazena um
            valor deste tipo.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="197" qi="1" tipo="lógico">
		<introducao>Uma variável de um tipo de classe T pode reter
            apenas uma referência <stmt>null</stmt> ou uma referência
            para uma instância da classe de T.</introducao>
		<resposta valor="f">Observe que pode também reter uma
            referência para uma subclasse de T.</resposta>
	</questao>
	<questao id="198" qi="1" tipo="lógico">
		<introducao>A variável de um tipo interface pode reter apenas
            uma referência para qualquer instância de qualquer classe
            que implementa a interface.</introducao>
		<resposta valor="f">Pode reter também a referência <stmt>null</stmt>.</resposta>
	</questao>
	<questao id="199" qi="1" tipo="lógico">
		<introducao>Se T é um tipo primitivo, então uma variável do tipo
            &quot;<stmt>array</stmt> de T&quot; pode reter uma
            referência <stmt>null</stmt> ou uma referência para qualquer
            <stmt>array</stmt> do tipo &quot;<stmt>array</stmt> de T&quot;.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="200" qi="1" tipo="lógico">
		<introducao>Se T é um tipo de referência, então uma variável do
            tipo &quot;<stmt>array</stmt> de T&quot; pode reter a
            referência <stmt>null</stmt> ou uma referência para qualquer
            <stmt>array</stmt> do tipo &quot;<stmt>array</stmt> de
            S&quot; onde uma variável do tipo S pode ter seu valor
            atribuído a uma variável do tipo T.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="201" qi="1" tipo="lógico">
		<introducao>Uma variável do tipo <stmt>Object</stmt> pode reter
            a referência <stmt>null</stmt> ou uma referência para
            qualquer objeto, seja uma instância de classe ou <stmt>array</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="202" qi="1" tipo="lógico">
		<introducao>Há dois tipos de &quot;tipos&quot; em Java: os tipos
            primitivos e os tipos de referência.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="203" qi="1" tipo="lógico">
		<introducao>Há dois tipos de valores que podem ser armazenados
            em variáveis da linguagem de programação Java: os valores
            primitivos, correspondentes aos tipos primitivos e os
            valores de referência, correspondentes aos tipos de referência.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="204" qi="1" tipo="lógico">
		<introducao>Em Java, <stmt>null</stmt> é um tipo especial, que
            não possui nome e que representa o tipo de expressões
            <stmt>null</stmt>. Embora considerada um tipo, não é
            possível criar uma variável do tipo <stmt>null</stmt> ou
            realizar uma operação de conversão (cast) com o tipo
            <stmt>null</stmt>, por exemplo.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="205" qi="1" tipo="lógico">
		<introducao>A referência <stmt>null</stmt> sempre pode ser
            convertida (cast) para qualquer tipo de referência. Embora
            considerada um tipo, pode-se tratar <stmt>null</stmt> como
            uma simples literal especial que pode ser de qualquer tipo
            de referência.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="206" qi="1" tipo="lógico">
		<introducao>O valor de um variável de um tipo primitivo só pode
            ser alterado por uma operação de atribuição naquela variável.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="207" qi="1" tipo="lógico">
		<introducao>Os tipos ditos inteiros são byte, short, int e long
            que, respectivamente representam valores de 8 bits, 16 bits,
            32 bits e 64 bits com sinal usando a notação de complemento
            de dois. O tipo char também é considerado um tipo inteiro e
            seus valores são de 16 bits. Ao contrário dos anteriores,
            contudo, estes valores representam caracteres UNICODE e são
            todos sem sinal.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="208" qi="1" tipo="lógico">
		<introducao>O tipo <stmt>boolean</stmt> é, entre os tipos
            primitivos, aquele cujo domínio de valores é menor. Apenas
            dois valores existem para variáveis do tipo
            <stmt>boolean</stmt>: verdadeiro e falso, que são
            representados, respectivamente, pelas literais
            <stmt>true</stmt> e <stmt>false</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="209" qi="1" tipo="lógico">
		<introducao>Os tipos primitivos em ponto-flutuamente incluem
            float e double, respectivamente valores de 32 e 64 bits
            conforme a especificação IEEE 754.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="210" qi="1" tipo="lógico">
		<introducao>Os operadores de comparação, &lt;, &lt;=, > e >=,
            quando aplicados a valores inteiros produzem como resultado
            um valor do tipo <stmt>boolean</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="211" qi="1" tipo="lógico">
		<introducao>Os operadores numéricos, quando aplicados a
            operandos do tipo inteiro, resultam em valor do tipo
            <stmt>int</stmt> ou <stmt>long</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="212" qi="1" tipo="lógico">
		<introducao>O + e o - unários são operadores numéricos.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="213" qi="1" tipo="lógico">
		<introducao>O +, -, *, / e % são operadores numéricos.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="214" qi="1" tipo="lógico">
		<introducao>São operadores numéricos: ++ e --, ambos prefixados
            e pós-fixados.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="215" qi="1" tipo="lógico">
		<introducao>Os operadores de deslocamente com e sem sinal são
            operadores numéricos: &lt;&lt;, >> e >>>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="216" qi="1" tipo="lógico">
		<introducao>O operador ~ representa o complemento bit a bit
            (bitwise) além de exemplo de operador numérico.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="217" qi="1" tipo="lógico">
		<introducao>Os operadores bit a bit (bitwise) &amp;, | e ^ são
            ditos numéricos e representam operações bit a bit</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="218" qi="1" tipo="lógico">
		<introducao>O operador condicional ? : é considerado um operador numérico.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="219" qi="1" tipo="lógico">
		<introducao>O operador de conversão (cast) pode converter um
            valor inteiro em qualuqer valor numérico.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="220" qi="1" tipo="lógico">
		<introducao>O operador + quando envolver uma <stmt>String</stmt>
            e um operando inteiro, converterá o operando inteiro em uma
            <stmt>String</stmt> que representa o valor na forma decimal
            e então produzirá uma nova <stmt>String</stmt> que é a
            concatenação da <stmt>String</stmt> existente com aquela
            criada pela conversão.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="221" qi="1" tipo="lógico">
		<introducao>Se um operador inteiro que não seja o operador de
            deslocamento tenha pelo menos um operando do tipo long,
            então a operação será realizada utilizando-se uma precisão
            de 64 bits e o resultado do operador é do tipo long.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="222" qi="1" tipo="lógico">
		<introducao>Se um dos operandos de um operador numérico é long e
            o outro não, entao o operando que não é do tipo long é
            expandido (promovido) para um valor do tipo long antes que a
            operação seja realizada.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="223" qi="1" tipo="lógico">
		<introducao>Se nenhum dos operandos de um operador numérico é do
            tipo long, então a operação é realizada empregando-se um
            precisão de 32 bits e o resultado do operador numérico é do
            tipo int. Neste caso, o operando que não for do tipo int tem
            seu valor promovido para um do tipo int.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="224" qi="1" tipo="lógico">
		<introducao>Os operadores inteiros não geram exceção que
            represente overflow.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="225" qi="1" tipo="lógico">
		<introducao>Os operadores inteiros não gera exceção que
            represente underflow.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="226" qi="1" tipo="lógico">
		<introducao>Os únicos operadores numéricos que geram exceção são
            os operadores inteiros / e % quando o operando da direita é
            zero. Nestes casos, a exceção ArithmeticException é gerada.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="227" qi="1" tipo="lógico">
		<introducao>Qualquer valor de um tipo inteiro pode ser
            convertido (cast) para ou de querquer tipo numérico.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="228" qi="1" tipo="lógico">
		<introducao>Não existe nenhum tipo de conversão entre os tipos
            inteiros e o tipo <stmt>boolean</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="229" qi="1" tipo="lógico">
		<introducao>Uma máquina virtual é um software que executa
            código. Em particular, a máquina virtual Java, ou JVM,
            executa código escrito em <it>bytecode</it>s, geralmente
            obtido através da compilação de código fonte em Java.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="230" qi="1" tipo="lógico">
		<introducao>Pode-se afirmar que a programação dita procedural
            enfatiza a ordenação temporal (seqüencia) de passos
            executados pelo código, ao passo que a programação orientada
            a objetos orienta-se para a criação de objetos que trocam
            mensagens entre eles.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="231" qi="1" tipo="lógico">
		<introducao>Objetos que não mais possuem referências para eles
            podem ser removidos da memória automaticamente pelo garbage collector.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="232" qi="1" tipo="lógico">
		<introducao>A máquina virtual Java executa código em Java.</introducao>
		<resposta valor="f">Uma JVM executa código em
            <it>bytecode</it>s, obtidos através do processo de
            compilação de código fonte em Java.</resposta>
	</questao>
	<questao id="233" qi="1" tipo="lógico">
		<introducao>Um applet reside em um servidor Web. A execução de
            um applet, por outro lado, ocorre em um cliente, que executa
            um browser, através do qual provavelmente ocorreu o download
            do applet.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="234" qi="1" tipo="lógico">
		<introducao>A linguagem de programação Java é dita
            &quot;independente de plataforma&quot; porque permite a
            criação de programas que podem ser executados em várias plataformas.</introducao>
		<resposta valor="v">Um programa escrito em Java pode
            ser executado em várias plataformas. A rigor, tantas quantas
            forem as implementações disponíveis do ambiente de execução Java.</resposta>
	</questao>
	<questao id="235" qi="1" tipo="lógico">
		<introducao>Pode-se dizer que Java baseia-se, em parte, nas
            construções da linguagem de programação C++.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="236" qi="1" tipo="lógico">
		<introducao>Toda classe que se escreve em Java possui uma superclasse.</introducao>
		<resposta valor="v">Observe que toda classe em Java é
            descendente da classe <stmt>Object</stmt>.</resposta>
	</questao>
	<questao id="237" qi="1" tipo="lógico">
		<introducao>O atributo de um objeto pode ser uma referência para
            outro objeto ou para o próprio objeto que contém o atributo.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="238" qi="1" tipo="lógico">
		<introducao>Um objeto é uma instância de uma classe.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="239" qi="1" tipo="lógico">
		<introducao>A linguagem de programação Java é dita &quot;case
            sensitive&quot;, ou seja, uma linguagem cujos
            identificadores consideram a existência de letras maiúsculas
            e minúsculas como letras distintas. Por exemplo, os
            identificadores &quot;A&quot; e &quot;a&quot; são
            identificadores distintos, da mesma forma que
            &quot;soldo&quot; e &quot;Soldo&quot;.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="240" qi="1" tipo="lógico">
		<introducao>Em Java, se uma classe pública é definida, então
            esta classe deve estar descrita em uma arquivo cujo nome é
            formado pelo identificador desta classe pública com a
            extensão &quot;.java&quot;.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="241" qi="1" tipo="lógico">
		<introducao>Comentários em Java devem ser escritos sempre que se
            desejar que o código correspondente seja executado com mais eficiência.</introducao>
		<resposta valor="f">Comentários em Java são tratados pelo
            compilador como um espaço em branco e, portanto, não possuem
            nenhuma função semântica.</resposta>
	</questao>
	<questao id="242" qi="1" tipo="lógico">
		<introducao>Todo programa em Java inicia-se por um método
            especial chamado main.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="243" qi="1" tipo="lógico">
		<introducao>Uma sintaxe válida do método especial main é
            &quot;public static void main(<stmt>String</stmt> [] args)&quot;.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="244" qi="1" tipo="lógico">
		<introducao>Uma sintaxe válida do método especial main é
            &quot;static public void main(<stmt>String</stmt> args[])&quot;.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="245" qi="1" tipo="lógico">
		<introducao>Uma sintaxe válida do método especial main é
            &quot;static public void main(<stmt>String</stmt> []$i)&quot;.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="246" qi="1" tipo="lógico">
		<introducao>Existem várias sintaxes válidas para o método
            especial main através do qual a JVM inicia a execução de um
            programa em Java. Apesar de alguma flexibilidade,
            necessariamente tal método deve possuir como identificador
            &quot;main&quot;; o retorno deve ser &quot;void&quot;; o
            argumento é um <stmt>array</stmt> de <stmt>String</stmt> e,
            por último, deve possuir dois modificadores:
            &quot;public&quot; e &quot;static&quot;.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="247" qi="1" tipo="lógico">
		<introducao>Um único método especial main através do qual uma
            aplicação em Java é iniciada pode estar disponível em um programa.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="248" qi="1" tipo="lógico">
		<introducao>Variáveis em Java são empregadas por vários motivos.
            Entre eles, reter um valor ou uma referência para um objeto,
            por exemplo.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="249" qi="1" tipo="lógico">
		<introducao>Valores são armazenados, empregando-se a linguagem
            de programação Java, principalmente através do emprego de
            tipos primitivos. Existem oito tipos primitivos em Java:
            <stmt>byte</stmt>, <stmt>short</stmt>, <stmt>int</stmt>,
            <stmt>long</stmt>, <stmt>float</stmt>, <stmt>double</stmt>,
            <stmt>char</stmt> e <stmt>boolean</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="250" qi="1" tipo="lógico">
		<introducao>Valores são armazenados, empregando-se a linguagem
            de programação Java, principalmente através do emprego de
            tipos primitivos. Existem nove tipos primitivos em Java:
            <stmt>byte</stmt>, <stmt>short</stmt>, <stmt>int</stmt>,
            <stmt>long</stmt>, <stmt>float</stmt>, <stmt>double</stmt>,
            <stmt>char</stmt>, <stmt>boolean</stmt> e <stmt>void</stmt>.</introducao>
		<resposta valor="f">A palavra reservada &quot;void&quot; não
            é um tipo primitivo. Representa a ausência de valor.</resposta>
	</questao>
	<questao id="251" qi="1" tipo="lógico">
		<introducao>Todos os tipos primitivos de Java dão origem a
            variáveis que ocupam um número múltiplo de 8 bits.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="252" qi="1" tipo="lógico">
		<introducao>Variáveis em Java devem necessariamente ser
            declaradas antes de utilizadas.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="253" qi="1" tipo="lógico">
		<introducao>Variáveis locais (declaradas no interior de um
            método) devem necessariamente ser iniciadas explicitamente
            antes de utilizadas.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="254" qi="1" tipo="lógico">
		<introducao>Heap é uma área da memória usada para alocação
            dinâmica de memória por um programa. Em geral, blocos de
            memória de tamanhos desconhecidos, em tempo de compilação,
            são alocados e liberados em uma ordem arbitrária.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="255" qi="1" tipo="lógico">
		<introducao>Stack é uma área da memória usada para armazenar
            informações utilizadas por um &quot;curto&quot; período de
            tempo como as variáveis locais a um método.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="256" qi="1" tipo="lógico">
		<introducao>Em uma atribuição envolvendo duas variáveis de tipos
            distintos, onde há perda de precisão, o compilador
            simplesmente não compila o programa que contém a atribuição
            (um erro é gerado).</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="257" qi="1" tipo="lógico">
		<introducao>Em Java, os identificadores &quot;salário&quot; e
            &quot;salario&quot; são considerados iguais.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="258" qi="1" tipo="lógico">
		<introducao>Em Java, os identificadores &quot;Salario&quot; e
            &quot;salario&quot; são considerados iguais.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="259" qi="1" tipo="lógico">
		<introducao>Após a execução da sentença &quot;int a = 0; int b =
            ++a;&quot;, o resultado da soma do valor de a com o valor de
            b é 1.</introducao>
		<resposta valor="f">O valor de a é incrementado de uma
            unidade, tornando-se 1, que é o valor atribuído a b e, dessa
            forma, a + b é igual a 2.</resposta>
	</questao>
	<questao id="260" qi="1" tipo="lógico">
		<introducao>Na sentença &quot;Se a ligação ocorre após 22h,
            então o preço é mais baixo. Se for iniciada antes das 22h ou
            às 22h00min a tarifa é normal&quot;, os operadores
            relacionais e lógicos envolvidos, respectivamente, são > e &lt;=.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="261" qi="1" tipo="lógico">
		<introducao>Deve-se usar o método &quot;equals&quot; para testar
            se as <stmt>String</stmt>s de duas referências são iguais. O
            operador == quando aplicado a referências, independente do
            tipo, retorna verdadeiro se e somente se as referências são
            de um mesmo objeto.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="262" qi="1" tipo="lógico">
		<introducao>Atributos públicos de um objeto não podem ser
            alterados por métodos privados deste objeto.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="263" qi="1" tipo="lógico">
		<introducao>Atributos privados de um objeto não podem ser
            alterados por métodos públicos de um objeto.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="264" qi="1" tipo="lógico">
		<introducao>O escopo de uma variável refere-se à região de um
            programa em que a variável é visível.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="265" qi="1" tipo="lógico">
		<introducao>Construtores podem ser sobrecarregados (<it>overloaded</it>).</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="266" qi="1" tipo="lógico">
		<introducao>Final e final são identificadores distintos em Java.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="267" qi="1" tipo="lógico">
		<introducao>Identificadores em Java podem ser de no máximo 64
            bits (8 bytes).</introducao>
		<resposta valor="f">Identificadores não se confundem com os
            tipos das variáveis aos quais estes estão associados. Em
            Java, um identificador pode ser de tamanho arbitrário.</resposta>
	</questao>
	<questao id="268" qi="1" tipo="lógico">
		<introducao>Se uma classe X não sobrepõe (override) o método
            &quot;equals&quot;, então instâncias desta classe não podem
            ser utilizadas como chave em uma hashtable.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="269" qi="1" tipo="lógico">
		<introducao>O padrão IEEE 754 inclui não apenas números
            positivos e negativos mas também um zero positivo, um zero
            negativo, um infinito positivo,um infinito negativo e
            valores especiais Not-a-Number (NaN).</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="270" qi="1" tipo="lógico">
		<introducao>O valor infinito positivo e o infinito negativo
            representam valores distintos.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="271" qi="1" tipo="lógico">
		<introducao>O valor zero positivo e o valor zero negativo
            representam um mesmo valor (zero).</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="272" qi="1" tipo="lógico">
		<introducao>Os valores em ponto flutuante estão ordenados, desde
            o menor até o maior. Excetua-se os valores NaN.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="273" qi="1" tipo="lógico">
		<introducao>Existe um maior valor em ponto flutuante do tipo
            float que é finito.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="274" qi="1" tipo="lógico">
		<introducao>Existe o valor em ponto flutuante do tipo float que
            representa o valor infinito positivo.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="275" qi="1" tipo="lógico">
		<introducao>Existe um menor valor positivo diferente de zero do
            tipo float. Este valor é representado pela constante Float.MIN_VALUE.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="276" qi="1" tipo="lógico">
		<introducao>O valor resultante de 1.0/0.0 representa o infinito positivo.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="277" qi="1" tipo="lógico">
		<introducao>O valor resultante de 1.0/-0.0 representa o infinito negativo.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="278" qi="1" tipo="lógico">
		<introducao>Os operadores numéricos de comparação &lt;, &lt;=, >
            e >= retornam falso se um ou ambos os operandos são NaN.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="279" qi="1" tipo="lógico">
		<introducao>A expressão lógica <stmt>Float.NaN ==
            Float.NaN</stmt> é verdadeira.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="280" qi="1" tipo="lógico">
		<introducao><![CDATA[A expressão lógica <stmt>Float.NaN >= Float.NaN</stmt> é verdadeira.]]></introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="281" qi="1" tipo="lógico">
		<introducao>A expressão lógica Float.NaN != Float.NaN representa
            um valor falso.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="282" qi="1" tipo="lógico">
		<introducao>O operador de desigualdade != retorna verdadeiro se
            um ou ambos os operandos é ou são NaN.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="283" qi="1" tipo="lógico">
		<introducao>A expressão x != x pode ser verdadeira, dependendo
            do valor armazenado em x.</introducao>
		<resposta valor="v">Se x contém um NaN, então a
            desigualdade é verdadeira.</resposta>
	</questao>
	<questao id="284" qi="1" tipo="lógico">
		<introducao>A expressão x == x pode ser falsa, dependendo do
            valor armazenado em x.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="285" qi="1" tipo="lógico">
		<introducao>Se pelo menos um dos operandos de um operador
            binário é do tipo ponto flutuante, então a operação é uma
            operação de ponto flutuante, mesmo que o outro operando seja
            de um tipo inteiro.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="286" qi="1" tipo="lógico">
		<introducao>Se pelo menos um dos operandos de um operador
            numérico é do tipo double, então a operação é realizada
            utilizando-se a aritimética de ponto flutuante de 64 bits. O
            resultado da operação é do tipo double. Se um dos operandos
            não é do tipo double, então este operando é convertido para
            o tipo double.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="287" qi="1" tipo="lógico">
		<introducao>Se nenhum dos operandos de um operador é do tipo
            double e pelo menos um deles é um número ponto flutuante,
            então a operação é realizada utilizando-se a aritmética de
            ponto flutuante de 32 bits. Neste caso, se há um operando
            que não é do tipo float, então este é primeiro promovido
            para float, antes que a operação seja realizada.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="288" qi="1" tipo="lógico">
		<introducao>Operadores de ponto flutuante não produzem exceções.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="289" qi="1" tipo="lógico">
		<introducao>A expressão 1.0/0 não gera exceção.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="290" qi="1" tipo="lógico">
		<introducao>A expressão 1/0 gera exceção.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="291" qi="1" tipo="lógico">
		<introducao>A moldagem de um valor do tipo <stmt>boolean</stmt>
            só é permitida para o tipo <stmt>boolean</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="292" qi="1" tipo="lógico">
		<introducao>Um valor do tipo <stmt>boolean</stmt> pode ser
            convertido para uma <stmt>String</stmt> da mesma forma que
            uma <stmt>String</stmt> pode ser convertida para um valor
            correspondente do tipo <stmt>boolean</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="293" qi="1" tipo="lógico">
		<introducao>Um objeto é uma instância de uma classe ou um <stmt>array</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="294" qi="1" tipo="lógico">
		<introducao>Uma instância de uma interface é um objeto.</introducao>
		<resposta valor="f">Não se pode criar instância de uma
            interface, mas apenas de classes.</resposta>
	</questao>
	<questao id="295" qi="1" tipo="lógico">
		<introducao>Um <stmt>array</stmt> é um objeto.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="296" qi="1" tipo="lógico">
		<introducao>Uma referência é um valor que identifica um objeto.
            Há uma referência <stmt>null</stmt> que não se refere a
            objeto algum.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="297" qi="1" tipo="lógico">
		<introducao>Classe que contém o método <stmt>finalize</stmt>
            necessariamente não é uma classe abstrata.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="298" qi="1" tipo="lógico">
		<introducao>Qualquer caractere UNICODE pode ser utilizado em um
            comentário em Java.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="299" qi="1" tipo="lógico">
		<introducao>Um identificador em Java pode se iniciar pelo
            símbolo <stmt>$</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="300" qi="1" tipo="lógico">
		<introducao>Um identificador em Java pode se iniciar pelo
            símbolo <stmt>_</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="301" qi="1" tipo="lógico">
		<introducao>Programa em Java que faz uso de <stmt>const</stmt>
            e/ou <stmt>goto</stmt> provoca erro em tempo de compilação.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="302" qi="1" tipo="lógico">
		<introducao>O código abaixo compila sem erros.   <java> public
                class Teste {     public static void main(String[] args)
                {} }</java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="303" qi="1" tipo="lógico">
		<introducao>Uma nova instância da classe <stmt>String</stmt> é
            implicitamente criada quando quando o operador de
            concatenação <stmt>+</stmt> é utilizado, como na sentença
            <stmt>(&quot;a&quot;+&quot;b&quot;).toUpperCase()</stmt> que
            envolve 4 instâncias de <stmt>String</stmt>. As duas strings
            <stmt>&quot;a&quot;</stmt> e <stmt>&quot;b&quot;</stmt>,
            aquela resultante da concatenação e aquela
            <stmt>&quot;AB&quot;</stmt>, criada pelo método <stmt>toUpperCase()</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="304" qi="1" tipo="lógico">
		<introducao>Um novo objeto <it>array</it> é criado
            implicitamente quando uma expressão de inicialização de
            <it>array</it> é avaliada. Por exemplo, <stmt>String [] strs
                = { &quot;a&quot;, &quot;b&quot; }</stmt> cria
            implicitamente o <it>array</it> de objetos
            <stmt>String</stmt> com dois componentes.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="305" qi="1" tipo="lógico">
		<introducao>Todo objeto possui um <it>lock</it> associado
            através do qual é controlado o acesso concorrente por
            múltiplos <it>threads</it>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="306" qi="1" tipo="lógico">
		<introducao>A classe <stmt>Object</stmt> é a superclasse de
            todas as classes em Java.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="307" qi="1" tipo="lógico">
		<introducao>Uma variável do tipo <stmt>Object</stmt> retém uma
            referência para qualquer objeto, seja instância de uma
            classe ou um <it>array</it>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="308" qi="1" tipo="lógico">
		<introducao>O método <stmt>getClass</stmt> retorna um objeto
            <stmt>Class</stmt> que representa a classe de um objeto.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="309" qi="1" tipo="lógico">
		<introducao>Existe um objeto do tipo <stmt>Class</stmt> para
            cada tipo de referência. Este objeto pode ser usado para
            descobrir o nome completo de uma classe, seus membros, sua
            superclasse imediata e as interfaces que implementa.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="310" qi="1" tipo="lógico">
		<introducao>Instâncias da classe <stmt>String</stmt> representam
            seqüências de caracteres UNICODE.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="311" qi="1" tipo="lógico">
		<introducao>A sentença <stmt>import doc.texto.Formata</stmt>
            declara o tipo <stmt>Formata</stmt>, importado do tipo
            <stmt>doc.texto.Formata</stmt>, contido no <it>package</it>
            denominado de <stmt>doc.texto</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="312" qi="1" tipo="lógico">
		<introducao>Uma variável é um espaço de armazenamento com um
            tipo associado, que é um tipo primitivo ou um tipo de referência.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="313" qi="1" tipo="lógico">
		<introducao>Uma variável do tipo referência retém ou o valor
            <stmt>null</stmt> ou uma referência para qualquer objeto
            cuja classe é compatível com a atribuição ao tipo da variável.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="314" qi="1" tipo="lógico">
		<introducao>Uma variável de um tipo primitivo sempre retém um
            valor do tipo primitivo correspondente.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="315">
		<introducao>Uma variável de classe pode ser declarada em uma
            classe declarado com a palavra reservada <stmt>static</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="316">
		<introducao>Uma variável de classe pode ser declarada em uma
            interface (<stmt>interface</stmt>) e, neste caso, não é
            necessário o emprego da palavra reservada <stmt>static</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="317">
		<introducao>Uma variável de classe cessa a sua existência quando
            a classe ou interface correspondente é descarregada (<it>unloaded</it>).</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="318">
		<introducao>Uma variável de instância é um campo de uma classe
            declarado sem o emprego da palavra reservada <stmt>static</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="319">
		<introducao>Se uma classe <stmt>C</stmt> possui um campo
            <stmt>c</stmt> que é uma variável de instância, então uma
            nova instância da variável <stmt>c</stmt> é criada e
            iniciada com um valor <it>default</it> como parte de cada
            objeto criado da classe <stmt>C</stmt> ou de qualquer classe
            que é descendente de <stmt>C</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="320">
		<introducao>Componentes de um <it>array</it>, conhecidos em
            inglês pelo termo <it>array components</it>, são variáveis
            anônimas criadas e iniciadas com valores <it>default</it>
            sempre que um objeto que é um <it>array</it> é criado.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="321">
		<introducao>Quando um <it>array</it> não é mais referenciado,
            todos os componentes que dele fazem parte têm suas
            existências finalizadas.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="322">
		<introducao>Parâmetros de um mêtodo são valores passados a um método.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="323">
		<introducao>Toda vez que um método <stmt>M</stmt> é chamado
            (<it>invoked</it>) cada um dos parâmetros deste método dá
            origem a uma nova variável, que é iniciada com o
            correspondente valor da chamada.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="324">
		<introducao>As variáveis criadas para reter os argumentos
            fornecidos durante a chamada de um método, cada uma delas
            correspondentes a um argumento deste método, deixam de
            existir quando não mais há o que executar no corpo do método
            em questão.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="325">
		<introducao>O parâmetro de um tratador de exceção, ou
                <it>exception-handler parameter</it>, é criado toda vez
            que uma exceção é capturada por uma cláusula
            <stmt>catch</stmt> de uma sentença <stmt>try</stmt>. A nova
            variável criada é iniciada com o objeto associado com a
            exceção. O parâmetro cessa a sua existência quando a
            execução do bloco <stmt>catch</stmt> é finalizada.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="326">
		<introducao>Variáveis locais são declaradas no corpo de métodos,
            por exemplo.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="327">
		<introducao>Toda vez que o fluxo de controle entra em um bloco
            (delimitado por <stmt>{</stmt> e <stmt>}</stmt>) ou uma
            sentença <stmt>for</stmt>, uma nova variável é criada para
            cada variável local declarada no interior do bloco ou
            sentença <stmt>for</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="328">
		<introducao>O valor de uma variável local não pode ser utilizado
            se a variável correspondente não foi iniciada ou se um valor
            não foi atribuído à variável em questão.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="329">
		<introducao>Uma variável local tem sua existência finalizada
            quando é terminada a execução do bloco ou sentença
            <stmt>for</stmt> correspondente.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="330">
		<introducao>A variável <stmt>x</stmt> é uma variável
                local.<java> public class X {     static int x = 1; }</java>
		</introducao>
		<resposta valor="f">Não. Trata-se de uma variável de classe.</resposta>
	</questao>
	<questao id="331">
		<introducao>A variável <stmt>i</stmt>, declarada no código
            abaixo é dita uma variável de instância.<java> public class
                I {     int i; }</java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="332">
		<introducao>Para o código fornecido abaixo pode-se afirmar que
            <stmt>a[1]</stmt> é um componente de um <it>array</it>.<java><![CDATA[public class I {
    int a[] = new int[2];
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="333">
		<introducao>Uma variável pode ser declarada <stmt>final</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="334">
		<introducao>Dado o trecho de código abaixo, pode-se afirmar que
            a variável <stmt>x</stmt> é uma variável declarada como
                <stmt>final</stmt>.<java> x = 2; x = x + 3;</java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="335">
		<introducao>Uma variável declarada como <stmt>final</stmt> só
            pode participar do lado esquerdo de uma atribuição uma única vez.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="336">
		<introducao>Após a inicialização de uma variável
            <stmt>final</stmt> com um valor, esta variável sempre
            conterá este valor</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="337">
		<introducao>A declaração de uma variável como <stmt>final</stmt>
            significa que o valor correspondente, atribuído a esta
            variável, não será alterado ao longo de toda a existência
            desta variável.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="338">
		<introducao>Um objeto referenciado por uma variável declarada
            como <stmt>final</stmt> pode alterar os valores de seus campos.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="339">
		<introducao>O código abaixo produz um erro de compilação, pois
            tenta-se alterar o valor de uma variável declarada como <stmt>final</stmt>.<java><![CDATA[
class Final {
    public int i = 0;
    public void M() {
        final Final f = new Final();
        f.i = 2;
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="340">
		<introducao>Toda variável de classe, variável de instância ou
            componente de <it>array</it> é iniciado com um valor
            <it>default</it> quando é criada.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="341">
		<introducao>O valor <it>default</it> para uma variável do tipo
            <stmt>byte</stmt> é zero, ou seja, o valor <stmt>(byte)0</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="342">
		<introducao>O valor <it>default</it> para uma variável do tipo
            <stmt>short</stmt> é zero, ou seja, o valor <stmt>(short)0</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="343">
		<introducao>O valor <it>default</it> para uma variável do tipo
            <stmt>int</stmt> é zero, ou seja, o valor <stmt>0</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="344">
		<introducao>O valor <it>default</it> para uma variável do tipo
            <stmt>long</stmt> é zero, ou seja, o valor
            <stmt>(long)0</stmt>, ou <stmt>0l</stmt> ou <stmt>0L</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="345">
		<introducao>O valor <it>default</it> para uma variável do tipo
            <stmt>float</stmt> é zero, ou seja, o valor
            <stmt>0.0f</stmt>, ou <stmt>(float)0</stmt>, ou <stmt>0.0F</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="346">
		<introducao>O valor <it>default</it> para uma variável do tipo
            <stmt>double</stmt> é zero, ou seja, o valor
            <stmt>(double)0</stmt>, ou <stmt>0.0</stmt>, ou
            <stmt>0.0D</stmt> ou <stmt>0.0d</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="347">
		<introducao>O valor <it>default</it> para uma variável do tipo
            <stmt>char</stmt> é o caractere nulo, ou seja, <stmt>'\u0000'</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="348">
		<introducao>O valor <it>default</it> para uma variável do tipo
            <stmt>boolean</stmt> é falso, ou seja, <stmt>false</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="349">
		<introducao>O valor <it>default</it> para uma variável do tipo
            referência é o valor <stmt>null</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="350">
		<introducao>Toda variável correspondente a um parâmetro de um
            método é iniciada com o valor do correspondente argumento
            fornecido durante a chamada do método</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="351">
		<introducao>Antes de se fazer uso de uma variável local, um
            valor deve ser explicitamente atribuído à variável.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="352">
		<introducao>Valores <it>default</it> não são empregados em
            variáveis locais.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="353">
		<introducao>Em Java, toda variável e toda expressão possui um
            tipo que pode ser determinado em tempo de compilação.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="354">
		<introducao>Uma expressão ou uma variável pode ter como tipo um
            dos tipos primitivos ou o tipo referência.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="355">
		<introducao>Os tipos referência incluem os tipos classes e os
            tipos interfaces.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="356">
		<introducao>Diz-se que um objeto é uma instância da classe
            correspondente e de todas as superclasses desta classe.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="357">
		<introducao>Pode-se dizer, para a sentença <stmt>P p = new
            P()</stmt>, que <stmt>p</stmt> é uma variável do tipo
            <stmt>P</stmt> cujo valor inicial é uma referência para a
            nova instância criada da classe <stmt>P</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="358">
		<introducao>Se a classe <stmt>Quadrado</stmt> é derivada da
            classe <stmt>Quadrilátero</stmt>, <stmt>a</stmt> é uma
            variável que retém uma referência para um objeto do tipo
            <stmt>Quadrado</stmt> e <stmt>b</stmt> é uma variável que
            armazena uma referência para uma instância de
            <stmt>Quadrilátero</stmt>, então pode-se afirmar que a
            atribuição <stmt>b=a</stmt> é válida, enquanto a atribuição
            <stmt>a=b</stmt> não é permitida em Java.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="359">
		<introducao>Uma variável <stmt>v</stmt> do tipo referência, em
            particular, tipo interface <stmt>I</stmt>, pode reter como
            valor qualquer referência para um objeto cuja classe
            implementa a interface <stmt>I</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="360">
		<introducao>A sentença <stmt>ICor ic = new ICor()</stmt> é
            inválida se <stmt>ICor</stmt> é uma interface.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="361">
		<introducao>Não se pode criar instâncias de interfaces.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="362">
		<introducao>Instâncias de classes podem ser criadas através do
            emprego do operador <stmt>new</stmt>.</introducao>
		<resposta valor=""/>
	</questao>
	<questao id="363">
		<introducao>Todo <it>array</it> possui uma classe
            correspondente. O método <stmt>getClass</stmt> quando
            aplicado a um <it>array</it> retorna o objeto da classe
            <stmt>Class</stmt> que representa a classe do <it>array</it>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="364">
		<introducao>A conversão de um valor do tipo <stmt>float</stmt>
            para o tipo <stmt>double</stmt> não perde informação. A
            conversão no sentido inverso pode ocasionar perda de precisão.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="365">
		<introducao>Conversão de atribuição e de invocação de método
            nunca gera exceção.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="366">
		<introducao>A conversão por moldagem (<it>casting</it>) pode
            gerar exceção em tempo de execução.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="367">
		<introducao>A conversão de um tipo para o mesmo tipo é permitida
            para qualquer que seja o tipo.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="368">
		<introducao>Toda expressão é sujeita à conversão de tipo.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="369">
		<introducao>A única conversão envolvendo o tipo
            <stmt>boolean</stmt> é a conversão de <stmt>boolean</stmt>
            para o próprio <stmt>boolean</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="370">
		<introducao>Conversão do tipo <stmt>byte</stmt> para o tipo
            <stmt>short</stmt> não envolve perda de informação.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="371">
		<introducao>Conversão do tipo <stmt>byte</stmt> para o tipo
            <stmt>int</stmt> não envolve perda de informação.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="372">
		<introducao>Conversão do tipo <stmt>byte</stmt> para o tipo
            <stmt>long</stmt> não envolve perda de informação.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="373">
		<introducao>Conversão do tipo <stmt>float</stmt> para o tipo
            <stmt>double</stmt> não envolve perda de informação.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="374">
		<introducao>Conversão do tipo <stmt>short</stmt> para o tipo
            <stmt>double</stmt> não envolve perda de informação.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="375">
		<introducao>Conversão do tipo <stmt>short</stmt> para o tipo
            <stmt>float</stmt> não envolve perda de informação.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="376">
		<introducao>Conversão do tipo <stmt>short</stmt> para o tipo
            <stmt>int</stmt> não envolve perda de informação.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="377">
		<introducao>Conversão do tipo <stmt>char</stmt> para o tipo
            <stmt>int</stmt> não envolve perda de informação.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="378">
		<introducao>Conversão do tipo <stmt>char</stmt> para o tipo
            <stmt>long</stmt> não envolve perda de informação.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="379">
		<introducao>Conversão do tipo <stmt>char</stmt> para o tipo
            <stmt>float</stmt> não envolve perda de informação.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="380">
		<introducao>Conversão do tipo <stmt>char</stmt> para o tipo
            <stmt>double</stmt> não envolve perda de informação.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="381">
		<introducao>Conversão do tipo <stmt>int</stmt> para o tipo
            <stmt>long</stmt> não envolve perda de informação.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="382">
		<introducao>Conversão do tipo <stmt>int</stmt> para o tipo
            <stmt>float</stmt> não envolve perda de informação.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="383">
		<introducao>Conversão do tipo <stmt>int</stmt> para o tipo
            <stmt>double</stmt> não envolve perda de informação.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="384">
		<introducao>Conversão do tipo <stmt>long</stmt> para o tipo
            <stmt>float</stmt> não envolve perda de informação.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="385">
		<introducao>As conversões entre tipos primitivos podem causar
            perda de precisão, por exemplo, do tipo <stmt>int</stmt>
            para o tipo <stmt>float</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="386">
		<introducao>Conversões entre tipos primitivos do tipo
            <it>widening</it>, apesar da possível perda de informação,
            não geram exceções em tempo de execução.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="387">
		<introducao>Conversão do tipo <stmt>float</stmt> para o tipo
            <stmt>double</stmt> não envolve perda de informação.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="388">
		<introducao>Uma conversão do tipo <it>narrowing</it> de um
            inteiro com sinal para um tipo inteiro <it>T</it>
            simplesmente discarta todos os bits que não fazem parte dos
            <it>n</it> bits de menor ordem de <it>T</it>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="389">
		<introducao>Valores do tipo <stmt>char</stmt>, mesmo sendo
            inteiros sem sinal, quando convertidos para um tipo inteiro
            (<it>narrowing</it>), podem resultar em um valor negativo.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="390">
		<introducao>A conversão de um valor em ponto-flutuante para um
            valor inteiro pode exigir duas conversões. Primeiro o valor
            em ponto-flutuante é convertido para o tipo
            <stmt>long</stmt> ou tipo <stmt>int</stmt>. Esta conversão
            segue a seguinte regra: (a) a conversão é para o tipo
            <stmt>long</stmt> se o tipo destino é do tipo
            <stmt>long</stmt>; (b) a conversão é para o tipo
            <stmt>int</stmt> se o tipo destino é <stmt>byte</stmt>,
            <stmt>short</stmt>, <stmt>int</stmt> ou <stmt>char</stmt>.
            Por último, se a conversão para o tipo destino é
            <stmt>long</stmt> ou <stmt>int</stmt>, então a conversão foi
            realizada completamente. Caso contrário, será necessário
            converter o tipo <stmt>int</stmt>, via <it>narrowing</it>,
            para o tipo desejado, ou seja, <stmt>byte</stmt>,
            <stmt>short</stmt> ou <stmt>char</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="391">
		<introducao>A tentativa de impressão do valor
            <stmt>0.0f/0.0F</stmt> gera uma exceção.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="392">
		<introducao>O resultado da impressão do valor
            <stmt>0.0/0.0D</stmt> é <stmt>NaN</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="393">
		<introducao>A execução de <stmt>Math.sqrt(-1)</stmt> gera uma exceção.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="394">
		<introducao>O resultado de <stmt>Math.sqrt(-1.0)</stmt> é <stmt>NaN</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="395">
		<introducao>O valor de <stmt>(int)(0.0/0.0D)</stmt> é o valor
            inteiro <stmt>0</stmt>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="396">
		<introducao>O valor de <stmt>(int)(0.0/0.0D)</stmt> é o valor
            inteiro <stmt>0L</stmt>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="397">
		<introducao>A expressão <stmt>(int)(1.0/0.0) ==
            Integer.MAX_VALUE</stmt> é verdadeira.</introducao>
		<resposta valor=""/>
	</questao>
	<questao id="398">
		<introducao>A expressão <stmt>(int)(-1.0/0.0) ==
            Integer.MIN_VALUE</stmt> é verdadeira.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="399">
		<introducao>A conversão entre referências não gera exceção
            quando se converte uma referência para um tipo classe
            <stmt>S</stmt> para o tipo classe <stmt>T</stmt> e
            <stmt>S</stmt> é subclasse de <stmt>T</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="400">
		<introducao>Não gera exceção a conversão de uma referência de um
            tipo <it>array</it>para uma do tipo classe <stmt>Object</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="401">
		<introducao>Não gera exceção a conversão de uma referência de um
            tipo <it>array</it>para uma do tipo classe <stmt>Cloneable</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="402">
		<introducao>Não gera exceção a conversão de uma referência de um
            tipo <it>array</it>para uma do tipo classe <stmt>java.io.Serializable</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="403">
		<introducao>Uma conversão de um valor de referência para outro
            pode gerar a exceção <stmt>ClassCastException</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="404">
		<introducao>A conversão de um valor de referência do tipo classe
            <stmt>Object</stmt>para o tipo <it>array</it> pode gerar a
            exceção <stmt>ClassCastException</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="405">
		<introducao>Há conversão para o tipo classe <stmt>String</stmt>
            de qualquer outro tipo, incluindo o tipo <stmt>null</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="406">
		<introducao>Não é permitida a conversão do tipo referência para
            qualquer tipo primitivo.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="407">
		<introducao>Não é permitida a conversão do tipo
            <stmt>null</stmt> para qualquer tipo primitivo.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="408">
		<introducao>A única conversão envolvendo o tipo
            <stmt>boolean</stmt> é aquela deste tipo para o próprio.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="409">
		<introducao>Excluindo-se a classe <stmt>String</stmt>, não
            existe nenhuma conversão envolvendo os tipos classe
            <stmt>S</stmt> e <stmt>T</stmt> se <stmt>S</stmt>não é
            subclasse de <stmt>T</stmt> ou <stmt>S</stmt> não é
            superclasse de <stmt>T</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="410">
		<introducao>Se a classe <stmt>S</stmt> é uma classe
            <stmt>final</stmt> e não implementa a interface
            <stmt>I</stmt>, então não é permitida a conversão do tipo
            referência da classe <stmt>S</stmt> para a interface <stmt>I</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="411">
		<introducao>Não é permitida a conversão do tipo classe
            <stmt>S</stmt> para qualquer tipo <it>array</it> se
            <stmt>S</stmt> não é <stmt>Object</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="412">
		<introducao>Não é permitida a conversão do tipo interface
            <stmt>J</stmt> para o tipo interface <stmt>K</stmt> se
            <stmt>J</stmt> e <stmt>K</stmt> contêm métodos com as mesmas
            assinaturas mas diferentes tipos de retorno.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="413">
		<introducao>Não é permitida a conversão de nenhum tipo
            <it>array</it> para qualquer tipo interface, exceto para os
            tipos interface <stmt>java.io.Serializable</stmt> e <stmt>Cloneable</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="414">
		<introducao>Todo e qualquer <it>array</it> implementa as
            interfaces <stmt>java.io.Serializable</stmt> e <stmt>Cloneable</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="415">
		<introducao>Quando se deseja implementar a linguagem de
            programação Java, há opções (decisões) de implementação que
            devem ser realizadas.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="416">
		<introducao>Toda implementação da linguagem de programação Java
            realiza, rigorosamente, os mesmos serviços funcionais
            através dos quais os mesmos resultados são obtidos,
            independente da implementação considerada.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="417">
		<introducao>Se o tipo de uma expressão não pode ser convertido
            para o tipo da variável do lado direito de uma atribuição,
            então um erro em tempo de compilação é gerado.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="418">
		<introducao>Uma atribuição pode gerar a exceção <stmt>ArrayStoreException</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="419">
		<introducao>A operação de moldagem (<it>casting</it>) da
            atribuição <stmt>byte umByte = (byte)20;</stmt> é permitida,
            mas não é obrigatória.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="420">
		<introducao>A atribuição <stmt>byte x = 20;</stmt> provoca um
            erro em tempo de compilação.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="421">
		<introducao>A atribuição <stmt>byte bValor = (int)45;</stmt>
            provoca um erro em tempo de compilação.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="422">
		<introducao>A atribuição <stmt>byte bValor = (int)45;</stmt>
            provoca um erro em tempo de execução.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="423">
		<introducao>Um valor de um tipo primitivo, qualquer que seja
            este, não pode ser atribuído a uma variável do tipo referência.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="424">
		<introducao>Um dos valores de tipos primitivos que pode ser
            atribuído a uma variável referência é a constante <stmt>null</stmt>.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="425">
		<introducao>A tentativa de atribuir um valor de um tipo
            primitivo a uma referência é verificado em tempo de execução.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="426">
		<introducao>Um valor do tipo <stmt>boolean</stmt> só pode ser
            atribuído a uma variável do tipo <stmt>boolean</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="427">
		<introducao>A atribuição <stmt>short s = (int)-10;</stmt> não é
            permitida em Java.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="428">
		<introducao>A atribuição <stmt>short s = (byte)-1;</stmt> não é
            permitida em Java.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="429">
		<introducao>A atribuição <stmt>short s = (char)65;</stmt> é
            permitida em Java.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="430">
		<introducao>Nem todo valor <stmt>short</stmt> também é um valor
            <stmt>char</stmt> e nem todo valor <stmt>char</stmt> também
            é um valor <stmt>short</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="431">
		<introducao>O valor <stmt>null</stmt> do tipo <stmt>null</stmt>
            é um dentre os valores comumente atribuídos a uma variável
            do tipo referência.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="432">
		<introducao>Em Java, o tipo <stmt>null</stmt> contém um único
            valor, a referência <stmt>null</stmt>. Comparando-o com o
            tipo primitivo <stmt>boolean</stmt>, pode-se dizer que o
            tipo <stmt>null</stmt> possui um domínio mais restrito, com
            um único valor, ao contrário dos dois valores possíveis para
            o tipo <stmt>boolean</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="433">
		<introducao>Um <it>array</it> de elementos do tipo primitivo
            <stmt>byte</stmt> pode ser atribuído a um <it>array</it>
            cujos elementos são do tipo <stmt>int</stmt>.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="434">
		<introducao>A atribuição de uma referência do tipo interface
            <stmt>O</stmt> para uma variável do tipo classe
            <stmt>D</stmt> é válida apenas se <stmt>D</stmt> for
            <stmt>Object</stmt>. Caso contrário, um erro em tempo de
            compilação ocorre.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="435">
		<introducao>O código abaixo é compilado com sucesso.<java><![CDATA[
interface O { void ok(); }

class D implements O {
    public void ok() {}
}

public class teste {
    public static void main(String[] args) {
	O obj = new D();
	Object oo = obj;
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="436">
		<introducao>O código abaixo é compilado com sucesso.<java><![CDATA[
interface O { void ok(); }

class D implements O {
    public void ok() {}
}

public class teste {
    public static void main(String[] args) {
	O obj = new D();
	D objD = obj;
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="437">
		<introducao>O código abaixo gera erro em tempo de compilação.<java><![CDATA[
interface O { void ok(); }

class D implements O {
    public void ok() {}
}

public class teste {
    public static void main(String[] args) {
	O obj = new D();
	D objD = (D)obj;
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="438">
		<introducao>O código abaixo é compilado com sucesso, mas gera um
            erro em tempo de execução.<java><![CDATA[
public class Teste {
    public static void main(String[] args) {
	long[] aLong = new long[100];
	Object o = aLong;
	((byte[])o)[1] = 2;
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="439">
		<introducao>O código abaixo é compilado com sucesso, mas gera um
            erro em tempo de execução.<java><![CDATA[
public class Teste {
    public static void main(String[] args) {
	long[] aLong = new long[100];
	Object o = aLong;
	((long[])o)[1] = 2;
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="440">
		<introducao>O código abaixo, embora seja compilado
            satisfatoriamente, gera a exceção
            <stmt>ClassCastException</stmt> em tempo de execução.<java><![CDATA[
public class Teste {
    public static void main(String[] args) {
	byte[] vecByte = new byte[100];
	Object o = vecByte;
	((int[])o)[1] = 2;
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="441">
		<introducao>O código abaixo é compilado com sucesso, mas gera um
            erro em tempo de execução.<java><![CDATA[
class Base {}
class Derivada extends Base {}

public class teste {
    public static void main(String[] args) {
	Base[] aBase = new Base[1];
	Derivada[] aDerivada = new Derivada[1];
	aBase = aDerivada;
    }
}]]></java>
		</introducao>
		<resposta valor="f">O código compila e é executado sem exceção.</resposta>
	</questao>
	<questao id="442">
		<introducao>O código abaixo, quando executado, gera a exceção <stmt>ArrayStoreException</stmt>.<java><![CDATA[
class Base {}
class Derivada extends Base {}

public class teste {
    public static void main(String[] args) {
	Base[] aBase = new Base[1];
	Derivada[] aDerivada = new Derivada[1];
	aBase = aDerivada;
	aBase[0] = new Base();
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="443">
		<introducao>O código abaixo gera a exceção
            <stmt>ArrayStoreException</stmt>, quando executado.<java><![CDATA[
class Base {}
class Derivada extends Base {}

public class teste {
    public static void main(String[] args) {
	Base[] aBase = new Base[1];
	Derivada[] aDerivada = new Derivada[1];
	aBase = aDerivada;
	aBase[0] = new Derivada();
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="444">
		<introducao>O código abaixo é compilado com sucesso.<java><![CDATA[
class Base {}
class Derivada extends Base {}

public class teste {
    public static void main(String[] args) {
	Base[] aBase = new Base[1];
	Derivada[] aDerivada = new Derivada[1];
	aDerivada = aBase;
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="445">
		<introducao>O código abaixo não é compilado com sucesso.<java><![CDATA[
class Base {}
class Derivada extends Base {}

public class teste {
    public static void main(String[] args) {
	Base[] aBase = new Base[1];
	Derivada[] aDerivada = new Derivada[1];
	aBase = aDerivada;
	aDerivada = (Derivada[])aBase;
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="446">
		<introducao>O código abaixo gera uma exceção em tempo de execução.<java><![CDATA[
class Base {}
class Derivada extends Base {}

public class teste {
    public static void main(String[] args) {
	Base[] aBase = new Base[1];
	Derivada[] aDerivada = new Derivada[1];
	aBase = aDerivada;
	aDerivada = (Derivada[])aBase;
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="447">
		<introducao>O código abaixo, quando executado, gera a exceção <stmt>ArrayStoreException</stmt>.<java><![CDATA[
class Base {}
class Derivada extends Base {}

public class teste {
    public static void main(String[] args) {
	Base[] aBase = new Base[1];
	Derivada[] aDerivada = new Derivada[1];
	aDerivada = (Derivada[])aBase;
    }
}]]></java>
		</introducao>
		<resposta valor="f">A exceção gerada é <stmt>ClassCastException</stmt>.</resposta>
	</questao>
	<questao id="448">
		<introducao>O operador <stmt>+</stmt> torna-se um operador de
            concatenação apenas quando um dos operandos é uma <stmt>String</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="449">
		<introducao>Quando um dos argumentos do operador <stmt>+</stmt>
            é uma <stmt>String</stmt>, caso o outro não seja, este será
            convertido para uma <stmt>String</stmt> e uma nova
            <stmt>String</stmt>, resultado da concatenação das duas
            <stmt>String</stmt>s envolvidas é produzida. </introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="450">
		<introducao>O operador de moldagem (<it>casting</it>) converte o
            valor da expressão (operando) em um valor do tipo fornecido
            pelo operador de moldagem.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="451">
		<introducao>A atribuição <stmt>X obj = (X)null;</stmt> não é válida.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="452">
		<introducao>A operação de moldagem (<it>casting</it>) exige
            validação em tempo de compilação.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="453">
		<introducao>A operação de moldagem (<it>casting</it>) não é
            validada em tempo de execução.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="454">
		<introducao>O código abaixo compila satisfatoriamente.<java><![CDATA[interface O {}
class Base {}
class Derivada extends Base implements O {}
final class Outra {}

public class teste {
    public static void main(String[] args) {
	Base aBase = new Base();
	Derivada aDerivada = new Derivada();
	O iO;
	aDerivada = (Derivada)aBase;
	iO = (O)aBase;
	iO = (O)(new Outra());
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="455">
		<introducao>O código abaixo compila satisfatoriamente.<java><![CDATA[interface O {}
class Base {}
class Derivada extends Base implements O {}
class Outra {}

public class teste {
    public static void main(String[] args) {
	Base aBase = new Base();
	Derivada aDerivada = new Derivada();
	O iO;
	aDerivada = (Derivada)aBase;
	iO = (O)aBase;
	iO = (O)(new Outra());
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="456">
		<introducao>O código abaixo não compila.<java><![CDATA[
interface O { void a(); }
class Base {}
class Derivada extends Base implements O { public void a() {} }

public class teste {
    public static void main(String[] args) {
	Base aBase = new Derivada();
	Derivada aDerivada;
	O iO;
	aDerivada = (Derivada)aBase;
	iO = (O)aBase;
	iO = (O)(new O(){ public void a() {} });
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="457">
		<introducao>O código abaixo gera a exceção
            <stmt>ClassCastException</stmt> quando  executado.<java><![CDATA[
interface O { void a(); }
class Base {}
class Derivada extends Base implements O { public void a() {} }

public class teste {
    public static void main(String[] args) {
	Base aBase = new Derivada();
	Derivada aDerivada;
	O iO;
	aDerivada = (Derivada)aBase;
	iO = (O)aBase;
	iO = (O)(new O(){ public void a() {} });
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="458">
		<introducao>Promoções numéricas (<it>numeric promotions</it>)
            referem-se às conversões de operandos de um operador
            numérico para um tipo comum de tal forma que a operação
            possa ser realizada.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="459">
		<introducao>A sentença <stmt>byte b = +4;</stmt> gera um erro de compilação.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="460">
		<introducao>Se o operando do operador unário <stmt>+</stmt> é </introducao>
		<resposta valor=""/>
	</questao>
	<questao id="461">
		<introducao>O código abaixo não compila.<java><![CDATA[
public class teste {
    public static void main(String[] args) {
	byte b1 = -4;
	byte b2 = (int)+(byte)4;
	System.out.println( "b1 + b2 = " + b1 + b2 );
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="462">
		<introducao>O código abaixo compila e, quando executado, exibe a
            mensagem <stmt>&quot;b1 + b2 = 0&quot;</stmt>
			<java><![CDATA[
public class teste {
    public static void main(String[] args) {
	byte b1 = -4;
	byte b2 = (int)+(byte)4;
	System.out.println( "b1 + b2 = " + b1 + b2 );
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="463">
		<introducao>O código abaixo compila e, quando executado, exibe a
            mensagem <stmt>&quot;b1 + b2 = -44&quot;</stmt>
			<java><![CDATA[
public class teste {
    public static void main(String[] args) {
	byte b1 = -4;
	byte b2 = (int)+(byte)4;
	System.out.println( "b1 + b2 = " + b1 + b2 );
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="464">
		<introducao>O operando do tipo <stmt>byte</stmt>,
            <stmt>short</stmt> ou <stmt>char</stmt>, em tempo de
            compilação, de um operador unário promove o valor
            correspondente para o tipo <stmt>int</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="465">
		<introducao>Para um operador binário, se um dos operandos é do
            tipo primitivo <stmt>double</stmt>, então o outro é
            convertido para o tipo <stmt>double</stmt> antes que a
            operação seja executada.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="466">
		<introducao>Para um operador binário, se nenhum operando é do
            tipo <stmt>double</stmt> e há um operando do tipo
            <stmt>float</stmt>, então o outro é convertido para
            <stmt>float</stmt> antes da execução da operação.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="467">
		<introducao>Para um operador binário, se nenhum operando é do
            tipo ponto-flutuante e há um operando do tipo
            <stmt>long</stmt>, então o outro é convertido para o tipo
            <stmt>long</stmt> antes que a operação seja realizada.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="468">
		<introducao>Para um operador binário, se ambos os operandos são
            inteiros e não são do tipo <stmt>long</stmt>, então ambos
            são convertidos para o tipo <stmt>int</stmt> antes que a
            operação seja executada.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="469">
		<introducao>Se a <stmt>String</stmt> produzida por
            <stmt>Integer.toHexString(~k+1)</stmt> é <stmt>80</stmt>,
            então pode-se afirmar que o valor decimal armazenado na
            variável <stmt>k</stmt> do tipo <stmt>byte</stmt> é <stmt>-128</stmt>
		</introducao>
		<resposta valor="v">O valor hexadecimal 80 representa o
            decimal 128.  Observe que 128 foi obtido por meio da negação
            bit a bit do valor em <stmt>k</stmt> seguido do posterior
            acréscimo de uma unidade, o que significa que o valor em
            <stmt>k</stmt> é -128, pois são estas as operações
            necessárias para se determinar o valor armazenado em uma
            variável inteira com sinal.</resposta>
	</questao>
	<questao id="470">
		<introducao>Em Java, nomes são empregados para se referir a
            entidades declaradas em um programa.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="471">
		<introducao>Um pacote (<it>package</it>), uma classe, uma
            interface, um método, um campo de interface ou classe,
            parâmetros de método, construtor ou tratador de exceção
                (<it>exception handler</it>) e uma variável local são
            exemplos de entidades em Java que são referenciadas pelos
            seus nomes.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="472">
		<introducao>Toda declaração que introduz um nome tem um escopo.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="473">
		<introducao>Escopo (<it>scope</it>) é o nome de uma parte do
            texto de um programa no qual uma entidade pode ser
            referenciada por um nome simples.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="474">
		<introducao>Controle de acesso pode ser especificado na
            declaração de uma classe, interface, método ou campo, para
            determinar quando o acesso à entidade em questão é permitida.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="475">
		<introducao>Controle de acesso e escopo são sinônimos.</introducao>
		<resposta valor="f">Escopo estabelece uma &quot;região&quot;
            de um programa onde uma entidade é conhecida pelo seu nome.
            Controle de acesso, por outro lado, é mecanismo para
            prevenir usuários de acesso desnecessário ou que se deve
            evitar a uma entidade.</resposta>
	</questao>
	<questao id="476">
		<introducao>Uma declaração introduz uma entidade em um programa
            e inclui um identificador. O identificador pode ser
            utilizado, em um nome, para fazer referência à entidade.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="477">
		<introducao>O campo <stmt>length</stmt> é um membro de todo tipo
            <it>array</it> e <stmt>String</stmt>.</introducao>
		<resposta valor="f">
			<stmt>String</stmt> não tem campo <stmt>length</stmt>, mas o
            método <stmt>length()</stmt>.</resposta>
	</questao>
	<questao id="478">
		<introducao>Um nome é usado para referenciar uma entidade
            declarada em um programa.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="479">
		<introducao>Há dois tipos de nomes em Java: nomes simples e
            nomes qualificados.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="480">
		<introducao>Em Java, um nome simples é um único identificador,
            que pode fazer uso da notação usando o ponto como em <stmt>java.lang.String</stmt>.</introducao>
		<resposta valor="f">O exemplo é de um nome qualificado.</resposta>
	</questao>
	<questao id="481">
		<introducao>Nem todos os identificadores em um programa são
            parte de um nome.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="482">
		<introducao>Um nome qualificado é uma seqüência de
            identificadores separados por pontos.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="483">
		<introducao>Membros de uma classe são declarados quando da
            declaração da classe ou são herdados.</introducao>
		<resposta valor="verdadeiros"/>
	</questao>
	<questao id="484">
		<introducao>Construtores não são membros.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="485">
		<introducao>Membros de uma classe incluem os construtores desta classe.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="486">
		<introducao>Uma classe não pode ter dois ou mais campos com os
            mesmos nomes simples.</introducao>
		<resposta valor="f">Basta que estes nomes sejam declarados
            em diferentes interfaces ou sejam herdados.</resposta>
	</questao>
	<questao id="487">
		<introducao>Dois métodos cujos tipos de retorno sejam distintos
            não possuem a mesma assinatura.</introducao>
		<resposta valor="f">O tipo de retorno não é relevante para a
            assinatura de um método.</resposta>
	</questao>
	<questao id="488">
		<introducao>Um pacote, em determinado contexto, pode não estar acessível.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="489">
		<introducao>Um membro declarado como <stmt>protected</stmt>
		</introducao>
		<resposta valor=""/>
	</questao>
	<questao id="490">
		<introducao>Exceto a classe <stmt>Object</stmt>, todas as demais
            são extensões (ou seja, são subclasses) de uma única classe</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="491">
		<introducao>Uma classe aninhada é uma classe cuja declaração
            ocorre no interior de outra classe ou de uma interface.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="492">
		<introducao>Uma classe de nível superior (<it>top level</it>) é
            uma classe que não é aninhada.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="493">
		<introducao>Uma classe que não é completamente implementada onde
            é declarada deve ser, necessariamente, declarada como <stmt>abstract</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="494">
		<introducao>Os modificadores de acesso explícitos incluem
            <stmt>public</stmt>, <stmt>protected</stmt> e <stmt>private</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="495">
		<introducao>Um construtor pode ser declarado <stmt>private</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="496">
		<introducao>Um construtor pode ser declarado <stmt>protected</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="497">
		<introducao>A declaração de uma classe possivelmente inclui zero
            ou mais dos modificadores <stmt>public</stmt>,
            <stmt>protected</stmt>, <stmt>private</stmt>,
            <stmt>strictfp</stmt>, <stmt>abstract</stmt>,
            <stmt>final</stmt> e <stmt>static</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="498">
		<introducao>Apenas classes declaradas como <stmt>abstract</stmt>
            podem conter métodos <stmt>abstract</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="499">
		<introducao>Uma classe que não é <stmt>abstract</stmt> e contém
            um método <stmt>abstract</stmt> gera um erro em tempo de compilação.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="500">
		<introducao>Uma classe derivada de uma classe
            <stmt>abstract</stmt> necessariamente deve implementar todos
            os métodos declarados como <stmt>abstract</stmt> da classe herdada.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="501">
		<introducao>Uma classe declarada como <stmt>final</stmt> não
            pode possuir subclasses.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="502">
		<introducao>Os métodos de uma classe <stmt>final</stmt> podem
            ser sobrepostos (<it>overriden</it>).</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="503">
		<introducao>
			<stmt>inherits</stmt> é palavra reservada de Java.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="504">
		<introducao>
			<stmt>protect</stmt> é palavra reservada.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="505">
		<introducao>
			<stmt>synchronize</stmt> é palavra reservada.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="506">
		<introducao>Pelo meno uma das palavras reservadas de Java possui
            uma letra maiúscula.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="507">
		<introducao/>
		<resposta valor=""/>
	</questao>
	<questao id="508">
		<introducao>
			<stmt>overload</stmt> é palavra reservada.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="509">
		<introducao>
			<stmt>unsigned</stmt> é palavra reservada.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="510">
		<introducao>
			<stmt>signed</stmt> é palavra reservada.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="511">
		<introducao>
			<stmt>virtual</stmt> é palavra reservada.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="512">
		<introducao>
			<stmt>friend</stmt> é palavra reservada.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="513">
		<introducao>
			<stmt>Private</stmt>, <stmt>Protected</stmt> e
            <stmt>Public</stmt> são palavras reservadas.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="514">
		<introducao>O código abaixo não compila.<java><![CDATA[abstract class A { 
    abstract void a(); 
}

abstract class B extends A { 
    void a() {} 
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="515">
		<introducao>O código abaixo compila.<java><![CDATA[class A { 
    abstract void a(); 
}

abstract class B extends A { 
    void a() {} 
}]]></java>
		</introducao>
		<resposta valor="f">Toda classe que contém um método
            <stmt>abstract</stmt> deve ser declarada
            <stmt>abstract</stmt> ou um erro em tempo de compilação é gerado.</resposta>
	</questao>
	<questao id="516">
		<introducao>Um método <stmt>abstract</stmt> de uma classe
            <stmt>X</stmt> deve ser implementado por uma classe derivada
            de <stmt>X</stmt> e que não é declarada <stmt>abstract</stmt>.</introducao>
		<resposta valor="f">Uma classe declarada
            <stmt>abstract</stmt> pode implementar um método declarado
            <stmt>abstract</stmt> de uma superclasse herdada.</resposta>
	</questao>
	<questao id="517">
		<introducao>Uma classe declarada </introducao>
		<resposta valor=""/>
	</questao>
	<questao id="518">
		<introducao>O código abaixo não compila.<java><![CDATA[abstract class A { 
    public int x;
    abstract void a(); 
}

abstract class B extends A { 
    void a() {} 
}

class C extends B {}

public class Teste {
    public static void main(String[] args) {
	Object o = new C();
	System.out.println(((A)o).x);
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="519">
		<introducao>O código abaixo, quando executado, gera a exceção <stmt>ClassCastException</stmt>.<java><![CDATA[abstract class A { 
    public int x;
    abstract void a(); 
}

abstract class B extends A { 
    void a() {} 
}

class C extends B {}

public class Teste {
    public static void main(String[] args) {
	Object o = new C();
	System.out.println(((A)o).x);
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="520">
		<introducao>O código abaixo, quando executado gera uma exceção
            decorrente da operação de moldagem (<it>casting</it>), pois
            a classe <stmt>A</stmt> é declarada como <stmt>abstract</stmt>.<java><![CDATA[abstract class A { 
    public int x;
    abstract void a(); 
}

class B extends A { 
    void a() {} 
}

public class Teste {
    public static void main(String[] args) {
	Object o = new B();
	A a = (A)o;
	System.out.println(a.x);
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="521">
		<introducao>Uma classe <stmt>X</stmt>, declarada
            <stmt>final</stmt>, não permite que instâncias sejam criadas
            da forma <stmt>new X()</stmt>. </introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="522">
		<introducao>Uma classe <stmt>X</stmt>, declarada
            <stmt>abstract</stmt>, não pode possuir subclasse.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="523">
		<introducao>Se uma classe declarada <stmt>abstract</stmt> é
            herdada por uma subclasse não declarada
            <stmt>abstract</stmt>, então a subclasse, em sua declaração,
            faz uso da palavra reservada <stmt>implements</stmt>.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="524">
		<introducao>Um método declarado <stmt>native</stmt> significa
            que está implementado na linguagem de programação C.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="525">
		<introducao>O código abaixo compila e, quando executado, imprime
            o valor zero na saída padrão.<java><![CDATA[class A { 
    public int x;
}

public class Teste extends A {
    public static void main(String[] args) {
	Object o = new Teste();
	A a = (A)o;
	System.out.println(a.x);
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="526">
		<introducao>O código abaixo compila.<java><![CDATA[native class A { 
    public int x;
}

public class Teste extends A {
    public static void main(String[] args) {
	Object o = new Teste();
	A a = (A)o;
	System.out.println(a.x);
    }
}]]></java>
		</introducao>
		<resposta valor="f">O modificador <stmt>native</stmt> só se
            aplica a métodos.</resposta>
	</questao>
	<questao id="527">
		<introducao>O código abaixo compila.<java><![CDATA[class A { 
    public int x;
    public native void a() {}
}

public class Teste extends A {
    public static void main(String[] args) {
	Object o = new Teste();
	A a = (A)o;
	System.out.println(a.x);
    }
}]]></java>
		</introducao>
		<resposta valor="f">Método declarado <stmt>native</stmt> não
            pode possuir bloco de código (corpo).</resposta>
	</questao>
	<questao id="528">
		<introducao>O código abaixo não compila.<java><![CDATA[class A { 
    public int x;
    public native void a();
}

public class Teste extends A {
    public static void main(String[] args) {
	Object o = new Teste();
	A a = (A)o;
	System.out.println(a.x);
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="529">
		<introducao>O código abaixo não compila.<java><![CDATA[class A { 
    public int x;
    public native void a();
}

public class Teste extends A {
    public static void main(String[] args) {
	Object o = new Teste();
	A a = (A)o;
	a.a();
	System.out.println(a.x);
    }
}]]></java>
		</introducao>
		<resposta valor="f">Embora compile, quando executado, gera
            uma exceção: <stmt>UnsatisfiedLinkError</stmt>.</resposta>
	</questao>
	<questao id="530">
		<introducao>O código abaixo não compila.<java><![CDATA[abstract class A { 
    public int x;
    public native void a();
}

public class Teste extends A {
    public static void main(String[] args) {
	Object o = new Teste();
	A a = (A)o;
	System.out.println(a.x);
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="531">
		<introducao>O código abaixo compila.<java><![CDATA[abstract class A { 
    public int x;
    public abstract native void a();
}

public class Teste extends A {
    public void a() {}
    public static void main(String[] args) {
	System.out.println( 10 );
    }
}]]></java>
		</introducao>
		<resposta valor="f">Um método não pode ser declarado
            <stmt>native</stmt> e <stmt>abstract</stmt>.</resposta>
	</questao>
	<questao id="532">
		<introducao>Um campo definido como <stmt>volatile</stmt> previne
            este de ser serializado.</introducao>
		<resposta valor="f">Para tal, o campo deve ser declarado
            como <stmt>transient</stmt>.</resposta>
	</questao>
	<questao id="533">
		<introducao>Para que um campo seja impedido de ser serializado,
            este deve ser declarado <stmt>volatile</stmt>.</introducao>
		<resposta valor="f">Deve ser declarado como <stmt>transient</stmt>.</resposta>
	</questao>
	<questao id="534">
		<introducao>O tipo primitivo <stmt>bool</stmt> admite apenas
            dois valores: <stmt>true</stmt> e <stmt>false</stmt>.</introducao>
		<resposta valor="f">A palavra reservada escrita corretamente
            é <stmt>boolean</stmt>.</resposta>
	</questao>
	<questao id="535">
		<introducao>O código abaixo imprime o valor <stmt>false</stmt>.<java><![CDATA[class Super { 
    boolean super;

    boolean getSuper() {
	return super;
    }
}

class SuperMan extends Super {}

public class Teste extends A {
    public static void main(String[] args) {
	System.out.println( (new SuperMan()).getSuper() );
    }
}]]></java>
		</introducao>
		<resposta valor="f">A compilação falha, pois
            <stmt>super</stmt> é palavra reservada.</resposta>
	</questao>
	<questao id="536">
		<introducao>
			<stmt>null</stmt>, <stmt>true</stmt> e <stmt>false</stmt>
            são literais que não podem ser empregadas como
            identificadores e devem ser tratadas como as demais palavras reservadas.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="537">
		<introducao>O código abaixo compila.<java><![CDATA[public class Teste {
    public static void main(String[] args) {
	long true = 23L;
	System.out.println( true );
    }
}]]></java>
		</introducao>
		<resposta valor="f">Observe o emprego errado da literal
            <stmt>true</stmt> (valor do tipo primitivo <stmt>boolean</stmt>).</resposta>
	</questao>
	<questao id="538">
		<introducao>A declaração de um método como <stmt>public</stmt>,
            <stmt>protect</stmt> ou <stmt>private</stmt> permite
            controlar o tipo de acesso ao método.</introducao>
		<resposta valor="f">
			<stmt>protect</stmt> não é modificador de acesso, ao
            contrário de <stmt>protected</stmt>.</resposta>
	</questao>
	<questao id="539">
		<introducao>A sentença <stmt>class A extend B implements
                Interface {}</stmt> declara uma classe <stmt>A</stmt>
            cuja superclasse é <stmt>B</stmt> e implementa a interface <stmt>Interface</stmt>.</introducao>
		<resposta valor="f">O correto é <stmt>extends</stmt> e não
            <stmt>extend</stmt>, como fornecido.</resposta>
	</questao>
	<questao id="540">
		<introducao>
			<stmt>external</stmt> é palavra reservada.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="541">
		<introducao>
			<stmt>define</stmt> é palavra reservada.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="542">
		<introducao>Embora criticado por muitos, o emprego de
            <stmt>goto</stmt> em Java é permitido.</introducao>
		<resposta valor="f">
			<stmt>goto</stmt> é uma palavra reservada mas não é empregada.</resposta>
	</questao>
	<questao id="543">
		<introducao>
			<stmt>const</stmt> é empregada na declaração de uma variável
            cujo valor não pode ser alterado.</introducao>
		<resposta valor="f">
			<stmt>const</stmt> é uma palavra reservada mas não empregada
            em Java.</resposta>
	</questao>
	<questao id="544">
		<introducao>Pode-se construir uma classe que empregue todas as
            palavras reservadas de Java.</introducao>
		<resposta valor="f">
			<stmt>const</stmt> e <stmt>goto</stmt> são palavras
            reservadas que não são empregadas.</resposta>
	</questao>
	<questao id="545">
		<introducao>
			<stmt>const</stmt> e <stmt>goto</stmt> são palavras
            reservadas que podem ser empregadas na definição do corpo de
            um método.</introducao>
		<resposta valor="f">Não podem ser empregadas, embora sejam
            palavras reservadas.</resposta>
	</questao>
	<questao id="546">
		<introducao>O código abaixo, quando executado, é executado em
            intervalo de tempo finito.<java><![CDATA[public class Teste {
    public static void main(String[] args) {
	boolean final = false;
	while ( !final ) {
	    final = !final;
	}
    }
}]]></java>
		</introducao>
		<resposta valor="f">A compilação do código acima falha pela
            tentativa de empregar a palavra reservada <stmt>final</stmt>
            como identificador.</resposta>
	</questao>
	<questao id="547">
		<introducao>O código abaixo imprime, quando executado, a
            seqüência de caracteres correspondente ao literal
            <stmt>false</stmt> do tipo <stmt>boolean</stmt>.</introducao>
		<resposta valor="f">O código não compila. Observe que há
            tentativa de empregar a palavra reservada <stmt>do</stmt>
            como identificador.</resposta>
	</questao>
	<questao id="548">
		<introducao>
			<stmt>abstract</stmt>, <stmt>char</stmt>,
            <stmt>double</stmt> e <stmt>String</stmt> são todas palavras reservadas.</introducao>
		<resposta valor="f">
			<stmt>String</stmt> não é palavra reservada.</resposta>
	</questao>
	<questao id="549">
		<introducao>O código abaixo não compila.<java><![CDATA[public class Teste {
    public static void main(String[] args) {
	int String = 10;
	System.out.println( String );
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="550">
		<introducao>
			<stmt>for</stmt>, <stmt>int</stmt>, <stmt>private</stmt> e
            <stmt>strictf</stmt> são todas palavras reservadas.</introducao>
		<resposta valor="f">O correto é <stmt>strictfp</stmt>.</resposta>
	</questao>
	<questao id="551">
		<introducao>
			<stmt>throws</stmt>, <stmt>assert</stmt> e <stmt>case</stmt>
            são palavras reservadas.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="552">
		<introducao>
			<stmt>assert</stmt> não é palavra reservada de Java, mas um
            mecanismo que pode ser empregado para que, em determinado
            ponto da execução de uma programa, uma condição, quando
            avaliada como verdadeiro, não produza nenhum efeito. Por
            outro lado, se a avaiação conduzir a um valor falso, então
            um mensagem é emitida e a execução do programa é interrompida.</introducao>
		<resposta valor="f">
			<stmt>assert</stmt> é palavra reservada.</resposta>
	</questao>
	<questao id="553">
		<introducao>O código abaixo compila.<java><![CDATA[public class Teste {
    public static void main(String[] args) {
	int assert = 10;
	System.out.println( assert );
    }
}]]></java>
		</introducao>
		<resposta valor="f">
			<stmt>assert</stmt> é palavra reservada.</resposta>
	</questao>
	<questao id="554">
		<introducao>
			<stmt>enabled</stmt> é palavra reservada.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="555">
		<introducao>
			<stmt>bool</stmt>, <stmt>class</stmt>, <stmt>else</stmt> e
            <stmt>if</stmt> são palavras reservadas.</introducao>
		<resposta valor="f">O correto é <stmt>boolean</stmt> e não
            apenas <stmt>bool</stmt>.</resposta>
	</questao>
	<questao id="556">
		<introducao>
			<stmt>goto</stmt>, <stmt>const</stmt> e <stmt>assert</stmt>
            são palavras reservadas.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="557">
		<introducao>
			<stmt>super</stmt>, <stmt>strictfp</stmt> e
            <stmt>synchronize</stmt> são palavras reservadas.</introducao>
		<resposta valor="f">O correto é <stmt>synchronized</stmt>.</resposta>
	</questao>
	<questao id="558">
		<introducao>
			<stmt>synchronized</stmt> e <stmt>protected</stmt> são
            palavras reservadas.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="559">
		<introducao>
			<stmt>native</stmt>, <stmt>volatile</stmt> e
            <stmt>strictfp</stmt> são palavras reservadas.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="560">
		<introducao>
			<stmt>transient</stmt>, <stmt>native</stmt> e
            <stmt>volatile</stmt> não são palavras reservadas.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="561">
		<introducao>
			<stmt>throws</stmt> e <stmt>throw</stmt> são palavras reservadas.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="562">
		<introducao>
			<stmt>extend</stmt> e <stmt>implement</stmt> são palavras reservadas.</introducao>
		<resposta valor="f">O correto é <stmt>extends</stmt> e <stmt>implements</stmt>.</resposta>
	</questao>
	<questao id="563">
		<introducao>
			<stmt>final</stmt> e <stmt>finally</stmt> são palavras reservadas.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="564">
		<introducao>
			<stmt>throws</stmt>, <stmt>extends</stmt> e
            <stmt>implements</stmt> são palavras reservadas.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="565">
		<introducao>
			<stmt>continue</stmt> e <stmt>default</stmt> são palavras reservadas.</introducao>
		<resposta valor="verddeiro"/>
	</questao>
	<questao id="566">
		<introducao>
			<stmt>break</stmt>, <stmt>goto</stmt>, <stmt>const</stmt>,
            <stmt>assert</stmt> e <stmt>continue</stmt> são palavras reservadas.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="567">
		<introducao>
			<stmt>static</stmt> e <stmt>dynamic</stmt> são palavras reservadas.</introducao>
		<resposta valor="f">Apenas <stmt>static</stmt>.</resposta>
	</questao>
	<questao id="568">
		<introducao>
			<stmt>try</stmt> e <stmt>this</stmt> são palavras reservadas.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="569">
		<introducao>
			<stmt>instanceof</stmt>, <stmt>interface</stmt> e
            <stmt>imports</stmt> são palavras reservadas.</introducao>
		<resposta valor="f">O correto é <stmt>import</stmt>.</resposta>
	</questao>
	<questao id="570">
		<introducao>
			<stmt>implements</stmt>, <stmt>extends</stmt> e
            <stmt>catches</stmt> são palavras reservadas.</introducao>
		<resposta valor="f">O correto é <stmt>catch</stmt>.</resposta>
	</questao>
	<questao id="571">
		<introducao>
			<stmt>do</stmt>, <stmt>native</stmt> e <stmt>include</stmt>
            são palavras reservadas.</introducao>
		<resposta valor="f">Apenas <stmt>do</stmt> e
            <stmt>native</stmt> destas três são palavras reservadas.</resposta>
	</questao>
	<questao id="572">
		<introducao>
			<stmt>super</stmt>, <stmt>native</stmt>,
            <stmt>volatile</stmt> e <stmt>synchronize</stmt> são
            palavras reservadas.</introducao>
		<resposta valor="f">O correto é <stmt>synchronized</stmt>.</resposta>
	</questao>
	<questao id="573">
		<introducao>
			<stmt>package</stmt>, <stmt>abstract</stmt>,
            <stmt>else</stmt>, <stmt>interface</stmt> e
            <stmt>transiente</stmt> são palavras reservadas.</introducao>
		<resposta valor="f">O correto é <stmt>transient</stmt>.</resposta>
	</questao>
	<questao id="574">
		<introducao>
			<stmt>switch</stmt>, <stmt>case</stmt> e
            <stmt>transiente</stmt> são palavrs reservadas.</introducao>
		<resposta valor="f">O correto é <stmt>transient</stmt>.</resposta>
	</questao>
	<questao id="575">
		<introducao>
			<stmt>byte</stmt> e <stmt>boolean</stmt> são palavras reservadas.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="576">
		<introducao>
			<stmt>Character</stmt>, <stmt>byte</stmt> e
            <stmt>boolean</stmt> são palavras reservadas.</introducao>
		<resposta valor="f">
			<stmt>Character</stmt> não é palavra reservada.</resposta>
	</questao>
	<questao id="577">
		<introducao>
			<stmt>String</stmt> é identificador válido.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="578">
		<introducao>
			<stmt>Boolean</stmt> é identificador válido.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="579">
		<introducao>
			<stmt>Integer</stmt> é tipo primitivo.</introducao>
		<resposta valor="f">O correto é <stmt>int</stmt>.</resposta>
	</questao>
	<questao id="580">
		<introducao>
			<stmt>Double</stmt> é identificador válido.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="581">
		<introducao>
			<stmt>goto</stmt> é identificador válido.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="582">
		<introducao>
			<stmt>const</stmt> é um identificador válido.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="583">
		<introducao>
			<stmt>synchronize</stmt> é identificador válido.</introducao>
		<resposta valor="v">Observe que
            <stmt>synchronized</stmt> é palavra reservada.</resposta>
	</questao>
	<questao id="584">
		<introducao>
			<stmt>instanceOf</stmt> é identificador válido.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="585">
		<introducao>
			<stmt>transiente</stmt> é identificador válido.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="586">
		<introducao>
			<stmt>transient</stmt> é identificador válido.</introducao>
		<resposta valor="f">
			<stmt>transient</stmt> é palavra reservada.</resposta>
	</questao>
	<questao id="587">
		<introducao>
			<stmt>null</stmt> é identificador válido.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="588">
		<introducao>
			<stmt>false</stmt> é identificador válido.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="589">
		<introducao>
			<stmt>true</stmt> é identificador válido.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="590">
		<introducao>
			<stmt>final</stmt> é identificador válido.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="591">
		<introducao>
			<stmt>finale</stmt> não é identificador válido.</introducao>
		<resposta valor="f">A palavra reservada
            &quot;homógrafa&quot; é <stmt>finally</stmt>.</resposta>
	</questao>
	<questao id="592">
		<introducao>Palavras reservadas não podem ser utilizadas como
            identificadores de classes, métodos e variáveis.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="593">
		<introducao>Todas as palavras reservadas estão escritas
            exclusivamente em letras minúsculas.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="594">
		<introducao>Algumas palavras reservadas como
            <stmt>boolean</stmt> e <stmt>double</stmt>, por exemplo,
            possuem versões equivalentes com a inicial maiúscula.</introducao>
		<resposta valor="f">Todas as palavras reservadas são
            escritas exclusivamente em minúsculas.</resposta>
	</questao>
	<questao id="595">
		<introducao>
			<stmt>instanceOf</stmt> é uma palavra reservada que possui,
            embora não seja a primeira letra, uma letra escrita em maiúscula.</introducao>
		<resposta valor="f">
			<stmt>instanceOf</stmt> é um identificador válido, enquanto
            <stmt>instanceof</stmt> é palavra reservada.</resposta>
	</questao>
	<questao id="596">
		<introducao>
			<stmt>byte</stmt>, <stmt>short</stmt>, <stmt>integer</stmt>
            e <stmt>long</stmt> são palavras reservadas.</introducao>
		<resposta valor="f">O correto é <stmt>int</stmt>.</resposta>
	</questao>
	<questao id="597">
		<introducao>
			<stmt>reserved</stmt> é palavra reservada.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="598">
		<introducao>
			<stmt>default</stmt> e <stmt>continues</stmt> são palavras reservadas.</introducao>
		<resposta valor="f">O correto é <stmt>continue</stmt>.</resposta>
	</questao>
	<questao id="599">
		<introducao>
			<stmt>asserts</stmt> e <stmt>return</stmt> são palavras reservadas.</introducao>
		<resposta valor="f">O correto é <stmt>assert</stmt>.</resposta>
	</questao>
	<questao id="600">
		<introducao>
			<stmt>break</stmt> e <stmt>instanceOf</stmt> são
            identificadores válidos.</introducao>
		<resposta valor="f">
			<stmt>break</stmt> é palavra reservada.</resposta>
	</questao>
	<questao id="601">
		<introducao>
			<stmt>catch</stmt>, <stmt>break</stmt> e <stmt>begin</stmt>
            são palavras reservadas.</introducao>
		<resposta valor="f">
			<stmt>begin</stmt> é identificador válido.</resposta>
	</questao>
	<questao id="602">
		<introducao>
			<stmt>with</stmt> e <stmt>synchronized</stmt> são palavras reservadas.</introducao>
		<resposta valor="f">
			<stmt>with</stmt> é identificador válido.</resposta>
	</questao>
	<questao id="603">
		<introducao>Os tipos primtivitos include <stmt>byte</stmt>,
            <stmt>short</stmt>, <stmt>int</stmt>, <stmt>long</stmt>,
            <stmt>float</stmt>, <stmt>double</stmt>, <stmt>char</stmt> e <stmt>boolean</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="604">
		<introducao>Os tipos primitivos numéricos, ou seja,
            <stmt>byte</stmt>, <stmt>short</stmt>, <stmt>int</stmt>,
            <stmt>long</stmt>, <stmt>float</stmt> e <stmt>double</stmt>
            são tipos com sinal (<it>singed</it>). Ou seja, valores
            deste tipo podem ser negativos ou positivos.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="605">
		<introducao>Os tipos com sinal em Java usam o bit mais a
            esquerda, o bit mais significativo, para representar o
            sinal. Quando este bit é 1, o número é negativo, caso
            contrário, o número é positivo (o que inclui o zero).</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="606">
		<introducao>Em Java, os tipos com sinal usam a notação de
            complemento de dois para representá-los internamente. </introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="607">
		<introducao>O tipo primitivo <stmt>byte</stmt> representa um
            conjunto de 256 valores, correspondentes a 2 elevado a 8.
            Destes 256 valores, 128 são negativos, de -128 até -1. Os
            outros 128 valores vão de 0 a 127.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="608">
		<introducao>Uma variável do tipo primitivo <stmt>short</stmt>
            faz uso de 16 bits para representar números deste tipo.
            Estes 16 bits permitem representar 2 elevado a 16 números,
            ou 65536 valores distintos. Destes, 32768 valores são
            negativos e os demais 32768 são positivos. Os negativos vão
            de -32768 até -1, enquanto os positivos vão de 0 até 32767</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="609">
		<introducao>Quando se escreve um valor do tipo <stmt>int</stmt>,
            <stmt>boolean</stmt> ou outro, em Java, diz-se que o que
            você escreve é uma literal.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="610">
		<introducao>Há três formas de representar números inteiros em
            Java: decimal (base 10), octal (base 8) e hexadecimal (base 16).</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="611">
		<introducao>Números inteiros na base 10, em Java, são
            representados normalmente como em muitos outros cenários,
            por exemplo, <stmt>-10</stmt>, <stmt>26</stmt>e
            <stmt>32767</stmt> são literais inteiras na representação decimal.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="612">
		<introducao>Números na base octal fazem uso apenas dos dígitos
            de 0 a 7, inclusive.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="613">
		<introducao>Um número em octal na linguagem de programação Java
            é necessariamente iniciado por um zero.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="614">
		<introducao>São exemplos de números inteiros na base octal em
            Java as seguintes literais: <stmt>00</stmt> e <stmt>01234567</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="615">
		<introducao>A literal Java <stmt>032386</stmt> correspondente a
            um inteiro na base octal.</introducao>
		<resposta valor="f">Observe o dígito <stmt>8</stmt>, não
            permitido em números na base octal.</resposta>
	</questao>
	<questao id="616">
		<introducao>O código abaixo não imprime a mensagem
            <stmt>ok</stmt> quando executado.<java><![CDATA[public class Literal11 {
    public static void main(String[] args) {
        int sete = 07;
        int treze = 015;
        int vinte = 20;
        if ( vinte == (sete + treze) ) {
            System.out.println("ok");
        }
    }
}]]></java>
		</introducao>
		<resposta valor="f">Observe que as variáveis
            <stmt>sete</stmt> e <stmt>treze</stmt> foram iniciadas com
            literais inteiras no formato octal.</resposta>
	</questao>
	<questao id="617">
		<introducao>Em Java, a igualdade <stmt>-2 == (8 - 010)</stmt> é verdadeira.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="618">
		<introducao>A condição <stmt>(1000-0001) == 0999</stmt> é verdadeira.</introducao>
		<resposta valor="f">Observe que <stmt>0001</stmt> e
            <stmt>0999</stmt> deveriam, ambos ser números na
            representação octal. O último deles não é uma literal válida.</resposta>
	</questao>
	<questao id="619">
		<introducao>A condição <stmt>(100-020)==80</stmt> é verdadeira.</introducao>
		<resposta valor="f">Observe que <stmt>020</stmt> é literal
            no formato octal cujo valor decimal correspondente é 16.</resposta>
	</questao>
	<questao id="620">
		<introducao>Literais na representação hexadecimal empregam todos
            os dígitos empregados na representação decimal acrescidos
            dos caracteres alfabéticos <stmt>a</stmt>, <stmt>b</stmt>,
            <stmt>c</stmt>, <stmt>d</stmt>, <stmt>e</stmt> e, por
            último, <stmt>f</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="621">
		<introducao>Os dígitos hexadecimais representam 16 valores
            possíveis, do 0 ao 15.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="622">
		<introducao>Toda literal na representação hexadecimal contém o
            prefixo <stmt>0x</stmt> ou <stmt>0X</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="623">
		<introducao>
			<stmt>0xCafe</stmt> é uma literal válida.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="624">
		<introducao>
			<stmt>0xfe</stmt> é uma literal válida.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="625">
		<introducao>
			<stmt>0xBabel</stmt> é uma literal válida.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="626">
		<introducao>
			<stmt>0xFaca</stmt> é uma literal válida.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="627">
		<introducao>O texto <stmt>0xB0CA</stmt> representa uma literal
            válida em Java.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="628">
		<introducao>Todas as literais inteiras são, exceto se
            especificado o contrário, do tipo <stmt>int</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="629">
		<introducao>A literal <stmt>0xal</stmt> representa o valor 10 do
            tipo <stmt>long</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="630">
		<introducao>Literais na notação ponto-flutuante são do tipo
            <stmt>double</stmt> por <it>default</it>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="631">
		<introducao>A literal <stmt>1.0</stmt> representa um valor do
            tipo <stmt>float</stmt> ou <stmt>double</stmt>.</introducao>
		<resposta valor="f">Apenas <stmt>double</stmt>.</resposta>
	</questao>
	<questao id="632">
		<introducao>A literal <stmt>2.64</stmt> representa um valor do
            tipo <stmt>double</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="633">
		<introducao>As literais <stmt>1</stmt>, <stmt>024</stmt> e
            <stmt>0xC0CA</stmt> representam valores do tipo <stmt>int</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="634">
		<introducao>O sufixo <stmt>L</stmt> ou <stmt>l</stmt> pode ser
            empregado para representar uma literal do tipo
            <stmt>long</stmt>, independente da representação ser
            decimal, octal ou hexadecimal.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="635">
		<introducao>A literal <stmt>010L</stmt> representa o valor 8 do
            tipo <stmt>long</stmt>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="636">
		<introducao>A literal <stmt>0144L</stmt> representa o valor
            decimal 100 do tipo <stmt>long</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="637">
		<introducao>Valores do tipo <stmt>byte</stmt> fazem uso de 8
            bits para serem representados.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="638">
		<introducao>Valores do tipo <stmt>short</stmt> fazem uso de 16
            bits para serem representados.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="639">
		<introducao>Valores do tipo <stmt>int</stmt> fazem uso de 32
            bits para serem representados.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="640">
		<introducao>Valores do tipo <stmt>long</stmt> fazem uso de 64
            bits para serem representados.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="641">
		<introducao>Valores do tipo <stmt>float</stmt> fazem uso de 32
            bits para serem representados.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="642">
		<introducao>Valores do tipo <stmt>double</stmt> fazem uso de 64
            bits para serem representados.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="643">
		<introducao>Valores do tipo <stmt>float</stmt> e
            <stmt>short</stmt> fazem uso de 4 bytes para serem representados.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="644">
		<introducao>Valores do tipo <stmt>long</stmt> e
            <stmt>double</stmt> fazem uso de 8 bits para serem representados.</introducao>
		<resposta valor="f">São 8 bytes.</resposta>
	</questao>
	<questao id="645">
		<introducao>O tipo <stmt>short</stmt> representa um conjunto com
            o dobre do número de elementos daquele representado pelo
            tipo <stmt>byte</stmt>.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="646">
		<introducao>O tipo <stmt>short</stmt> representa um conjunto com
            o quadrado do número de elementos daquele representado pelo
            tipo <stmt>byte</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="647">
		<introducao>Nem todo valor do tipo <stmt>float</stmt> tem
            correspondente exato do tipo <stmt>int</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="648">
		<introducao>Se <stmt>x</stmt> e <stmt>y</stmt> armazenam valores
            do tipo <stmt>int</stmt> e sabe-se que o valor inteiro
            armazenado em <stmt>x</stmt> e diferente daquele armazenado
            em <stmt>y</stmt>, então os valores correspondentes,
            convertidos para o tipo <stmt>float</stmt> também são distintos.</introducao>
		<resposta valor="f">Experimente, por exemplo, os valores
            -2147482724 e -2147482725. Quando convertidos para
            <stmt>float</stmt>, os valores convertidos são iguais.</resposta>
	</questao>
	<questao id="649">
		<introducao>Todos os possíveis valores que uma variável do tipo
            <stmt>float</stmt> pode assumir podem ser contados com uma
            variável do tipo <stmt>int</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="650">
		<introducao>Todo valor do tipo <stmt>int</stmt> possui um
            correspondente exato do tipo <stmt>float</stmt>.</introducao>
		<resposta valor="f">Caso contrário, todos os valores seriam inteiros.</resposta>
	</questao>
	<questao id="651">
		<introducao>Todo valor do tipo <stmt>long</stmt> possui um
            correspondente exato do tipo <stmt>double</stmt>.</introducao>
		<resposta valor="f">Caso contrário, todos os valores seriam inteiros.</resposta>
	</questao>
	<questao id="652">
		<introducao>Nem todo valor do tipo <stmt>float</stmt> pode ser
            representado sem perda de precisão por um valor do tipo <stmt>int</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="653">
		<introducao>Nem todo valor do tipo <stmt>float</stmt> pode ser
            representado sem perda de precisão por um valor do tipo <stmt>long</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="654">
		<introducao>Nem todo valor do tipo <stmt>long</stmt> pode ser
            representado sem perda de precisão por um valor do tipo <stmt>int</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="655">
		<introducao>Nem todo valor do tipo <stmt>byte</stmt> pode ser
            representado sem perda de precisão por um valor do tipo <stmt>int</stmt>.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="656">
		<introducao>Nem todo valor do tipo <stmt>int</stmt> pode ser
            representado sem perda de precisão por um valor do tipo <stmt>long</stmt>.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="657">
		<introducao>Nem todo valor do tipo <stmt>short</stmt> pode ser
            representado sem perda de precisão por um valor do tipo <stmt>float</stmt>.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="658">
		<introducao>Nem todo valor do tipo <stmt>short</stmt> pode ser
            representado sem perda de precisão por um valor do tipo <stmt>int</stmt>.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="659">
		<introducao>Literais ponto-flutuante em Java podem fazer uso de vírgula.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="660">
		<introducao>Literais ponto-flutuante em Java podem fazer uso de ponto.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="661">
		<introducao>Literais ponto-flutuante em Java podem fazer uso de
            vírgula e de ponto, simultaneamente.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="662">
		<introducao>Uma literal ponto-flutuante em Java pode fazer uso
            de mais de um ponto.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="663">
		<introducao>Em Java, o tipo que representa o menor conjunto
            possível de valores é o tipo primitivo <stmt>boolean</stmt>,
            que representa apenas dois valores.</introducao>
		<resposta valor="f">O tipo <stmt>null</stmt> é menor.</resposta>
	</questao>
	<questao id="664">
		<introducao>O tipo em Java que possui o menor conjunto de
            valores é o tipo <stmt>null</stmt>, que possui um único valor.</introducao>
		<resposta valor=""/>
	</questao>
	<questao id="665">
		<introducao>A código abaixo compila.<java><![CDATA[public class Boolean1 {
    public static void main(String[] args) {
        int x = 1;
        int y = x ? -1 : 1;
        System.out.println(y);
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="666">
		<introducao>A código abaixo, quando executado, deposita em
            <stmt>y</stmt> a literal <stmt>-1</stmt>.<java><![CDATA[public class Boolean1 {
    public static void main(String[] args) {
        int x = 1;
        int y = x ? -1 : 1;
        System.out.println(y);
    }
}]]></java>
		</introducao>
		<resposta valor="f">O código não compila.</resposta>
	</questao>
	<questao id="667">
		<introducao>O código abaixo, quando executado, imprime a literal <stmt>true</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="668">
		<introducao>Uma literal do tipo <stmt>char</stmt> é representada
            por um único caracteres entre aspas simples.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="669">
		<introducao>A declaração <stmt>char c = 'ab';</stmt> é válida em Java.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="670">
		<introducao>A declaração <stmt>char c = &quot;a&quot;;</stmt> é
            válida em Java.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="671">
		<introducao>A literal correspondente a um caractere pode ser
            fornecida através do valor UNICODE do caracteres.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="672">
		<introducao>
			<stmt>char c = '\u0041';</stmt> é uma declaração válida em Java.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="673">
		<introducao>
			<stmt>char c = '\x0041';</stmt> é uma declaração válida em Java.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="674">
		<introducao>As declarações <stmt>char c = '\u0041';</stmt> e
                <stmt>char c = 0x0041</stmt> são equivalentes.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="675">
		<introducao>Embora muito exótico e que se deve evitar, pode-se
            utilizar a declaração <stmt>char c =
            (char)0xffff0041;</stmt> ou, em vez do número hexadecimal, o
            número negativo correspondente em notação decimal, para
            depositar na variável <stmt>c</stmt> a letra A, cuja literal
            UNICODE correspondente é <stmt>'\u0041'</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="676">
		<introducao>Caracteres, ou valores do tipo primtivo
            <stmt>char</stmt>, são inteiros positivos de 16 bits.
            Qualquer número inteiro de 16 bits e que é maior que zero
            pode ser utilizado para uma atribuição a variáveis do tipo <stmt>char</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="677">
		<introducao>Não se pode atribuir um valor inteiro negativo a uma
            variável do tipo <stmt>char</stmt> porque o compilador
            verifica que o número em questão está fora da faixa de
            valores permitidos.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="678">
		<introducao>A declaração <stmt>char c = 66000;</stmt> provoca um
            erro de compilação.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="679">
		<introducao>A declaração <stmt>char c = (char)66000;</stmt>
            provoca um erro de compilação.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="680">
		<introducao>A declaração <stmt>char c = 0101;</stmt> provoca um
            erro de compilação.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="681">
		<introducao>A declaração <stmt>char c = 0101;</stmt> deposita em
            <stmt>c</stmt> o caractere cujo valor UNICODE corresponde ao
            valor <stmt>101</stmt>.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="682">
		<introducao>Nem todos os caracteres podem ser digitados, como o
            caractere que indica uma nova linha, por exemplo.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="683">
		<introducao>Para definir a variável <stmt>c</stmt> do tipo
            primitivo <stmt>char</stmt> e, no momento da declaração
            iniciar esta variável com o caractere de &quot;nova
            linha&quot; (<it>new line</it>), pode-se empregar uma
            sentença como <stmt>char c = '\n';</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="684">
		<introducao>Uma literal <stmt>String</stmt> em Java é uma
            seqüência de caracteres fornecida entre aspas duplas.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="685">
		<introducao>
			<stmt>String</stmt> não é um tipo primitivo de Java.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="686">
		<introducao>
			<stmt>Boolean</stmt> não é um tipo primitivo de Java.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="687">
		<introducao>Embora <stmt>String</stmt> não seja um tipo
            primitivo, valores deste tipo podem ser representados como literais.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="688">
		<introducao>Embora o tipo <stmt>null</stmt> não seja um tipo
            primitivo, o único valor deste tipo pode ser representado
            como literal, o valor <stmt>null</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="689">
		<introducao>Dois tipos que não são primitivos, na linguagem de
            programação Java, possuem literais que podem ser diretamente
            digitados pelos programadores em código fonte nesta
            linguagem. Estes tipos são: <stmt>String</stmt> e <stmt>null</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="690">
		<introducao>Um <it>array</it> é uma instância da classe
            <stmt>Object</stmt> em Java.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="691">
		<introducao>Um <it>array</it> armazena múltiplas variáveis de um
            mesmo tipo.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="692">
		<introducao>A declaração de uma <it>array</it> exige que seja
            fornecido o tipo dos elementos que serão armazenados no <it>array</it>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="693">
		<introducao>Um <it>array</it> pode armazenar variáveis de um
            tipo primitivo ou tipo referência.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="694">
		<introducao>Um <it>array</it> de inteiros cujo identificador é
            <stmt>x</stmt> pode ser declarado com os colchetes
            imediatamente após o tipo (<stmt>int[] x;</stmt>) ou com os
            colchetes após o identificador (<stmt>int x[];).</stmt>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="695">
		<introducao>A declaração <stmt>int [] x;</stmt> não é válida.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="696">
		<introducao>A declaração <stmt>int x [];</stmt> não é válida.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="697">
		<introducao>A declaração <stmt>int[]x;</stmt> não compila.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="698">
		<introducao>A declaração <stmt>int[]x;</stmt> seguida de <stmt>a
                = new int[0];</stmt> gera um erro de compilação.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="699">
		<introducao>A declaração <stmt>int[]x;</stmt> seguida de <stmt>a
                = new int[0];</stmt> cria um objeto <it>array</it> cuja
            referência é depositada na variável <stmt>a</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="700">
		<introducao>A declaração <stmt>int[]x;</stmt> seguida de <stmt>a
                = new int[0];</stmt> cria um objeto <it>array</it> com
            zero elementos. Ou seja, a tentativa de usar qualquer
            componente do <it>array</it> gera uma exceção.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="701">
		<introducao>As declarações <stmt>Thread[] threads;</stmt> e
                <stmt>Thread threads[];</stmt> são equivalentes.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="702">
		<introducao>
			<it>Arrays</it> são implementados em Java como objetos.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="703">
		<introducao>
			<it>Arrays</it> multidimensionais são permitidos em Java
            através de <it>arrays</it> de <it>arrays</it>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="704">
		<introducao>
			<stmt>String[][] gerencia;</stmt> declara o <it>array</it>
            identificado por <stmt>gerencia</stmt> cujos elementos são
            <it>arrays</it> de <stmt>String</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="705">
		<introducao>
			<stmt>int[] arrayInt[];</stmt> é uma declaração ilegal.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="706">
		<introducao>A compilação do código abaixo falha.<java><![CDATA[public class Array2 {
    public static void main(String[] args) {
        int array[][][];
        array = new int[2][2][2];
        array[0][0][0] = 1;
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="707">
		<introducao>
			<stmt>array</stmt> é palavra reservada mas não empregada
            pela linguagem Java.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="708">
		<introducao>A declaração <stmt>int a[10];</stmt> cria a variável
            de referência <stmt>a</stmt>de um <it>array</it> cujos
            elementos são do tipo <stmt>int</stmt> e em um total de 10.</introducao>
		<resposta valor="f">Não se pode fornecer o tamanho do
            <it>array</it> na declaração.</resposta>
	</questao>
	<questao id="709">
		<introducao>Não se pode fornecer o tamanho de um <it>array</it>
            quando este é declarado, ou seja, <stmt>char
            nome[80];</stmt> é uma declaração ilegal.</introducao>
		<resposta valor=""/>
	</questao>
	<questao id="710">
		<introducao>
			<stmt>double d[120];</stmt> declara o <it>array</it>
            identificado por <stmt>d</stmt> de um total de 120 elementos
            do tipo <stmt>double</stmt>.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="711">
		<introducao>A quantidade de elementos que compõe um
            <it>array</it> é estabelecida apenas quando este é
            construído no <it>heap</it> (ou alocado).</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="712">
		<introducao>Um <it>array</it> é construído, entre outras formas,
            através do emprego da palavra reservada  <stmt>new</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="713">
		<introducao>Quando se cria um <it>array</it> em Java, ao
            contrário da declaração, é necessário conhecer o tamanho do <it>array</it>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="714">
		<introducao>O tamanho de um <it>array</it> é a quantidade de
            elementos que o <it>array</it> poderá reter. </introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="715">
		<introducao>
			<stmt>int x[];</stmt> declara um <it>array</it> identificado
            por <stmt>x</stmt> cujos elementos são do tipo primitivo <stmt>int</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="716">
		<introducao>Se <stmt>aInt</stmt> foi declarado como um
            <it>array</it> de inteiros (<stmt>int</stmt>), então
                <stmt>aInt = int[10];</stmt> cria o <it>array</it> com
            10 elementos do tipo <stmt>int</stmt>.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="717">
		<introducao>A sentença <stmt>int [] aInt = new int[5];</stmt>
            declara um <it>array</it> de elementos do tipo
            <stmt>int</stmt> e cria um objeto correspondente contendo
            com capacidade para 5 inteiros.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="718">
		<introducao>Após a execução de <stmt>double x[] = new
            double[3];</stmt> a soma de todos os elementos do
            <it>array</it> irá provocar uma exceção em tempo de execução.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="719">
		<introducao>Após a execução de <stmt>double x[] = new
            double[3];</stmt> a soma de todos os elementos do
            <it>array</it> irá resultar no valor <stmt>0.0</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="720">
		<introducao>Todos os elementos de um <it>array</it>, quando este
            é criado por meio de <stmt>new</stmt>, são iniciados com o
            valor <it>default</it> correspondente ao tipo em questão.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="721">
		<introducao>
			<stmt>int [] a;</stmt> seguida de <stmt>a = new
            int[6];</stmt> tem o mesmo efeito que <stmt>int [] a = new int[6];</stmt>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="722">
		<introducao>
			<stmt>boolean b[] = new boolean(4);</stmt> declara a
            variável de referência <stmt>b</stmt> como um <it>array</it>
            de elementos do tipo primitivo <stmt>boolean</stmt> e cria
            um objeto no <it>heap</it> capaz de reter 4 valores do tipo
            <stmt>boolean</stmt> e inicia todos eles com o valor <stmt>false</stmt>.</introducao>
		<resposta valor="f">Observe o emprego do parênteses em vez
            de colchetes.</resposta>
	</questao>
	<questao id="723">
		<introducao>Após a execução de <stmt>String [] strs = new
            String[2];</stmt> haverá pelo menos três objetos no
            <it>heap</it>. Um correspondente ao <it>array</it> criado,
            cuja referência é armazenada em <stmt>strs</stmt> e outros
            dois correspondentes ao objeto <stmt>String</stmt> em
            <stmt>strs[0]</stmt> e outro em <stmt>strs[1]</stmt>.</introducao>
		<resposta valor="f">Apenas o objeto <stmt>strs</stmt> é
            criado. Nenhuma <stmt>String</stmt> é criada.</resposta>
	</questao>
	<questao id="724">
		<introducao>
			<stmt>thread</stmt> é palavra reservada de Java.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="725">
		<introducao>
			<stmt>Thread</stmt> não é palavra reservada mas não pode ser
            utilizada como identificador em Java.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="726">
		<introducao>
			<stmt>thread</stmt> não é palavra reservada mas não pode ser
            utilizada como identificador em Java.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="727">
		<introducao>
			<stmt>construct</stmt> é palavra reservada em Java.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="728">
		<introducao>
			<stmt>create</stmt> é palavra reservada em Java.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="729">
		<introducao>
			<stmt>instantiate</stmt> é palavra reservada em Java.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="730">
		<introducao>
			<stmt>Object</stmt> é palavra reservada em Java.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="731">
		<introducao>A compilação do código abaixo falha.<java><![CDATA[public class ArrayTest {
    public static void main(String[] args) {
        int Object[][][];
        Object = new int[2][2][2];
        Object[0][0][0] = 1;
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="732">
		<introducao>A sentença <stmt>Object strs[] = new String[5];</stmt>
		</introducao>
		<resposta valor=""/>
	</questao>
	<questao id="733">
		<introducao>A compilação do código abaixo falha.<java><![CDATA[public class Array3 {
    public static void main(String[] args) {
        Object[] strs = new String[5];
        strs[0] = new Boolean(true);
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="734">
		<introducao>A execução do código abaixo gera uma exceção: <stmt>ArrayStoreException</stmt>.<java><![CDATA[public class Array {
    public static void main(String[] args) {
        Object[] strs = new String[5];
        strs[0] = new Boolean(true);
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="735">
		<introducao>Números inteiros em Java podem ser representados
            usando três bases distintas: a base 10 (decimal), a base 8
            (octal) e a base 16 (hexadecimal).</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="736">
		<introducao>Literais na notação hexadecimal e octal são
            permitidas exclusivamente para a representação de números
            inteiros, o que exclui literais ponto-flutuante.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="737">
		<introducao>O compilação do código abaixo falha.<java><![CDATA[public class Literal {
    public static void main(String[] args) {
        long int x = 10;
        short int y = 10;
        System.out.println(x + y);
    }
}]]></java>
		</introducao>
		<resposta valor="v">
			<stmt>long int</stmt> e <stmt>short int</stmt> não são tipos
            primitivos da linguagema Java.</resposta>
	</questao>
	<questao id="738">
		<introducao>A compilação do código abaixo falha.<java><![CDATA[public class Literal {
    public static void main(String[] args) {
        int x = 10L;
        int y = 10L;
        System.out.println(x + y);
    }
}]]></java>
		</introducao>
		<resposta valor="v">Há possível perda de precisão ao se
            tentar depositar um valor do tipo <stmt>long</stmt> em uma
            variável do tipo <stmt>int</stmt>.</resposta>
	</questao>
	<questao id="739">
		<introducao>O código abaixo exibe o resultado <stmt>20</stmt>,
            quando executado.<java><![CDATA[public class Literal {
    public static void main(String[] args) {
        int x = 10L;
        int y = 10L;
        System.out.println(x + y);
    }
}]]></java>
		</introducao>
		<resposta valor="f">O código não compila.</resposta>
	</questao>
	<questao id="740">
		<introducao>A compilação do código abaixo falha.<java><![CDATA[public class Literal {
    public static void main(String[] args) {
        float x = 010f;
        float y = 010;
        System.out.println(x + y);
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="741">
		<introducao>O código abaixo exibe o resultado <stmt>20</stmt>,
            quando executado.<java><![CDATA[public class Literal {
    public static void main(String[] args) {
        float x = 010f;
        float y = 010;
        System.out.println(x + y);
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="742">
		<introducao>O código abaixo exibe o resultado <stmt>16</stmt>,
            quando executado.<java><![CDATA[public class Literal {
    public static void main(String[] args) {
        float x = 010f;
        float y = 010;
        System.out.println(x + y);
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="743">
		<introducao>O código abaixo exibe o resultado <stmt>18</stmt>,
            quando executado.<java><![CDATA[public class Literal {
    public static void main(String[] args) {
        float x = 010f;
        float y = 010;
        System.out.println(x + y);
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="744">
		<introducao>A declaração <stmt>float f = 010;</stmt> deposita na
            variável do tipo primitivo <stmt>float</stmt> o valor
            decimal 8.</introducao>
		<resposta valor="v">Observe a representação octal
            empregada pela literal inteira.</resposta>
	</questao>
	<questao id="745">
		<introducao>A declaração <stmt>int i = (int)010f;</stmt> causa
            um erro de compilação.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="746">
		<introducao>A declaração <stmt>int i = (int)010f;</stmt>
            deposita na variável <stmt>i</stmt> o valor decimal 10.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="747">
		<introducao>A declaração <stmt>long l = (long)010d;</stmt>
            deposita na variável <stmt>l</stmt> o valor decimal 10.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="748">
		<introducao>A declaração <stmt>byte b = (byte)020;</stmt>
            deposita na variável <stmt>b</stmt> o valor decimal 16.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="749">
		<introducao>A declaração <stmt>short s = (short)012f;</stmt>
            deposita na variável <stmt>s</stmt> o valor decimal 10.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="750">
		<introducao>A declaração <stmt>short s = (short)012f;</stmt>
            deposita na variável <stmt>s</stmt> o valor decimal 12.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="751">
		<introducao>Em Java, uma literal com o prefixo <stmt>d</stmt>,
            <stmt>D</stmt>, <stmt>f</stmt> ou <stmt>F</stmt> é uma
            literal em ponto-flutuante. Isto significa que a literal
            está, necessariamente, escrita na base decimal.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="752">
		<introducao>A compilação do código abaixo falha.<java><![CDATA[public class Test {
    public static void main(String[] args) {
        float x = 010f;
        float y = 010;
        int i = x + y;
        System.out.println(i);
    }
}]]></java>
		</introducao>
		<resposta valor="v">A terceira declaração tenta
            depositar um valor do tipo <stmt>float</stmt> em uma
            variável do tipo <stmt>int</stmt>.</resposta>
	</questao>
	<questao id="753">
		<introducao>A compilação do código abaixo falha.<java><![CDATA[public class Teste {
    public static void main(String[] args) {
        int x = 010;
        int y = 010;
        int i = x + y/2.0;
        System.out.println(i);
    }
}]]></java>
		</introducao>
		<resposta valor="v">Na terceira declaração, a expressão
            resultante é do tipo <stmt>double</stmt>. </resposta>
	</questao>
	<questao id="754">
		<introducao>A compilação do código abaixo falha.<java><![CDATA[public class Teste {
    public static void main(String[] args) {
        int x = 010;
        int y = 010;
        int i = x + y/2;
        System.out.println(i);
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="755">
		<introducao>A execução deste código exibe o valor <stmt>12</stmt>.<java><![CDATA[public class Teste {
    public static void main(String[] args) {
        int x = 010;
        int y = 010;
        int i = x + y/2.0;
        System.out.println(i);
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="756">
		<introducao>O código abaixo imprime o resultado <stmt>191.0</stmt>.<java><![CDATA[public class Soma {
    public static void main(String[] args) {
        long x = 010L;
        int y = 10;
        double z = 0xaD;
        System.out.println(x + y + z);
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="757">
		<introducao>A compilação do código abaixo falha.<java><![CDATA[public class Soma {
    public static void main(String[] args) {
        long x = 010L;
        int y = 10;
        float z = 0xaD;
        System.out.println(x + y + z);
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="758">
		<introducao>A compilação do código abaixo falha.<java><![CDATA[public class Soma {
    public static void main(String[] args) {
        long x = 010L;
        int y = 10;
        float z = 0xad;
        System.out.println(x + y + z);
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="759">
		<introducao>A declaração <stmt>boolean b = (boolean)0;</stmt> é inválida.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="760">
		<introducao>A declaração <stmt>boolean b = (boolean)1;</stmt>
            declara a variável <stmt>b</stmt> do tipo
            <stmt>boolean</stmt> e a inicia com o valor <stmt>true</stmt>.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="761">
		<introducao>Quando um <it>array</it> é construído,
            necessariamente o tamanho deve ser fornecido.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="762">
		<introducao>A compilação da sentença <stmt>int [] a = new
            int[];</stmt> falha.</introducao>
		<resposta valor="v">Falta o tamanho do <it>array</it>.</resposta>
	</questao>
	<questao id="763">
		<introducao>Além da possibilidade de criação de um
            <it>array</it> com <stmt>new</stmt>, também pode-se empregar
            uma sintaxe  que cria o <it>array</it> e, ao mesmo tempo,
            são fornecidos valores iniciais para os elementos deste, ao
            contrário dos valores <it>default</it>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="764">
		<introducao>É possível criar objetos sem o emprego da palavra reservada<stmt>new</stmt>.</introducao>
		<resposta valor="v">Criação de <it>array</it> é um exemplo.</resposta>
	</questao>
	<questao id="765">
		<introducao>O código <stmt>int[][] matriz = new int[][];</stmt>
            provoca um erro de compilação.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="766">
		<introducao>O código <stmt>int[][] matriz = new int[5][];</stmt>
            provoca um erro de compilação.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="767">
		<introducao>Em Java, <it>arrays</it> de mais de uma dimensão são
            tratados como <it>arrays</it> de <it>arrays</it>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="768">
		<introducao>O código abaixo, quando executado, exibe a média das
            notas fornecidas no <it>array</it>.<java><![CDATA[public class Array {
    public static void main(String[] args) {
        float[] notas = { 3.2, 4.6, 7.8, 9.3 };
        float soma = 0.0;
        for (int i = 0; i < notas.length; i++)
            soma += notas[i];

        System.out.println(soma/notas.length);
    }
}]]></java>
		</introducao>
		<resposta valor="f">Não compila.</resposta>
	</questao>
	<questao id="769">
		<introducao>O código abaixo, quando executado, exibe a média das
            notas fornecidas no <it>array</it>.<java><![CDATA[public class Array {
    public static void main(String[] args) {
        double[] notas = { 3.2, 4.6, 7.8, 9.3 };
        double soma;
        for (int i = 0; i < notas.length; i++)
            soma += notas[i];

        System.out.println(soma/notas.length);
    }
}]]></java>
		</introducao>
		<resposta valor="f">Variável <stmt>soma</stmt> não foi iniciada.</resposta>
	</questao>
	<questao id="770">
		<introducao>O código abaixo, quando executado, exibe a média das
            notas fornecidas no <it>array</it>.<java><![CDATA[public class Array {
    public static void main(String[] args) {
        double[] notas = { 3.2, 4.6, 7.8, 9.3 };
        double soma = 0.0;
        for (int i = 0; i <= notas.length; i++)
            soma += notas[i];

        System.out.println(soma/notas.length);
    }
}]]></java>
		</introducao>
		<resposta valor="f">Gera exceção em tempo de execução: <stmt>ArrayIndexOutOfBoundsException</stmt>.</resposta>
	</questao>
	<questao id="771">
		<introducao>O código abaixo, quando executado, exibe a média dos
            elementos do <it>array</it>.<java><![CDATA[public class Array {
    public static void main(String[] args) {
        double[] notas = { 3.2, 4.6, 7.8f, 9.3 };
        double soma = 0;
        for (int i = 0; i < notas.length; i++)
            soma += notas[i];

        System.out.println(soma/notas.length);
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="772">
		<introducao>O resultado exibido pelo código abaixo é <stmt>3</stmt>.<java><![CDATA[public class Array {
    public static void main(String[] args) {
        int[][] array = new int[1][0];
        array[0] = new int[10];
        array[0][0] = 1;
        array[0][1] = 2;
        System.out.println(array[0][0] + array[0][1]);
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="773">
		<introducao>O código abaixo não compila.<java><![CDATA[public class Array {
    public static void main(String[] args) {
        int[][] array = new int[1][0];
        array[0] = new int[10];
        array[0][0] = 1;
        array[0][1] = 2;
        System.out.println(array[0][0] + array[0][1]);
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="774">
		<introducao>O código abaixo gera uma exceção em tempo de execução.<java><![CDATA[public class Array {
    public static void main(String[] args) {
        int[][] array = new int[1][0];
        array[0] = new int[10];
        array[0][0] = 1;
        array[0][1] = 2;
        System.out.println(array[0][0] + array[0][1]);
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="775">
		<introducao>Iniciar um <it>array</it> significa depositar
            elementos nele, ou valores primitivos ou referências para objetos.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="776">
		<introducao>Não se deposita um objeto em um <it>array</it> mas a
            referência para um objeto.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="777">
		<introducao>Quando se diz  que um <it>array</it> de
            <stmt>String</stmt> está-se, na verdade, fazendo referência
            a um <it>array</it> de referências para <stmt>String</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="778">
		<introducao>Elementos de um <it>array</it> podem ser obtidos por
            meio de um índice.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="779">
		<introducao>Um <it>array</it> de X elementos possui como índices
            válidos qualquer valor no intervalo de 1 a X, inclusive.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="780">
		<introducao>Um <it>array</it> de X elementos possui como índices
            válidos qualquer valor no intervalo de 0 a (X-1), inclusive.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="781">
		<introducao>O valor impresso pelo código abaixo é <stmt>0</stmt>.<java><![CDATA[class Numero {
    int n;

    int getN() {
        return n;
    }
}

public class Array {
    public static void main(String[] args) {
        Numero[] aN = new int[2];
        System.out.println(aN[0].getN() + aN[1].getN());
    }
}]]></java>
		</introducao>
		<resposta valor="f">Não compila.</resposta>
	</questao>
	<questao id="782">
		<introducao>O valor impresso pelo código abaixo é <stmt>0</stmt>.<java><![CDATA[class Numero {
    int n;

    int getN() {
        return n;
    }
}

public class Array {
    public static void main(String[] args) {
        Numero[] aN = new Numero(2);
        System.out.println(aN[0].getN() + aN[1].getN());
    }
}]]></java>
		</introducao>
		<resposta valor="f">Não compila.</resposta>
	</questao>
	<questao id="783">
		<introducao>O valor impresso pelo código abaixo é <stmt>0</stmt>.<java><![CDATA[class Numero {
    int n;

    int getN() {
        return n;
    }
}

public class Array {
    public static void main(String[] args) {
        Numero[] aN = new Numero[2];
        System.out.println(aN[0].getN() + aN[1].getN());
    }
}]]></java>
		</introducao>
		<resposta valor="f">Gera exceção <stmt>NullPointerException</stmt>.</resposta>
	</questao>
	<questao id="784">
		<introducao>O código abaixo gera uma exceção.<java><![CDATA[class Numero {
    int n;

    int getN() {
        return n;
    }
}

public class Array {
    public static void main(String[] args) {
        Numero[] aN = new Numero[2];
        aN[0] = new Numero();
        aN[1] = new Numero();
        System.out.println(aN[0].getN() + aN[1].getN());
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="785">
		<introducao>O código abaixo imprime o valor 0 quando executado.<java><![CDATA[class Numero {
    int n;

    int getN() {
        return n;
    }
}

public class Array {
    public static void main(String[] args) {
        Numero[] aN = new Numero[2];
        aN[0] = new Numero();
        aN[1] = new Numero();
        System.out.println(aN[0].getN() + aN[1].getN());
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="786">
		<introducao>A execução do código abaixo imprime os valores 2 e 2.<java><![CDATA[public class Array {
    public static void main(String[] args) {
        byte[][] b = new byte[2][2];
        byte[] aux = new byte[1];
        int soma = 0;

        b[0][0] = 1;
        b[0][1] = 1;

        for (int i = 0; i < b.length; i++)
            soma += b[0][i];
        System.out.println(soma);

        b[0] = aux;
        for (int i = 0; i < b.length; i++)
            soma += b[0][i];
        System.out.println(soma);
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="787">
		<introducao>A execução do código abaixo imprime os valores 2 e 4
            (nesta ordem).<java><![CDATA[public class Array {
    public static void main(String[] args) {
        byte[][] b = new byte[2][2];
        byte[] aux = new byte[1];
        int soma = 0;

        b[0][0] = 1;
        b[0][1] = 1;

        for (int i = 0; i < b.length; i++)
            soma += b[0][i];
        System.out.println(soma);

        b[0] = aux;
        for (int i = 0; i < b.length; i++)
            soma += b[0][i];
        System.out.println(soma);
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="788">
		<introducao>A execução do código abaixo imprime os valores 2 e 0
            (nesta ordem).<java><![CDATA[public class Array {
    public static void main(String[] args) {
        byte[][] b = new byte[2][2];
        byte[] aux = new byte[1];
        int soma = 0;

        b[0][0] = 1;
        b[0][1] = 1;

        for (int i = 0; i < b.length; i++)
            soma += b[0][i];
        System.out.println(soma);

        b[0] = aux;
        for (int i = 0; i < b.length; i++)
            soma += b[0][i];
        System.out.println(soma);
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="789">
		<introducao>O código abaixo não compila.<java><![CDATA[public class Array {
    public static void main(String[] args) {
        byte[][] b = new byte[2][2];
        byte[] aux = new byte[1];
        int soma = 0;

        b[0][0] = 1;
        b[0][1] = 1;

        for (int i = 0; i < b.length; i++)
            soma += b[0][i];
        System.out.println(soma);

        b[0] = aux;
        for (int i = 0; i < b.length; i++)
            soma += b[0][i];
        System.out.println(soma);
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="790">
		<introducao>O código abaixo gera a exceção <stmt>ArrayIndexOutOfBoundsException</stmt>.<java><![CDATA[public class Array {
    public static void main(String[] args) {
        byte[][] b = new byte[2][2];
        byte[] aux = new byte[1];
        int soma = 0;

        b[0][0] = 1;
        b[0][1] = 1;

        for (int i = 0; i < b.length; i++)
            soma += b[0][i];
        System.out.println(soma);

        b[0] = aux;
        for (int i = 0; i < b.length; i++)
            soma += b[0][i];
        System.out.println(soma);
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="791">
		<introducao>Pode-se criar um <it>array</it> de duas dimensões
            onde os elementos de uma dimensão são do tipo
            <stmt>int</stmt> e da outra dimensão do tipo <stmt>float</stmt>.</introducao>
		<resposta valor="f">Todos os elementos de um <it>array</it>
            são do mesmo tipo.</resposta>
	</questao>
	<questao id="792">
		<introducao>Para acrescentar 5 elementos no <it>array</it>
			<stmt>Array</stmt>do tipo <stmt>int</stmt> de 3 elementos,
            basta redefinir o tamanho deste como <stmt>Array.length += 5;</stmt>.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="793">
		<introducao>O código abaixo imprime o valor 0.<java><![CDATA[public class Array {
    public static void main(String[] args) {
        int[] a;
        System.out.println(a.length);
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="794">
		<introducao>O código abaixo gera a exceção <stmt>NullPointerException</stmt>.<java><![CDATA[public class Array {
    public static void main(String[] args) {
        int[] a;
        System.out.println(a.length);
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="795">
		<introducao>O código abaixo não compila.<java><![CDATA[public class Array {
    public static void main(String[] args) {
        int[] a;
        System.out.println(a.length);
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="796">
		<introducao>O código abaixo não compila.<java><![CDATA[public class Array {
    static int[] a;

    public static void main(String[] args) {
        System.out.println(a.length);
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="797">
		<introducao>O código abaixo imprime o valor 0.<java><![CDATA[public class Array {
    static int[] a;

    public static void main(String[] args) {
        System.out.println(a.length);
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="798">
		<introducao>O código abaixo gera a exceção <stmt>NullPointerException</stmt>.<java><![CDATA[public class Array {
    static int[] a;

    public static void main(String[] args) {
        System.out.println(a.length);
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="799">
		<introducao>O código abaixo gera a exceção <stmt>NullPointerException</stmt>.<java><![CDATA[public class Array {
    static int[] a;

    public static void main(String[] args) {
        a.length = 2;
        a[0] = 1;
        a[1] = 2;
        System.out.println(a[0] + a[1]);
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="800">
		<introducao>O código abaixo imprime o valor 3.<java><![CDATA[public class Array {
    static int[] a;

    public static void main(String[] args) {
        a.length = 2;
        a[0] = 1;
        a[1] = 2;
        System.out.println(a[0] + a[1]);
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="801">
		<introducao>O código abaixo gera uma exceção.<java><![CDATA[public class Array {
    static int[] a;

    public static void main(String[] args) {
        a.length = 2;
        a[0] = 1;
        a[1] = 2;
        System.out.println(a[0] + a[1]);
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="802">
		<introducao>O código abaixo não compila.<java><![CDATA[public class Array {
    static int[] a;

    public static void main(String[] args) {
        a.length = 2;
        a[0] = 1;
        a[1] = 2;
        System.out.println(a[0] + a[1]);
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="803">
		<introducao>O código abaixo gera a exceção <stmt>NullPointerException</stmt>.<java><![CDATA[public class Array {
    static int[] a;

    public static void main(String[] args) {
        a = new int[2];
        a[0] = 1;
        a[1] = 2;
        System.out.println(a[0] + a[1]);
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="804">
		<introducao>O código abaixo gera a exceção <stmt>NullPointerException</stmt>.<java><![CDATA[public class Array {
    static int[] a;

    public static void main(String[] args) {
        a = new int[4];
        a[0] = 1;
        a[1] = 2;
        System.out.println(a[0] + a[1]);
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="805">
		<introducao>A sentença <stmt>int[] notas = { 9, 9, 8, 10
            };</stmt> declara uma variável do tipo referência para um
            <it>array</it> de elementos do tipo primitivo <stmt>int</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="806">
		<introducao>A sentença <stmt>int[] notas = { 9, 9, 8, 10
            };</stmt> cria um <it>array</it> de 4 elementos do tipo
            primitivo <stmt>int</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="807">
		<introducao>A sentença <stmt>int[] notas = { 9, 9, 8, 10
            };</stmt> cria um <it>array</it> de 4 elementos do tipo
            primitivo <stmt>int</stmt> e os inicia com os valores 9, 9,
            8 e 10, respectivamente nas posições 0, 1, 2 e 3 do <it>array</it>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="808">
		<introducao>A sentença <stmt>int[] notas = { 9, 9, 8, 10
            };</stmt> atribui o objeto <it>array</it> criado à variável
            do tipo referência <stmt>notas</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="809">
		<introducao>A sentença <stmt>int[] notas = { 9, 9, 8, 10
            };</stmt> é funcionalmente equivalente ao código abaixo.<java><![CDATA[int[] notas;
notas = new int[4];
notas[0] = 9;
notas[1] = notas[0];
notas[2] = 8;
notas[3] = 10;]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="810">
		<introducao>O código abaixo imprime o valor 0.<java><![CDATA[public class Array {
    public static void main(String[] args) {
        int[] valores = {}
        System.out.println(valores.length);
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="811">
		<introducao>O código abaixo não compila.<java><![CDATA[public class Array {
    public static void main(String[] args) {
        int[] valores = {}
        System.out.println(valores.length);
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="812">
		<introducao>O código abaixo imprime o valor 0.<java><![CDATA[public class Array {
    public static void main(String[] args) {
        int[] valores = {};
        System.out.println(valores.length);
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="813">
		<introducao>O código abaixo gera a exceção <stmt>NullPointerException</stmt>.<java><![CDATA[public class Array {
    public static void main(String[] args) {
        int[] valores = {};
        System.out.println(valores.length);
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="814">
		<introducao>O código abaixo imprime os valores 0 e 50, nesta ordem.<java><![CDATA[public class Array {
    public static void main(String[] args) {
        int[] valores = {};
        System.out.println(valores.length);
        valores = new int[50];
        System.out.println(valores.length);
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="815">
		<introducao>O código abaixo não compila.<java><![CDATA[public class Array {
    public static void main(String[] args) {
        int[] valores = {};
        System.out.println(valores.length);
        valores = new int[50];
        System.out.println(valores.length);
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="816">
		<introducao>Em tempo de execução, o código abaixo gera uma exceção.<java><![CDATA[public class Array {
    public static void main(String[] args) {
        int[] valores = {};
        System.out.println(valores.length);
        valores = new int[50];
        System.out.println(valores.length);
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="817">
		<introducao>A sentença <stmt>int[][] x = { { 1 }, { 2, 3 }, { 4,
                5, 6 } };</stmt> gera um erro de compilação.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="818">
		<introducao>A sentença <stmt>int[][] x = { { 1 }, { 2, 3 }, { 4,
                5, 6 } };</stmt> declara uma variável do tipo referência
            denominada <stmt>x</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="819">
		<introducao>A sentença <stmt>int[][] x = { { 1 }, { 2, 3 }, { 4,
                5, 6 } };</stmt> cria um único objeto no <it>heap</it>.</introducao>
		<resposta valor="f">Cria 4 objetos.</resposta>
	</questao>
	<questao id="820">
		<introducao>A sentença <stmt>int[][] x = { { 1 }, { 2, 3 }, { 4,
                5, 6 } };</stmt> cria 4 (quatro) objetos no <it>heap</it>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="821">
		<introducao>A sentença <stmt>int[][] x = { { 1 }, { 2, 3 }, { 4,
                5, 6 } };</stmt> cria um <it>array</it> de
            <it>arrays</it> de elementos do tipo <stmt>int</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="822">
		<introducao>A sentença <stmt>int[][] x = { { 1 }, { 2, 3 }, { 4,
                5, 6 } };</stmt> cria um <it>array</it> contendo três
            referências para outros três objetos (referências para
            <it>arrays</it> de inteiros).</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="823">
		<introducao>A sentença <stmt>int[][] x = { { 1 }, { 2, 3 }, { 4,
                5, 6 } };</stmt> faz com que o segundo elemento de
            <stmt>x</stmt> seja uma referência para um objeto, que é um
            <it>array</it> contendo dois elementos, onde o segundo deles
            é <stmt>2</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="824">
		<introducao>Em Java, os <it>arrays</it> de múltiplas dimensões
            não precisam ser compostos por elementos que possuem os
            mesmos tamanhos. Por exemplo, <stmt>short[][] Short;</stmt>
            declara a variável do tipo referência <stmt>Short</stmt> que
            é um <it>array</it> de <it>arrays</it>. Cada um dos
            <it>arrays</it>, <stmt>Short[0]</stmt>,
            <stmt>Short[1]</stmt> e assim por diante, pode ter uma
            quantidade de elementos diferente dos demais.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="825">
		<introducao>Para a sentença <stmt>byte b[][] = { { -1, 20, -30,
                3}, {}, { 1, 2, 1 }, { 3, 4, 5 }};</stmt> a condição
                <stmt>b[0][0] == -1</stmt> é verdadeira.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="826">
		<introducao>Para a sentença <stmt>byte b[][] = { { -1, 20, -30,
                3}, {}, { 1, 2, 1 }, { 3, 4, 5 }};</stmt> a condição
                <stmt>b[1] == null</stmt> é verdadeira.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="827">
		<introducao/>
		<resposta valor="v"/>
	</questao>
	<questao id="828">
		<introducao>A sentença <stmt>System.out.println((new
            int[]{1}).length);</stmt> não compila.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="829">
		<introducao>A sentença <stmt>System.out.println((new
            int[]{2}).length);</stmt> imprime o valor 1.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="830">
		<introducao>A declaração da variável <stmt>i</stmt> via a
            sentença <stmt>int i = (new int[]{}).length;</stmt> deposita
            em <stmt>i</stmt> o valor inicial 0.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="831">
		<introducao>A sentença <stmt>int i = (new
            int[1]{2}).length;</stmt> não compila.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="832">
		<introducao>Se <stmt>a</stmt> é uma variável do tipo referência
            para um <it>array</it> de inteiros, então <stmt>a</stmt>
            pode receber a referência de qualquer outro objeto que é um
            <it>array</it> de inteiros, independente do tamanho deste.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="833">
		<introducao>A compilação do código abaixo não falha.<java><![CDATA[byte b[] = new byte[10];
        int i[] = b;]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="834">
		<introducao>O código abaixo gera um exceção em tempo de execução.<java><![CDATA[byte b[] = new byte[10];
        int i[] = b;]]></java>
		</introducao>
		<resposta valor="f">O código não compila.</resposta>
	</questao>
	<questao id="835">
		<introducao>Se a classe <stmt>A</stmt> é derivada de
            <stmt>B</stmt>, então uma variável do tipo referência para
            um <it>array</it> de <stmt>B</stmt> pode receber a
            referência de um objeto <it>array</it> cujos elementos são <stmt>A</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="836">
		<introducao>Se a classe <stmt>A</stmt> é derivada de
            <stmt>B</stmt>, então uma variável do tipo referência para
            um <it>array</it> de <stmt>A</stmt> pode receber a
            referência de um objeto <it>array</it> cujos elementos são <stmt>B</stmt>.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="837">
		<introducao>Um <it>array</it> declarado como de um tipo
            interface pode referenciar qualquer <it>array</it> de
            qualquer tipo que implementa a interface.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="838">
		<introducao>Variável local é declarada no interior de um método
            ou na lista de argumentos de um método.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="839">
		<introducao>Variável de instância é declarada no interior de uma
            classe, mas fora de qualquer método ou construtor.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="840">
		<introducao>Atribuições entre referências para <it>arrays</it>
            exigem, para que possam ser realizadas satisfatoriamente,
            que necessariamente possuam a mesma quantidade de dimensões
            (não é tamanho).</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="841">
		<introducao>A compilação do código abaixo falha.<java><![CDATA[        byte b[] = new byte[10];
        byte bb[][] = new byte[2][];
        bb[0] = b;
        bb = b;
        bb[0][0] = b;
]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="842">
		<introducao>No código abaixo, duas sentenças provacam erros de compilação.<java><![CDATA[        byte b[] = new byte[10];
        byte bb[][] = new byte[2][];
        bb[0] = b;
        bb = b;
        bb[0][0] = b;
]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="843">
		<introducao>Variáveis localis também são chamadas de
            <it>stack</it>, temporárias, automáticas ou variáveis de métodos.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="844">
		<introducao>É possível criar aplicações em Java em que pelo
            menos uma variável local não é inicializada e a compilação
            não falha.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="845">
		<introducao>Variável local não iniciada e que se tenta fazer uso
            gera um erro em tempo de execução.</introducao>
		<resposta valor="f">Em tempo de compilação.</resposta>
	</questao>
	<questao id="846">
		<introducao>Variável local não iniciada e que se tenta fazer uso
            gera um erro em tempo de compilação.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="847">
		<introducao>Variáveis de instância também são chamadas de
            membros e são declaradas no nível de classe.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="848">
		<introducao>Variáveis de instâncias que não são
            <stmt>static</stmt> recebem seus respectivos valores cada
            vez que uma instância da classe é criada.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="849">
		<introducao>Variáveis locais não recebem automaticamente valores
            <it>default</it> em qualquer que seja a situação. É preciso,
            antes de empregá-las, explicitamente fornecer um valor inicial.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="850">
		<introducao>A declaração <stmt>String str = null;</stmt> é
            similar à declaração <stmt>String str = &quot;&quot;;</stmt>.</introducao>
		<resposta valor="f">Na primeira, não há objeto
            <stmt>String</stmt> disponível no <it>heap</it>. Na segunda,
            há um objeto cuja seqüência de caracteres é vazia.</resposta>
	</questao>
	<questao id="851">
		<introducao>A compilação do código abaixo não falha.<java><![CDATA[public class Restaurante {
    private String nome;

    public static void main(String[] args) {
        Restaurante obj = new Restaurante();
        String nome = obj.getNome();
        System.out.println(nome.toLowerCase());
    }

    public String getNome() {
        return nome;
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="852">
		<introducao>A execução do código abaixo gera uma exceção.<java><![CDATA[public class Restaurante {
    private String nome;

    public static void main(String[] args) {
        Restaurante obj = new Restaurante();
        String nome = obj.getNome();
        System.out.println(nome.toLowerCase());
    }

    public String getNome() {
        return nome;
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="853">
		<introducao>Quando executado, o código abaixo imprime <stmt>NULL</stmt>.<java><![CDATA[public class Restaurante {
    private String nome;

    public static void main(String[] args) {
        Restaurante obj = new Restaurante();
        String nome = obj.getNome();
        System.out.println(nome.toUpperCase());
    }

    public String getNome() {
        return nome;
    }
}]]></java>
		</introducao>
		<resposta valor="f">Gera exceção <stmt>NullPointerException</stmt>.</resposta>
	</questao>
	<questao id="854">
		<introducao>Se uma referência para um determinado tipo possui o
            valor <stmt>null</stmt>, então qualquer tentativa de fazer
            uso da variável que contém esta referência, por exemplo,
            para se ter acesso a um método do tipo, irá provocar a
            exceção <stmt>NullPointerException</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="855">
		<introducao>Se o tipo classe <stmt>Aluno</stmt> possui um membro
            público do tipo <stmt>String</stmt> cuja variável é
            <stmt>nome</stmt>, então tentar o acesso a este membro
            através de <stmt>a.nome.toUpperCase();</stmt>, por exemplo,
            imediatamente após <stmt>Aluno a = null</stmt> irá gerar a
            exceção <stmt>NullReferenceException</stmt>.</introducao>
		<resposta valor="f">A exceção correta é <stmt>NullPointerException</stmt>.</resposta>
	</questao>
	<questao id="856">
		<introducao>Uma variável de instância do tipo <it>array</it> que
            não foi explicitamente iniciada terá o valor
            <stmt>null</stmt> fornecido como <it>default</it>, assim
            como qualquer outra variável de instância do tipo referência.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="857">
		<introducao>Elementos de um <it>array</it> sempre, após a
            criação do mesmo, iniciados com o valor <it>default</it> correspondente.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="858">
		<introducao>Após a sentença <stmt>boolean[] b = new
            boolean[10];</stmt>, todos os elementos de <stmt>b</stmt>
            contém o valor correspondente à literal <stmt>false</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="859">
		<introducao>Variáveis locais, quando se deseja fazer uso deles,
            sempre devem ser iniciadas.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="860">
		<introducao>Não é fornecido um valor <it>default</it> para
            variáveis locais em Java.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="861">
		<introducao>Pode-se declarar uma variável local e não fornecer
            um valor inicial para ela, desde que também ela não seja
            utilizada. Embora sem utilidade prática, o compilador não reclama.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="862">
		<introducao>A declaração da variável de instância <stmt>String
            str;</stmt> faz com que <stmt>str</stmt> receba o valor
            <stmt>null</stmt> quando uma instância da classe em questão
            é criada.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="863">
		<introducao>A declaração da variável local <stmt>String
            str;</stmt> faz com que a condição <stmt>str != null</stmt>,
            imediatamente em uma sentença que segue a declaração, gere
            um erro em tempo de compilação.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="864">
		<introducao>Uma referência <stmt>null</stmt> é o mesmo que uma
            referência não iniciada.</introducao>
		<resposta valor="f">No corpo de um método, uma referência
            não iniciada que se tenta fazer uso gera um erro de compilação.</resposta>
	</questao>
	<questao id="865" objetivo="4.3">
		<introducao>O método <stmt>main</stmt> é o método chamado pela
            máquina virtual Java quando se executa uma aplicação em Java.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="866" objetivo="4.3">
		<introducao>O método <stmt>main</stmt> chamado pela máquina
            virtual Java necessariamente possui um único argumento: um
            <it>array</it> do tipo <stmt>String</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="867" objetivo="4.3">
		<introducao>O nome do argumento do método <stmt>main</stmt>
            invocado pela máquina virtual Java necessariamente deve se
            chamar <stmt>args</stmt>.</introducao>
		<resposta valor="f">Qualquer identificador válido pode ser
            empregado, por exemplo <stmt>$linhaDeComandos</stmt>.</resposta>
	</questao>
	<questao id="868" objetivo="4.3">
		<introducao>
			<stmt>main</stmt> é palavra reservada de Java.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="869" objetivo="4.3">
		<introducao>A compilação do código abaixo falha.<java><![CDATA[final public class main {
    static final public void main(final String $s[]) {}
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="870" objetivo="4.3">
		<introducao>O código abaixo não correspondente a uma aplicação
            em Java, visto que o método <stmt>main</stmt> necessário em
            toda aplicação Java não é fornecido.<java><![CDATA[public class Teste {
    static final public void main(final String $s[]) {}
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="871" objetivo="4.3">
		<introducao>O programa abaixo adequadamente percorre e imprime
            todos os argumentos fornecidos na linha de comando quando
            uma aplicação é chamada. Em particular, se nenhum argumento
            é fornecido, então a aplicação imprime uma mensagem compatível.<java><![CDATA[public class main {
    public static void main(String[] args) {
        if (args.length == 0) {
            System.out.println("Nenhum argumento fornecido.");
        }

        for (int i = 0; i < args.length; i++) {
            System.out.println(i + ": " + args[i]);
        }
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="872" objetivo="4.3">
		<introducao>A compilação do código abaixo falha.<java><![CDATA[public class main {
    private static int n = -1;

    public static void main(String[] args) {
        if (n == -1) {
            n = args.length;
        }

        if (n == 0) {
            return;
        }

        int vez = n;
        n = n - 1;
        main(args);
        System.out.println(args[vez-1]);
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="873" objetivo="4.3">
		<introducao>O código abaixo, quando executado, entra em um laço
            infinito (não pára).<java><![CDATA[public class main {
    private static int n = -1;

    public static void main(String[] args) {
        if (n == -1) {
            n = args.length;
        }

        if (n == 0) {
            return;
        }

        int vez = n;
        n = n - 1;
        main(args);
        System.out.println(args[vez-1]);
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="874" objetivo="4.3">
		<introducao>O código abaixo exibe os argumentos fornecidos na
            linha de comandos na ordem em que foram fornecidos.<java><![CDATA[public class main {
    private static int n = -1;

    public static void main(String[] args) {
        if (n == -1) {
            n = args.length;
        }

        if (n == 0) {
            return;
        }

        int vez = n;
        n = n - 1;
        main(args);
        System.out.println(args[vez-1]);
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="875" objetivo="4.3">
		<introducao>O código abaixo necessariamente imprime a mensagem
            <stmt>fim</stmt> quando executado.<java><![CDATA[public class main {
    private static int n = -1;

    public static void main(String[] args) {
        System.out.println(args[0]);
        System.out.println("fim");        
    }
}]]></java>
		</introducao>
		<resposta valor="f">Quando nenhum argumento é fornecido
            tem-se que <stmt>args.length == 0</stmt> e, portanto, uma
            tentativa de acesso a <stmt>args[0]</stmt> gera a exceção
            <stmt>ArrayIndexOutOfBoundsException</stmt>, o que impede a
            execução de outras sentenças deste código.</resposta>
	</questao>
	<questao id="876" objetivo="1.2">
		<introducao>Um método declarado <stmt>public</stmt> pode ser
            chamado de qualquer outro ponto da aplicação em questão.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="877" objetivo="1.2">
		<introducao>Um método declarado <stmt>private</stmt> só pode ser
            chamado do alguma posição no interior da classe na qual este
            é declarado.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="878" objetivo="1.2">
		<introducao>Só pode existir uma classe declarada
            <stmt>public</stmt> por arquivo contendo código fonte em Java.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="879" objetivo="1.2">
		<introducao>O nome de um arquivo deve ser o mesmo da classe
            declarada <stmt>public</stmt> neste arquivo.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="880" objetivo="1.2">
		<introducao>Se uma classe faz parte de um <stmt>package</stmt>,
            então a declaração do pacote deve ser a primeira sentença do
            arquivo fonte.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="881" objetivo="1.2">
		<introducao>Se um arquivo contém sentenças <stmt>import</stmt>,
            então estas sentenças devem vir após a declaração
            <stmt>package</stmt>, caso o código deste arquivo faça parte
            de um pacote.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="882" objetivo="1.2">
		<introducao>Se um código em Java não faz parte de um
                <stmt>package </stmt>, então sentenças
            <stmt>import</stmt> podem ser as primeiras do arquivo em questão.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="883" objetivo="1.2">
		<introducao>A sentença <stmt>package</stmt> e as sentenças
            <stmt>import</stmt> eventualmente existentes em um arquivo
            aplicam-se a todas as classes contidas neste arquivo.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="884" objetivo="1.2">
		<introducao>O &quot;esqueleto&quot; da declaração de uma classe
            é <stmt>public class NomeClasse {}</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="885" objetivo="1.2">
		<introducao>O código <stmt>public class Teste {}</stmt> compila
            satisfatoriamente, gerando um arquivo de nome <it>Teste.class</it>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="886" objetivo="1.2">
		<introducao>Antes da declaração de uma classe podem seguir
            modificadores, que incluem: <stmt>public</stmt>,
            <stmt>protected</stmt>, <stmt>private</stmt>,
            <stmt>strictfp</stmt>, <stmt>final</stmt> e <stmt>abstract</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="887" objetivo="1.2">
		<introducao>Em Java existem 4 (quatro) níveis de controle de acesso.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="888" objetivo="1.2">
		<introducao>Em Java existem 4 (quatro) níveis de controle de
            acesso e apenas 3 (três) modificadores de acesso.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="889" objetivo="1.2">
		<introducao>Os modificadores de acesso são: <stmt>public</stmt>,
            <stmt>protected</stmt> e <stmt>private</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="890" objetivo="1.2">
		<introducao>Quando nenhum dos três modificadores de acesso é
            empregado, então o nível de acesso é o nível
            <it>default</it> ou de <it>package</it> (pacote).</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="891" objetivo="1.2">
		<introducao>Em Java, toda classe, método e variável de instância
            tem um controle de acesso, estabelecido explicitamente ou não.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="892" objetivo="1.2">
		<introducao>Uma classe só pode ser declarada, da perspectiva de
            controle de acesso, como <stmt>public</stmt> ou de controle
            de acesso <it>default</it>. Os outros dois níveis de
            controle de acesso não fazem sentido para uma classe.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="893" objetivo="1.2">
		<introducao>Controle de acesso significa visibilidade e, de
            fato, quando se diz que uma classe <stmt>A</stmt> tem acesso
            a uma classe <stmt>B</stmt>, significa que <stmt>A</stmt> ou
            pode criar instância da classe <stmt>B</stmt>, ou estender a
            classe <stmt>B</stmt> (herança) ou ter acesso a métodos ou
            variáveis  que fazem parte da classe <stmt>B</stmt>,
            conforme o controle de acesseo destes métodos e variáveis.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="894" objetivo="1.2">
		<introducao>Uma classe cujo controle de acesso é
            <it>default</it> não é precedida por modificador de acesso
            quando declarada.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="895" objetivo="1.2">
		<introducao>Se não é fornecido um controle de acesso para uma
            classe, então o controle é o <it>default</it>, que é
            estabelecido quando nenhum outro modificador é
            explicitamente fornecido.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="896" objetivo="1.2">
		<introducao>Uma classe com o controle de acesso <it>default</it>
            pode ser <it>vista</it> somente por classes que fazem parte
            do mesmo pacote.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="897" objetivo="1.2">
		<introducao>Se as classes <stmt>A</stmt> e <stmt>B</stmt> fazem
            parte de pacotes distintos e o nível de controle de acesso
            delas é o <it>default</it>, então nenhuma delas é visível a outra.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="898" objetivo="1.2">
		<introducao>Se a classe <stmt>Leite</stmt> faz parte do pacote
            <stmt>agropecuaria</stmt> e a classe <stmt>Resfriador</stmt>
            faz parte do pacote <stmt>industria</stmt>, então nenhuma
            destas classes é visível a outra, em outras palavras, é como
            se para cada uma delas a outra simplesmente não existisse.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="899" objetivo="1.2">
		<introducao>Se uma classe em construção e que faz parte do
            pacote <stmt>A</stmt> tenta herdar uma classe do pacote
            <stmt>B</stmt>, cuja declaração é <stmt>classe Raiz
            {}</stmt>, então a compilação desta tentativa de criar uma
            subclasse falha.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="900" objetivo="1.2">
		<introducao>A compilação de uma classe de um pacote
            <stmt>X</stmt>, que tenta fazer acesso a uma classe  cujo
            controle de acesso é <it>default</it> e faz parte de um
            pacote <stmt>Y</stmt>, falha.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="901" objetivo="1.2">
		<introducao>Uma classe declarada como <stmt>public</stmt> é
            visível em todas as classes, quaisquer que sejam os pacotes
            que estas classes pertençam.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="902" objetivo="1.2">
		<introducao>Todas as classes do universo Java têm acesso às
            classes declaradas como <stmt>public</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="903" objetivo="1.2">
		<introducao>Se uma classe declarada como <stmt>public</stmt>
            pertence a um pacote diferente de uma classe que faz uso
            desta classe declarada como <stmt>public</stmt>, então a
            classe que faz uso deve conter a sentença
            <stmt>import</stmt> para importar a classe declarada como <stmt>public</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="904" objetivo="1.2">
		<introducao>Para que uma classe seja visível em todas as classes
            de todos os pacotes, esta deve ser declarada como <stmt>public</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="905" objetivo="1.2">
		<introducao>Se uma classe <stmt>B</stmt> não é declarada
            <stmt>final</stmt> e não pode ser herdada por uma classe
            <stmt>A</stmt>, então o controle de acesso de <stmt>B</stmt>
            é <it>default</it> e o pacote ao qual a classe
            <stmt>A</stmt> pertence é diferente daquele que
            <stmt>B</stmt> pertence.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="906" objetivo="1.2">
		<introducao>Da perspectiva de um dado pacote, todas as classes
            ali contidas ou são visíveis exclusivamente no interior do
            pacote, o que é estabelecido quando não se emprega o
            modificador de acesso <stmt>public</stmt> quando da
            declaração da classe, ou esta é declarada como
            <stmt>public</stmt> e todas as demais do universo Java
            possuem acesso a ela.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="907" objetivo="1.2">
		<introducao>A declaração de uma classe pode ser modificada, além
            do emprego de algum modificador de acesso, através das
            palavras reservadas <stmt>final</stmt>,
            <stmt>abstract</stmt> ou <stmt>strictfp</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="908" objetivo="1.2">
		<introducao>Uma classe pode ser declarada <stmt>public</stmt> e <stmt>final</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="909" objetivo="1.2">
		<introducao>A declaração <stmt>final public class B {}</stmt> é válida.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="910" objetivo="1.2">
		<introducao>Uma classe pode ser declarada <stmt>abstract</stmt>
            e <stmt>final</stmt>.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="911" objetivo="1.2">
		<introducao>Uma classe pode ser declarada <stmt>abstract</stmt>
            pode possuir uma subclasse declarada  <stmt>final</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="912" objetivo="1.2">
		<introducao>Uma classe pode ser declarada <stmt>strictfp</stmt>
            e <stmt>final</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="913" objetivo="1.2">
		<introducao>Uma classe pode ser declarada <stmt>strictfp</stmt>
            e <stmt>abstract</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="914" objetivo="1.2">
		<introducao>A compilação de <stmt>abstract strictfp public class
                C {}</stmt> falha.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="915" objetivo="1.2">
		<introducao>A compilação de <stmt>abstract public strictfp
                class C {}</stmt> falha.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="916" objetivo="1.2">
		<introducao>A compilação de <stmt>strictfp abstract public class
                C {}</stmt> falha.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="917" objetivo="1.2">
		<introducao>
			<stmt>strictfp</stmt> pode ser empregada para modificar uma variável.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="918" objetivo="1.2">
		<introducao>
			<stmt>strictfp</stmt> pode ser empregada para modificar um método.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="919" objetivo="1.2">
		<introducao>
			<stmt>strictfp</stmt> pode ser empregada para modificar uma classe.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="920" objetivo="1.2">
		<introducao>Uma variável nunca pode ser declarada <stmt>strictfp</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="921" objetivo="1.2">
		<introducao>Declarar uma classe como <stmt>strictf</stmt>
            significa que todo método da classe irá seguir as regras do
            padrão IEEE 754 para operações em ponto-flutuante.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="922" objetivo="1.2">
		<introducao>Se uma classe não é declarada <stmt>strictfp</stmt>,
            então operações em ponto-flutuante podem se comportar de
            forma depentende de plataforma.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="923" objetivo="1.2">
		<introducao>Mesmo que uma classe não seja declarada
            <stmt>strictfp</stmt>, ela pode apresentar o mesmo
            comportamento se fosse declarada <stmt>strictfp</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="924" objetivo="1.2">
		<introducao>Declarar uma classe como <stmt>strictfp</stmt> é o
            mesmo que declarar todos os seus métodos como <stmt>strictfp</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="925" objetivo="1.2">
		<introducao>O código abaixo compila satisfatoriamente.<java><![CDATA[strictfp abstract public class C {
    strictfp float f() { return 1.0f; }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="926">
		<introducao>O código abaixo compila satisfatoriamente.<java><![CDATA[strictfp abstract public class C {
    float f() { return 1.0; }
}]]></java>
		</introducao>
		<resposta valor="f">A literal <stmt>1.0</stmt> não é do tipo <stmt>float</stmt>.</resposta>
	</questao>
	<questao id="927" objetivo="1.2">
		<introducao>Quando usada na declaração de uma classe, a palavra
            reservada <stmt>final</stmt> significa que a classe em
            questão não pode possuir descendente (subclasse).</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="928">
		<introducao>
			<stmt>extend</stmt> é palavra reservada.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="929" objetivo="1.2">
		<introducao>A declaração <stmt>class D extends C {}</stmt> é
            válida se a classe <stmt>C</stmt> é declarada como <stmt>final</stmt>.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="930" objetivo="1.2">
		<introducao>Se há dependência específica e imprescindível da
            implementação de métodos de uma classe, então a declaração
            da classe como <stmt>final</stmt> garante que estas
            implementações não serão alteradas (<it>overridden</it>).</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="931">
		<introducao>A classe que contém o método <stmt>main</stmt> a ser
            executado quando da execução da aplicação em questão deve,
            necessariamente, ser declarada <stmt>public</stmt>.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="932">
		<introducao>A compilação do código abaixo falha.<java><![CDATA[strictfp public class C {
    public static void main(String[] args) {
        System.out.println("main C");
    }
}

class D extends C {
    public static void main(String[] args) {
        System.out.println("main D");
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="933" objetivo="1.2">
		<introducao>A tentativa de execução da classe <stmt>D</stmt>
            gera uma exceção.<java><![CDATA[strictfp public class C {
    public static void main(String[] args) {
        System.out.println("main C");
    }
}

class D extends C {}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="934" objetivo="1.2">
		<introducao>Ao fornecer a classe <stmt>D</stmt> para que a
            máquina virtual Java a execute, a mensagem <stmt>main
            C</stmt> é impressa.<java><![CDATA[strictfp public class C {
    public static void main(String[] args) {
        System.out.println("main C");
    }
}

class D extends C {}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="935" objetivo="1.2">
		<introducao>O motivo da existência de uma classe
            <stmt>abstract</stmt> é ser herdada.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="936" objetivo="1.2">
		<introducao>Não se pode criar instância(s) de uma classe <stmt>abstract</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="937" objetivo="1.2">
		<introducao>Não se pode criar instância(s) de uma classe
            diretamente derivada de uma classe <stmt>abstract</stmt>.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="938" objetivo="1.2">
		<introducao>A compilação do código abaixo falha.<java><![CDATA[public abstract class E {}
class F extends E {}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="939" objetivo="1.2">
		<introducao>Uma classe declarada <stmt>abstract</stmt> deve
            possuir pelo menos um método <stmt>abstract</stmt>.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="940" objetivo="1.2">
		<introducao>Uma classe que possui pelo menos um método
            <stmt>abstract</stmt> deve ser declarada <stmt>abstract</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="941" objetivo="1.2">
		<introducao>A compilação do código abaixo falha.<java><![CDATA[public abstract class E {
    abstract void ok();
}

class F extends E {}]]></java>
		</introducao>
		<resposta valor="v">Observe que a classe <stmt>F</stmt>
            não implementa o método <stmt>ok</stmt> e, portanto, deve
            ser declarada <stmt>abstract</stmt>.</resposta>
	</questao>
	<questao id="942">
		<introducao>A classe que implementa o método <stmt>main</stmt>
            chamado pela máquina virtual Java pode ser declarada <stmt>abstract</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="943" objetivo="1.2">
		<introducao>Uma variável de instância pode ser daclarada <stmt>abstract</stmt>.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="944" objetivo="1.2">
		<introducao>Um método declarado <stmt>abstract</stmt> não pode
            possuir um corpo (bloco de código).</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="945" objetivo="1.2">
		<introducao>A declaração do método <stmt>abstract void ok()
            {}</stmt> falha.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="946" objetivo="1.2">
		<introducao>A classe abaixo gera um erro de compilação.<java><![CDATA[public abstract class E {
    abstract void ok();
}

abstract class F extends E {
    public static void main(String[] args) {
        System.out.println("main F");
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="947" objetivo="1.2">
		<introducao>A declaração de um método termina com
            ponto-e-vírgula quando este é declarado <stmt>abstract</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="948" objetivo="1.2">
		<introducao>Quando o método de uma classe não é declarado
            <stmt>abstract</stmt>, sua declaração deve terminar,
            necessariamente, por <stmt>}</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="949" objetivo="1.2">
		<introducao>Se a declaração de um método de uma classe termina
            com ponto-e-vírgula, então o método e a classe devem ser
            declarados como <stmt>abstract</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="950" objetivo="1.2">
		<introducao>Se um único método é declarado
            <stmt>abstract</stmt>, então a classe deve ser declarada <stmt>abstract</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="951" objetivo="1.2">
		<introducao>Uma classe <stmt>abstract</stmt> pode possuir
            métodos que não são <stmt>abstract</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="952" objetivo="1.2">
		<introducao>Uma classe <stmt>abstract</stmt> deve ser herdada,
            enquanto uma classe <stmt>final</stmt> não pode ser herdada.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="953" objetivo="1.2">
		<introducao>Uma classe declarada <stmt>abstract</stmt> pode
            possuir métodos declarados <stmt>final</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="954" objetivo="1.2">
		<introducao>A compilação da classe abaixo falha.<java><![CDATA[public abstract class E {
    abstract void ok();
    final void ok(int i) {}
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="955" objetivo="1.2">
		<introducao>Métodos e variáveis de instância (não locais) de uma
            classe são chamados de membros.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="956" objetivo="1.2">
		<introducao>Uma classe pode ser declarada, da perspectiva de
            controle de acesso, apenas como <stmt>public</stmt> ou,
            alternativamente e de forma implícita, <it>default</it>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="957" objetivo="1.2">
		<introducao>Uma classe não pode ser declarada
            <stmt>protected</stmt> ou <stmt>private</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="958" objetivo="1.2">
		<introducao>Todos os quatro níveis de controle de acesso podem
            ser aplicados aos membros de uma classe.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="959" objetivo="1.2">
		<introducao>Uma variável de instância pode ser declarada como
            <stmt>public</stmt>, <stmt>protected</stmt>,
            <stmt>private</stmt> ou <it>default</it>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="960" objetivo="1.2">
		<introducao>Um método de uma classe pode ser declarado como
            <stmt>public</stmt>, <stmt>protected</stmt>,
            <stmt>private</stmt> ou <it>default</it>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="961" objetivo="1.2">
		<introducao>O controle de acesso <it>default</it> é obtido
            quando não é fornecido nenhuma das palavras reservadas que
            explicitamente define o controle de acesso. Ou seja,
            <stmt>public</stmt>, <stmt>protected</stmt> ou <stmt>private</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="962" objetivo="1.2">
		<introducao>Se uma classe <stmt>A</stmt> tem acesso so membros
            de uma classe <stmt>B</stmt>, então os membros de
            <stmt>B</stmt> são visíveis à classe <stmt>A</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="963" objetivo="1.2">
		<introducao>Quando uma classe não tem acesso a um membro de uma
            outra classe, o compilador informa que há uma tentativa de
            de ser acesso a alguma coisa que supostamente a classe
            requisitante não deveria sequer saber que existe.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="964" objetivo="1.2">
		<introducao>Para que uma classe faça uso de um método de outra
            classe, é necessário empregar o operador <stmt>.</stmt> para
            chamar o método desejado da instância em questão.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="965" objetivo="1.2">
		<introducao>Nem sempre os métodos de uma superclasse são
            herdados pela subclasse.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="966" objetivo="1.2">
		<introducao>Se uma classe <stmt>A</stmt> não está acessível a
            uma classe <stmt>B</stmt>, então nenhum método de
            <stmt>A</stmt> está acessível da classe <stmt>B</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="967" objetivo="1.2">
		<introducao>Quando um método ou variável de instância de
            determinada classe é declarado <stmt>public</stmt>, este
            membro está acessível a todas as classes nas quais a classe
            que contém o membro está acessível.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="968" objetivo="1.2">
		<introducao>Se um método ou variável de instância está acessível
            sem o emprego do operador <stmt>.</stmt> significa que o
            membro em questão pertence à classe na qual o acesso pode
            ser realizado.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="969" objetivo="1.2">
		<introducao>Membros declarados <stmt>private</stmt> não são
            visíveis a qualquer código além daquele que é parte da
            classe na qual são declarados.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="970" objetivo="1.2">
		<introducao>Se um determinado membro de uma classe
            <stmt>A</stmt>é acessível de uma classe <stmt>B</stmt>,
            então este membro pode ter sido declarado <stmt>private</stmt>.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="971" objetivo="1.2">
		<introducao>Um membro declarado <stmt>private</stmt> é visível
            apenas pelo código da classe da qual é membro.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="972" objetivo="1.2">
		<introducao>Um membro declarado <stmt>private</stmt> não pode
            ser herdado.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="973" objetivo="1.2">
		<introducao>Uma subclasse de uma classe que possui um membro
            <stmt>private</stmt> não pode &quot;ver&quot;,  fazer uso,
            sobrepor (<it>override</it>) ou sobrecarregar
            (<it>overload</it>) este membro.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="974" objetivo="1.2">
		<introducao>Um método declarado <stmt>private</stmt> não pode
            ser sobreposto (<it>overrided</it>) por método de uma sublcasse.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="975" objetivo="1.2">
		<introducao>Sobreposição (<it>override</it>) depende de herança.
            Como membro <stmt>private</stmt> não pode ser herdado,
            conclui-se que método <stmt>private</stmt> não pode ser
            sobreposto (<it>overriden</it>).</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="976" objetivo="1.2">
		<introducao>Um membro declarado <stmt>protected</stmt> é
            acessível, por meio de herança, por subclasse mesmo que esta
            encontre-se em um <stmt>package</stmt> distinto daquele da
            classe herdada.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="977" objetivo="1.2">
		<introducao>Um membro declarado com o modificador de acesso
            <it>default</it>, ou seja, sem o emprego de um modificador
            explícito como <stmt>public</stmt>, <stmt>protected</stmt>
            ou <stmt>private</stmt>, é acessível apenas pelas classes
            que pertencem ao mesmo <stmt>package</stmt> da classe onde é declarado.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="978" objetivo="1.2">
		<introducao>A diferença entre um membro declarado
            <stmt>protected</stmt> ou <it>default</it> (ou controle de
            acesso de <stmt>package</stmt>) diferem apenas quanto a subclasses.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="979" objetivo="1.2">
		<introducao>Se um membro é declarado <stmt>protected</stmt>,
            então qualquer subclasse da classe que contém este membro,
            mesmo que parte de um <stmt>package</stmt> distinto, tem
            acesso ao membro.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="980" objetivo="1.2">
		<introducao>O modificador de controle de acesso <it>default</it>
            pode ser interpretado como &quot;restrição de <stmt>package</stmt>&quot;.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="981" objetivo="1.2">
		<introducao>Quando se pensa em <stmt>protected</stmt>, uma
            perspectiva é acesso <it>default</it> acrescido de subclasses.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="982" objetivo="1.2">
		<introducao>O modificador de controle de acesso <it>default</it>
            é mais restritivo que o modificador <stmt>protected</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="983" objetivo="1.2">
		<introducao>Um membro declarado <stmt>protected</stmt> de uma
            classe de um <stmt>package</stmt> é acessível via referência
            contida em outra classe de outro <stmt>package</stmt>.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="984" objetivo="1.2">
		<introducao>Um membro declarado <stmt>protected</stmt> e herdado
            por uma subclasse pode ser empregado por esta subclasse como
            se fosse <stmt>public</stmt>.</introducao>
		<resposta valor="f">Exceto se as classes pertencerem a um
            mesmo <stmt>package</stmt>.</resposta>
	</questao>
	<questao id="985" objetivo="1.2">
		<introducao>Uma subclasse tem acesso a um membro
            <stmt>protected</stmt> da superclasse apenas por meio de herança.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="986" objetivo="1.2">
		<introducao>Um membro declarado <stmt>protected</stmt>
            encontra-se acessível a uma subclasse da classe na qual é
            declarado apenas por meio de herança.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="987" objetivo="1.2">
		<introducao>Se uma classe <stmt>A</stmt> contém um membro
            <stmt>mA</stmt>declarado <stmt>protected</stmt> e é herdada
            por uma classe <stmt>B</stmt> declarada em outro
            <stmt>package</stmt>, então a sentença <stmt>iA.mA</stmt>,
            onde <stmt>iA</stmt> é uma instância da classe
            <stmt>A</stmt>, compila sem falha.</introducao>
		<resposta valor="f">Membro declarado <stmt>protected</stmt>
            só é acessível ao código de uma subclasse de outro
            <stmt>package</stmt> por meio de herança.</resposta>
	</questao>
	<questao id="988" objetivo="1.2">
		<introducao>Subclasse em um <stmt>package</stmt> distinto da
            superclasse herda os membros <stmt>protected</stmt> da superclasse.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="989" objetivo="1.2">
		<introducao>Subclasse de <stmt>package</stmt> distinto daquele
            da superclasse não tem acesso aos membros
            <stmt>protected</stmt> da superclasse através de uma
            referência para esta.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="990" objetivo="1.2">
		<introducao>A classe abaixo
            <java><![CDATA[package modificador.outro;

public class A {
    private int x = 1;
}]]></java>
            é herdada pela classe <stmt>G</stmt>, conforme
            segue.<java><![CDATA[package modificador;

import modificador.outro.A;

public class G extends A {
    public static void main(String[] args) {
        System.out.println(x);
    }
}]]></java>A
            compilação da classe <stmt>A</stmt> não falha, o contrário
            do resultado da compilação da classe <stmt>G</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="991" objetivo="1.2">
		<introducao>A classe abaixo
            <java><![CDATA[package modificador.outro;

public class A {
    private int x = 1;
}]]></java>
            é herdada pela classe <stmt>G</stmt>, conforme
            segue.<java><![CDATA[package modificador;

import modificador.outro.A;

public class G extends A {
    public static void main(String[] args) {
        A a = new A();
        System.out.println(a.x);
    }
}]]></java>A
            compilação da classe <stmt>A</stmt> não falha, o contrário
            do resultado da compilação da classe <stmt>G</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="992" objetivo="1.2">
		<introducao>A classe <stmt>B</stmt>
			<java><![CDATA[package modificador.outro;

public class B {
    protected int x = 2;
}]]></java>herdada
            pela classe <stmt>H</stmt>
			<java><![CDATA[package modificador;

import modificador.outro.B;

public class H extends B {
    public static void main(String[] args) {
        System.out.println(x);
    }
}]]></java>compila
            satisfatoriamente, enquanto a compilação da classe
            <stmt>H</stmt> falha.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="993" objetivo="1.2">
		<introducao>A classe <stmt>B</stmt>
			<java><![CDATA[package modificador.outro;

public class B {
    protected int x = 2;
}]]></java>herdada
            pela classe <stmt>H</stmt>
			<java><![CDATA[package modificador;

import modificador.outro.B;

public class H extends B {
    public static void main(String[] args) {
        System.out.println(new H().x);
    }
}]]></java>compila
            satisfatoriamente, enquanto a compilação da classe
            <stmt>H</stmt> falha.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="994" objetivo="1.2">
		<introducao>A classe <stmt>C</stmt>
			<java><![CDATA[package modificador.outro;

public class C {
    public int x = 3;
}]]></java>herdada
            pela classe <stmt>I</stmt>
			<java><![CDATA[package modificador;

import modificador.outro.C;

public class I extends C {
    public static void main(String[] args) {
        System.out.println(x);
    }
}]]></java>compila
            sem falhas, ao contrário da compilação da classe <stmt>I</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="995" objetivo="1.2">
		<introducao>A classe <stmt>C</stmt>
			<java><![CDATA[package modificador.outro;

public class C {
    public int x = 3;
}]]></java>herdada
            pela classe <stmt>I</stmt>
			<java><![CDATA[package modificador;

import modificador.outro.C;

public class I extends C {
    public static void main(String[] args) {
        System.out.println(new C().x);
    }
}]]></java>compila
            sem falhas, ao contrário da compilação da classe <stmt>I</stmt>.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="996" objetivo="1.2">
		<introducao>A classe <stmt>J</stmt>
			<java><![CDATA[package modificador;

public class J extends I {
    public static void main(String[] args) {
        System.out.println(new J().x);
    }
}]]></java>
            estende (herda) da classe <stmt>I</stmt>
			<java><![CDATA[package modificador;

import modificador.outro.C;

public class I extends C {
    public static void main(String[] args) {
        System.out.println(new C().x);
    }
}]]></java>que
            herda da classe <stmt>C</stmt> em outro
            <stmt>package</stmt>.<java><![CDATA[package modificador.outro;

public class C {
    public int x = 3;
}]]></java>Todas
            estas classes compilam satisfatoriamente.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="997" objetivo="1.2">
		<introducao>A classe <stmt>B</stmt>
			<java><![CDATA[package modificador.outro;

public class B {
    protected static int x = 2;
}]]></java>é
            herdada pela classe <stmt>H</stmt>
			<java><![CDATA[package modificador;

import modificador.outro.B;

public class H extends B {
    public static void main(String[] args) {
        System.out.println(x);
    }
}]]></java>que
            é herdada pela classe <stmt>K</stmt>
			<java><![CDATA[package modificador;

public class K extends H {
    public static void main(String[] args) {
        System.out.println(x);
    }
}]]></java>Nenhuma
            compilação destas classes falha.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="998" objetivo="1.2">
		<introducao>A classe <stmt>B</stmt>
			<java><![CDATA[package modificador.outro;

public class B {
    protected static int x = 2;
}]]></java>é
            herdada pela classe <stmt>H</stmt>
			<java><![CDATA[package modificador;

import modificador.outro.B;

public class H extends B {
    public static void main(String[] args) {
        System.out.println(x);
    }
}]]></java>que
            é herdada pela classe <stmt>K</stmt>
			<java><![CDATA[package modificador;

public class K extends H {
    public static void main(String[] args) {
        System.out.println(new K().x = 2);
    }
}]]></java>Nenhuma
            compilação destas classes falha.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="999" objetivo="1.2">
		<introducao>A classe <stmt>B</stmt>
			<java><![CDATA[package modificador.outro;

public class B {
    protected static int x = 2;
}]]></java>é
            herdada pela classe <stmt>H</stmt>
			<java><![CDATA[package modificador;

import modificador.outro.B;

public class H extends B {
    public static void main(String[] args) {
        System.out.println(x);
    }
}]]></java>e
            <stmt>H</stmt> é usada pela classe <stmt>K</stmt>
			<java><![CDATA[package modificador;

public class K {
    public static void main(String[] args) {
        System.out.println(new H().x = 2);
    }
}]]></java>Nenhuma
            compilação destas classes falha.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1000" objetivo="1.2">
		<introducao>A classe <stmt>B</stmt>
			<java><![CDATA[package modificador.outro;

public class B {
    protected int x = 2;
}]]></java>é
            herada pela classe <stmt>H</stmt>
			<java><![CDATA[package modificador;

import modificador.outro.B;

public class H extends B {
    public static void main(String[] args) {
        System.out.println(new B().x);
    }
}]]></java>cuja
            compilação falha.</introducao>
		<resposta valor="v">Membro <stmt>protected</stmt> é
            visível a subclasse de outro <stmt>package</stmt> via herança.</resposta>
	</questao>
	<questao id="1001" objetivo="1.2">
		<introducao>A classe <stmt>B</stmt>
			<java><![CDATA[package modificador.outro;

public class B {
    protected int x = 2;
}]]></java>é
            herada pela classe <stmt>H</stmt>
			<java><![CDATA[package modificador;

import modificador.outro.B;

public class H extends B {
    public static void main(String[] args) {
        System.out.println(new H().x);
    }
}]]></java>cuja
            compilação falha.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1002" objetivo="1.2">
		<introducao>A classe <stmt>B</stmt> declara um membro
            <stmt>protected</stmt>.<java><![CDATA[package modificador.outro;

public class B {
    protected int x = 2;
}]]></java>A
            classe <stmt>H</stmt> herda da classe <stmt>B</stmt> e faz
            uso do membro <stmt>protected</stmt> corretamente. Contudo,
            a classe <stmt>Uso</stmt> provoca um erro de compilação ao
            tentar fazer uso do membro <stmt>protected</stmt> herdado
            pela classe <stmt>H</stmt>.</introducao>
		<resposta valor="v">Membro <stmt>protected</stmt>
            herdado só é visível a outras classes por meio de herança.</resposta>
	</questao>
	<questao id="1003" objetivo="1.2">
		<introducao>A classe <stmt>B</stmt> parte do
            <stmt>package</stmt> denominado <stmt>modificador.outro</stmt>
			<java><![CDATA[package modificador.outro;

public class B {
    protected int x = 2;
}]]></java>é
            herdada pela classe <stmt>H</stmt> que é herdada pela classe
            <stmt>Uso</stmt>, conforme
            abaixo<java><![CDATA[package modificador;

import modificador.outro.B;

public class H extends B {
    public static void main(String[] args) {
        System.out.println(new H().x);
    }
}

class Uso extends H {
    public static void main(String[] args) {
        System.out.println(new Uso().x);
    }
}]]></java>contidas
            em outro <stmt>package</stmt>. A compilação destas classes
            ocorre satisfatoriamente.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1004" objetivo="1.2">
		<introducao>A classe <stmt>B</stmt> parte do
            <stmt>package</stmt> denominado <stmt>modificador.outro</stmt>
			<java><![CDATA[package modificador.outro;

public class B {
    protected int x = 2;
}]]></java>é
            herdada pela classe <stmt>H</stmt> que é herdada pela classe
            <stmt>Uso</stmt>, conforme
            abaixo<java><![CDATA[package modificador;

import modificador.outro.B;

public class H extends B {
    public static void main(String[] args) {
        System.out.println(new H().x);
    }
}

class Uso extends H {
    public static void main(String[] args) {
        System.out.println(new H().x);
    }
}]]></java>contidas
            em outro <stmt>package</stmt>. A compilação destas classes
            ocorre satisfatoriamente.</introducao>
		<resposta valor="f">Observe que a classe <stmt>Uso</stmt>
            tenta fazer uso do membro <stmt>protected</stmt> da classe
            <stmt>H</stmt> por meio de uma referência.</resposta>
	</questao>
	<questao id="1005" objetivo="1.2">
		<introducao>A classe <stmt>C</stmt>, declarada abaixo, é
            <stmt>public</stmt> além de fazer parte do pacote
            <stmt>packageA</stmt>. Esta classe ainda delcara o membro
            <stmt>int</stmt> com o modificador de acesso
            <stmt>protected</stmt>.<java><![CDATA[package packageA;

public class C {
    protected int c = -1;
}]]></java>Em
            conseqüência, pode-se afirmar que a compilação da classe
            abaixo não falha, pois <stmt>SubC</stmt> estende (é
            subclasse de) <stmt>C</stmt> e, por este motivo, mesmo em um
            <stmt>package</stmt> distinto, pode fazer uso de
            <stmt>c</stmt> na sua definição.<java><![CDATA[package packageB;

import packageA.C;

public class SubC extends C {
    public void teste() {
	c = c + 1;
    }

    public static void main(String[] strs) {
	System.out.println("ok");
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1006" objetivo="1.2">
		<introducao>A classe <stmt>C</stmt> declarada
            abaixo<java><![CDATA[package packageA;

public class C {
    protected int c = -1;
}]]></java>é
            herdada pela classe <stmt>SubC</stmt> fornecida a
            seguir.<java><![CDATA[package packageB;

import packageA.C;

public class SubC extends C {
     public static void main(String[] strs) {
	System.out.println(c);
    }
}]]></java>Pode-se
            afirmar que a compilação destas classe não falha.</introducao>
		<resposta valor="f">Há uma tentativa de usar uma variável de
            instância (<stmt>c</stmt>) em um contexto estatico (o método
            <stmt>main</stmt> é declarado <stmt>static</stmt>).</resposta>
	</questao>
	<questao id="1007" objetivo="1.2">
		<introducao>A classe <stmt>C</stmt> declarada
            abaixo<java><![CDATA[package packageA;

public class C {
    protected int c = -1;
}]]></java>é
            herdada pela classe <stmt>SubC</stmt> fornecida a
            seguir.<java><![CDATA[package packageB;

import packageA.C;

public class SubC extends C {
     public static void main(String[] strs) {
	System.out.println(new SubC().c);
    }
}]]></java>Pode-se
            afirmar que a compilação de <stmt>SubC</stmt> falha, pois o
            membro <stmt>c</stmt> foi declarado <stmt>protected</stmt>
            em <stmt>C</stmt>.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1008" objetivo="1.2">
		<introducao>A classe <stmt>C</stmt> declarada
            abaixo<java><![CDATA[package packageA;

public class C {
    protected int c = -1;
}]]></java>é
            herdada pela classe <stmt>SubC</stmt> fornecida a
            seguir.<java><![CDATA[package packageB;

import packageA.C;

public class SubC extends C {
     public static void main(String[] strs) {
	System.out.println(new C().c);
    }
}]]></java>Pode-se
            afirmar que a compilação da classe <stmt>SubC</stmt> falha,
            pois o membro <stmt>c</stmt> foi declarado
            <stmt>protected</stmt>. Neste caso, a falha ocorre mesmo em
            uma subclasse de <stmt>C</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1009" objetivo="1.2">
		<introducao>O uso de um membro <stmt>protected</stmt>, digamos
            <stmt>m</stmt>, de uma classe <stmt>C</stmt>, declarada
            <stmt>public</stmt>, da forma <stmt>new C().m</stmt> não é
            permitido em uma subclasse de <stmt>C</stmt> declarada em
            <stmt>package</stmt> distinto.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1010" objetivo="1.2">
		<introducao>O uso de um membro <stmt>protected</stmt> e
            <stmt>static</stmt>, digamos <stmt>m</stmt>, de uma classe
            <stmt>C</stmt>, declarada <stmt>public</stmt>, da forma
                <stmt>new C().m</stmt> não é permitido em uma subclasse
            de <stmt>C</stmt>, digamos <stmt>SubC</stmt>, que não é
            parte do mesmo <stmt>package</stmt> da classe <stmt>C</stmt>.</introducao>
		<resposta valor="f">A sentença <stmt>new C().m</stmt> é o
            mesmo que <stmt>new SubC().m</stmt> pois o membro
            <stmt>m</stmt> é <stmt>static</stmt>. São formas
            equivalentes de se referir a uma mesma entidade. O fato de
            ser <stmt>protected</stmt> permite o acesso a ele, mesmo de
            uma classe em <stmt>package</stmt> distinto quando se trata
            de uma subclasse (por meio do mecanismo de herança).</resposta>
	</questao>
	<questao id="1011" objetivo="1.2">
		<introducao>Quando nenhum modificador de acesso é explicitamente
            fornecido, então o membro em questão apresenta o modelo de
            proteção de acesso <it>default</it>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1012" objetivo="1.2">
		<introducao>Para se ter acesso a um membro de uma classe a
            partir de uma classe distinta é necessário o emprego do
            operador <stmt>.</stmt> (ponto).</introducao>
		<resposta valor="f">Se uma classe herda
            (<stmt>extends</stmt>) outra, então os membros desta outra
            não necessariamente precisam do emprego do operador
            <stmt>.</stmt> para serem acessadas.</resposta>
	</questao>
	<questao id="1013" objetivo="1.2">
		<introducao>Uma instância de uma classe pode enviar uma mensagem
            a uma instância de outra classe caso o método correspondente
            seja declarado público (<stmt>public</stmt>).</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1014" objetivo="1.2">
		<introducao>A compilação do código abaixo não falha.<java><![CDATA[public class L {
    public void L() {}
}

class M {
    M() { new L().L(); }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1015" objetivo="1.2">
		<introducao>A compilação do código abaixo falha.<java><![CDATA[public class L {
    private void L() {}
}

class M {
    M() { new L().L(); }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1016" objetivo="1.2">
		<introducao>A compilação do código abaixo não falha.<java><![CDATA[public class L {
    private void L() {}
}

class M {
    M() { new L(); }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1017" objetivo="1.2">
		<introducao>A compilação do código abaixo falha.<java><![CDATA[public class L {
    private L() {}
}

class M {
    M() { new L(); }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1018" objetivo="1.2">
		<introducao>A compilação do código abaixo não falha.<java><![CDATA[public class L {
    public L() {}
}

class M {
    M() { new L(); }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1019" objetivo="1.2">
		<introducao>A compilação do código abaixo, fornecido em uma
            mesma unidade de compilação, não falha.<java><![CDATA[private class L {
    public L() {}
}

class M {
    M() { new L(); }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1020" objetivo="1.2">
		<introducao>A compilação do código abaixo, fornecido em uma
            mesma unidade de compilação, não falha.<java><![CDATA[protected class L {
    public L() {}
}

class M {
    M() { new L(); }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1021" objetivo="1.2">
		<introducao>A compilação do código abaixo, fornecido em uma
            mesma unidade de compilação, não falha.<java><![CDATA[default class L {
    public L() {}
}

class M {
    M() { new L(); }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1022" objetivo="1.2">
		<introducao>A compilação do código abaixo, fornecido em uma
            mesma unidade de compilação, não falha.<java><![CDATA[class L {
    L() {}
}

class M {
    M() { new L(); }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1023" objetivo="1.2">
		<introducao>A compilação do código abaixo, fornecido em uma
            mesma unidade de compilação, falha.<java><![CDATA[private class L {
    public L() {}
    public K() {}
}

class M {
    M() { new L()->K(); }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1024" objetivo="1.2">
		<introducao>O emprego do operador <stmt>.</stmt> pode
            desnecessário, mesmo quando uma classe invoca o método de
            uma outra. Isto é possível quando a primeira herda desta
            outra métodos públicos (<stmt>public</stmt>), por exemplo. </introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1025" objetivo="1.2">
		<introducao>Para que um membro de uma classe, por exemplo, um
            método possa ser acessado de outra classe é suficiente que
            este membro seja declarado <stmt>public</stmt>.</introducao>
		<resposta valor="f">Se a classe que contém o método não for
            visível à classe que deseja invocar o método, então não é
            possível se ter acesso ao membro, mesmo que este seja público.</resposta>
	</questao>
	<questao id="1026" objetivo="1.2">
		<introducao>Seja <stmt>A</stmt> uma classe não declarada
            <stmt>public</stmt> em um <stmt>package</stmt> e que possui
            o método <stmt>m</stmt>, declarado <stmt>public</stmt>.
            Pode-se afirmar que necessariamente o método <stmt>m</stmt>
            pode ser acessado por código em outra classe, digamos <stmt>B</stmt>.</introducao>
		<resposta valor="f">Se <stmt>A</stmt> e <stmt>B</stmt>
            pertencem ao mesmo <stmt>package</stmt>, então é possível.
            Caso contrário, não.</resposta>
	</questao>
	<questao id="1027" objetivo="1.2">
		<introducao>A unidade de compilação
            abaixo<java><![CDATA[package modificador.outro;

import modificador.Base;

public class UsaBase {
    Base b = new Base();
}]]></java>faz
            uso da classe <stmt>Base</stmt>, fornecida na unidade de
            compilação
            seguinte.<java><![CDATA[package modificador;

public class Base {}]]></java>Pode-se
            afirmar que ambas as unidades são compiladas sem falha.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1028" objetivo="1.2">
		<introducao>A unidade de compilação
            abaixo<java><![CDATA[package modificador.outro;

import modificador.Base;

public class UsaBase {
    Base b = new Base();
}]]></java>faz
            uso da classe <stmt>Base</stmt>, fornecida na unidade de
            compilação
            seguinte.<java><![CDATA[package modificador;

public class Base {}]]></java>Pode-se
            afirmar que <stmt>UsaBase</stmt> emprega corretamente
            <stmt>Base</stmt> pois esta classe é declarada
            <stmt>public</stmt>, o que a torna visível, mesmo em outros <stmt>package</stmt>s.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1029" objetivo="1.2">
		<introducao>A unidade de compilação
            abaixo<java><![CDATA[package modificador.outro;

public class UsaBase {
    Base b = new Base();
}]]></java>faz
            uso da classe <stmt>Base</stmt>, fornecida na unidade de
            compilação
            seguinte.<java><![CDATA[package modificador;

public class Base {}]]></java>Ambas
            as unidades são compiladas sem falha.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1030" objetivo="1.2">
		<introducao>A unidade de compilação abaixo declara um construtor
            visível em qualquer classe do universo Java.<java><![CDATA[package modificador;

public class Base {
    Base() {}
}]]></java>
		</introducao>
		<resposta valor="f">O construtor faz uso do modificador de
            acesso <it>default</it> e, portanto, só é visível no âmbito
            do <stmt>package</stmt> em questão.</resposta>
	</questao>
	<questao id="1031" objetivo="1.2">
		<introducao>Pode-se afirmar que o construtor abaixo é visível em
            qualquer que seja a classe do universo Java.<java><![CDATA[package modificador;

public class Base {
    public Base() { System.out.println("Base"); }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1032" objetivo="1.2">
		<introducao>Pode-se afirmar que a compilação do código abaixo falha.<java><![CDATA[package modificador;

private class Base {
    public Base() { System.out.println("Base"); }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1033" objetivo="1.2">
		<introducao>Pode-se afirmar que a compilação do código abaixo falha.<java><![CDATA[package modificador;

public class Base {
    private Base() { System.out.println("Base"); }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1034" objetivo="1.2">
		<introducao>Dada a unidade de compilação abaixo, pode-se afirmar
            que não é possível criar uma instância de <stmt>Base</stmt>,
            por exemplo, por meio da sentença <stmt>new Base()</stmt>,
            por código que não é parte do <stmt>package</stmt>
            denominado <stmt>modificador</stmt>.<java><![CDATA[package modificador;

public class Base {
    private Base() { System.out.println("Base"); }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1035" objetivo="1.2">
		<introducao>Dada a unidade de compilação abaixo, pode-se afirmar
            que não é possível criar uma instância de <stmt>Base</stmt>,
            por exemplo, por meio da sentença <stmt>new Base()</stmt>,
            por código que é parte do <stmt>package</stmt> denominado
            <stmt>modificador</stmt> e membro de uma classe diferente de <stmt>Base</stmt>.<java><![CDATA[package modificador;

public class Base {
    private Base() { System.out.println("Base"); }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1036" objetivo="1.2">
		<introducao>Dada a unidade de compilação abaixo, pode-se afirmar
            que a sentença no interior do bloco do construtor jamais
            será executada, direta ou indiretamente, em decorrência da
            execução de código que não faz parte do <stmt>package</stmt>
            denominado <stmt>modificador</stmt>.<java><![CDATA[package modificador;

public class Base {
    private Base() { System.out.println("Base"); }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1037" objetivo="1.2">
		<introducao>Dada a unidade de compilação abaixo, pode-se afirmar
            que não é possível criar uma instância de <stmt>Base</stmt>.<java><![CDATA[package modificador;

public class Base {
    private Base() { System.out.println("Base"); }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1038" objetivo="1.2">
		<introducao>A compilação da classe abaixo
            falha.<java><![CDATA[package modificador;

public class SubBase extends Base {}
]]></java>Onde
            <stmt>Base</stmt> é fornecida na unidade de compilação abaixo.<java><![CDATA[package modificador;

public class Base {
    private Base() {
        System.out.println("Base()");
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1039" objetivo="1.2">
		<introducao>Uma classe cujo construtor <it>default</it> é
            privado só pode dar origem a instâncias por código no
            interior desta própria classe.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1040" objetivo="1.2">
		<introducao>Não é possível enviar uma mensagem <stmt>m</stmt>
            para uma instância de uma classe cujo construtor
            <it>default</it> é privado. Assuma que <stmt>m</stmt> é
            método público desta classe.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1041" objetivo="1.2">
		<introducao>Não é possível enviar uma mensagem <stmt>m</stmt>, a
            partir de código de uma classe <stmt>B</stmt> em um
            <stmt>package</stmt> denominado <stmt>pB</stmt> para uma
            instância de uma classe <stmt>A</stmt> em um
            <stmt>package</stmt> denominado <stmt>pA</stmt> cujo
            construtor <it>default</it> é privado. Assuma que
            <stmt>m</stmt> é método público desta classe <stmt>A</stmt>.</introducao>
		<resposta valor="f">Instâncias de <stmt>A</stmt> podem ser
            criadas por um método <stmt>static</stmt> de <stmt>A</stmt>
            e as respectivas referências obtidas por meio de métodos
            também <stmt>static</stmt>. Através destas referências é
            possível chamar o método <stmt>m</stmt> de <stmt>A</stmt>.</resposta>
	</questao>
	<questao id="1042" objetivo="1.2">
		<introducao>A unidade de
            compilação<java><![CDATA[package modificador.outro;

import modificador.Base;

public class UsaBase {
    public static void main(String[] args) {
        Base b = Base.getInstance();
        System.out.println(b.m());
    }
}]]></java>e
            aquela fornecida
            abaixo<java><![CDATA[package modificador;

public class Base {
    private Base() {}

    public String m() {
        return "ok";
    }

    public static Base getInstance() {
        return new Base();
    }
}]]></java>compilam
            satisfatoriamente. Em tempo de execução, contudo, uma
            execção é gerada. </introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1043" objetivo="1.2">
		<introducao>A unidade de
            compilação<java><![CDATA[package modificador.outro;

import modificador.Base;

public class UsaBase {
    public static void main(String[] args) {
        Base b = Base.getInstance();
        System.out.println(b.m());
    }
}]]></java>e
            aquela fornecida
            abaixo<java><![CDATA[package modificador;

public class Base {
    private Base() {}

    public String m() {
        return "ok";
    }

    public static Base getInstance() {
        return new Base();
    }
}]]></java>compilam
            satisfatoriamente e a execução da classe
            <stmt>UsaBase</stmt> a partir da linha de comandos imprime a
            mensagem <stmt>ok</stmt> na saída padrão.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1044" objetivo="1.2">
		<introducao>Não pode existir sobreposição de um método declarado <stmt>private</stmt>.</introducao>
		<resposta valor=""/>
	</questao>
	<questao id="1045" objetivo="2.1">
		<introducao>O classe abaixo exibe a mensagem <stmt>x = 1</stmt>
            quando executada.<java><![CDATA[public class FazPoucaCoisa {
    public static void main(String[] args) {
        int x = 1;

        if (x = 1) {
            System.out.print("x = 1");
        } else {
            System.out.print("x != 1");
        }
    }
}]]></java>
		</introducao>
		<resposta valor="f">O código não compila. É fornecido um
            valor do tipo <stmt>int</stmt> quando é esperado um valor do
            tipo <stmt>boolean</stmt>.</resposta>
	</questao>
	<questao id="1046" objetivo="2.1">
		<introducao>A execução da classe abaixo exibe a mensagem <stmt>123</stmt>.<java><![CDATA[class SimplesSwitch {

    static void quantos(int k) {
        switch (k) {
            case 1:
                System.out.print("1");
            case 2:
                System.out.print("2");
            case 3:
                System.out.print("3");
        }
    }

    public static void main(String[] args) {
        quantos(01);
    }
}]]></java>
		</introducao>
		<resposta valor="v">A chamada ao método
            <stmt>quantos</stmt> emprega o literal octal
            <stmt>01</stmt>, cujo valor decimal correspondente é 1.</resposta>
	</questao>
	<questao id="1047" objetivo="2.1">
		<introducao>O código abaixo imprime mensagem compatível com a
            comparação realizada.<java><![CDATA[class Switch {
    public static void main(String[] args) {
        int x = 5;
        switch (x) {
            case (0 <= x && x < 3):
                System.out.println("0 <= x && x < 3");
                break;
            case (3 <= x && x <= 6):
                System.out.println("3 <= x && x <= 6");
                break;
            default:
                System.out.println("x < 0 || x > 6");
        }
    }
}]]></java>
		</introducao>
		<resposta valor="f">O código não compila.</resposta>
	</questao>
	<questao id="1048" objetivo="2.1">
		<introducao>Imediatamente após a palavra reservada
            <stmt>switch</stmt> deve seguir, entre parênteses, uma
            expressão do tipo <stmt>char</stmt>, <stmt>byte</stmt>,
            <stmt>short</stmt> ou <stmt>int</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1049" objetivo="2.1">
		<introducao>A execução da classe abaixo imprime a mensagem
                <stmt>x != 3</stmt>.<java><![CDATA[public class UmIf {
    public static void main(String[] args) {
        int x = 4;

        if (x == 3)
            if (x == 5)
                System.out.print("x==3");
        else
            System.out.print("x != 3");
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1050" objetivo="2.1">
		<introducao>A compilação da classe abaixo falha.<java><![CDATA[class SwitchComBreak {
    public static void main(String[] args) {
        laco:
        switch (0) {
            case 0:
                break laco;
        }

        System.out.println("Fim");
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1051" objetivo="2.1">
		<introducao>A execução da classe abaixo gera uma exceção.<java><![CDATA[class SwitchComBreak {
    public static void main(String[] args) {
        laco:
        switch (0) {
            case 0:
                break laco;
        }

        System.out.println("Fim");
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1052" objetivo="2.1">
		<introducao>A execução da classe abaixo não termina (entra em um
            laço sem fim determinado).<java><![CDATA[class SwitchComBreak {
    public static void main(String[] args) {
        laco:
        switch (0) {
            case 0:
                break laco;
        }

        System.out.println("Fim");
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1053" objetivo="2.1">
		<introducao>A mensagem <stmt>Fim</stmt> jamais será impressa
            pela execução da classe abaixo.<java><![CDATA[class SwitchComBreak {
    public static void main(String[] args) {
        laco:
        switch (0) {
            case 0:
                break laco;
        }

        System.out.println("Fim");
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1054" objetivo="2.1">
		<introducao>Quando executada, a classe abaixo exibe a mensagem <stmt>Fim</stmt>.<java><![CDATA[class SwitchComBreak {
    public static void main(String[] args) {
        laco:
        switch (0) {
            case 0:
                break laco;
        }

        System.out.println("Fim");
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1055" objetivo="2.1">
		<introducao>A compilação da classe abaixo falha.<java><![CDATA[class UmSwitch {
    public static void main(String[] args) {
        int i = 1;

        loop:
        while (i < 10) {
            if (i % 3 == 0) {
                break loop;
            }
            i++;
        }

        System.out.println(i);
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1056" objetivo="2.1">
		<introducao>O valor impresso pela execução do código abaixo é 3.<java><![CDATA[class UmSwitch {
    public static void main(String[] args) {
        int i = 1;

        laco:
        while (i < 10) {
            if (i % 3 == 0) {
                break laco;
            }
            i++;
        }

        System.out.println(i);
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1057" objetivo="2.1">
		<introducao>A compilação da classe abaixo falha.<java><![CDATA[class UmSwitch {
    public static void main(String[] args) {
        int i = 1;

        laco:
        i++;
        while (i < 10) {
            if (i % 3 == 0) {
                break laco;
            }
            i++;
        }

        System.out.println(i);
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1058" objetivo="1.2">
		<introducao>A classe <stmt>Base</stmt>, fornecida na unidade de
            compilação
            abaixo<java><![CDATA[package modificador;

public class Base {
    Base() {}

    public void m() {
        System.out.println("Base.m()");
    }
}]]></java>e
            a classe <stmt>Sobreposição</stmt>, fornecida
            abaixo<java><![CDATA[package modificador;

public class Sobreposição extends Base {
    public void m() {
        super.m();
        System.out.println("Sobreposição.m()");
    }

    public static void main(String[] args) {
        Sobreposição sb = new Sobreposição();
        sb.m();
    }]]></java>compilam satisfatoriamente.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1059" objetivo="1.2">
		<introducao>A classe <stmt>Base</stmt>, fornecida na unidade de
            compilação
            abaixo<java><![CDATA[package modificador;

public class Base {
    Base() {}

    public void m() {
        System.out.println("Base.m()");
    }
}]]></java>é
            herdada pela classe <stmt>Sobreposição</stmt>, fornecida
            abaixo e, quando executada, produz a mensagem
            <stmt>Base.m()</stmt> seguida da mensagem
            <stmt>Sobreposição.m()</stmt> na linha seguinte.<java><![CDATA[package modificador;

public class Sobreposição extends Base {
    public void m() {
        super.m();
        System.out.println("Sobreposição.m()");
    }

    public static void main(String[] args) {
        Sobreposição sb = new Sobreposição();
        sb.m();
    }]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1060" objetivo="1.2">
		<introducao>A classe <stmt>Base</stmt>, fornecida na unidade de
            compilação
            abaixo<java><![CDATA[package modificador;

public class Base {
    Base() {}

    public void m() {
        System.out.println("Base.m()");
    }
}]]></java>e
            a classe <stmt>Sobreposição</stmt>, fornecida abaixo,
            sobrepõe (<it>overrides</it>) o método
            <stmt>m()</stmt>.<java><![CDATA[package modificador;

public class Sobreposição extends Base {
    public void m() {
        super.m();
        System.out.println("Sobreposição.m()");
    }

    public static void main(String[] args) {
        Sobreposição sb = new Sobreposição();
        sb.m();
    }]]></java>compilam satisfatoriamente.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1061" objetivo="1.2">
		<introducao>A classe <stmt>Base</stmt>, fornecida na unidade de
            compilação
            abaixo<java><![CDATA[package modificador;

public class Base {
    Base() {}

    private void m() {
        System.out.println("Base.m()");
    }
}]]></java>é
            herdada pela classe <stmt>Sobreposição</stmt>, fornecida
            abaixo e que sobrepõe o método <stmt>m()</stmt>.<java><![CDATA[package modificador;

public class Sobreposição extends Base {
    public void m() {
        super.m();
        System.out.println("Sobreposição.m()");
    }

    public static void main(String[] args) {
        Sobreposição sb = new Sobreposição();
        sb.m();
    }]]></java>
		</introducao>
		<resposta valor="f">Membro privado não pode ser sobreposto.
            Adicionalmente, a classe <stmt>Sobreposição</stmt> não
            compila, pois o método <stmt>m()</stmt> da classe
            <stmt>Base</stmt> é privado.</resposta>
	</questao>
	<questao id="1062" objetivo="1.2">
		<introducao>A classe <stmt>Base</stmt>, fornecida na unidade de
            compilação
            abaixo<java><![CDATA[package modificador;

public class Base {
    Base() {}

    private void m() {
        System.out.println("Base.m()");
    }
}]]></java>é
            herdada pela classe <stmt>Sobreposição</stmt>, fornecida
            abaixo.<stmt>m()</stmt>.<java><![CDATA[package modificador;

public class Sobreposição extends Base {
    public void m() {
        super.m();
        System.out.println("Sobreposição.m()");
    }

    public static void main(String[] args) {
        Sobreposição sb = new Sobreposição();
        sb.m();
    }]]></java>A
            classe <stmt>Base</stmt> compila, enquanto a classe
            <stmt>Sobreposição</stmt> não compila.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1063" objetivo="1.2">
		<introducao>Um membro declarado com o método de acesso
            <it>default</it> difere de um outro declarado
            <stmt>protected</stmt> por que o primeiro é visível em
            qualquer classe no interior do <stmt>package</stmt> em
            questão, enquanto aquele declarado <stmt>protected</stmt> é
            visível em uma subclasse, através de herança, mesmo que a
            subclasse faça parte de outro <stmt>package</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1064" objetivo="1.2">
		<introducao>A classe
            <java><![CDATA[package modificador;

public class Sobreposição extends Base {
    public void m() {
        super.m();
        System.out.println("Sobreposição.m()");
    }

    public static void main(String[] args) {
        Sobreposição sb = new Sobreposição();
        sb.m();
    }
}]]></java>herda
            a classe <stmt>Base</stmt>, fornecida abaixo, e
            <it>overrides</it> o método <stmt>m()</stmt>.<java><![CDATA[package modificador;

public class Base {
    Base() {}

    void m() {
        System.out.println("Base.m()");
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1065" objetivo="1.2">
		<introducao>A classe <stmt>Base</stmt> contém um construtor e um
            membro (método) ambos declarados de acesso <it>default</it>.<java><![CDATA[package modificador;

public class Base {
    Base() {}

    void m() {
        System.out.println("Base.m()");
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1066" objetivo="1.2">
		<introducao>A compilação da classe <stmt>Derivada</stmt>,
            fornecida
            abaixo,<java><![CDATA[package modificador.outro;

import modificador.Base;

public class Derivada extends Base {}]]></java>falha,
            dado que a classe <stmt>Base</stmt> é definida como segue.<java><![CDATA[package modificador;

public class Base {
    Base() {}

    void m() {
        System.out.println("Base.m()");
    }
}]]></java>
		</introducao>
		<resposta valor="v">O construtor <it>default</it> da
            classe <stmt>Base</stmt> é declarado implicitamente com o
            modificador de acesso <it>default</it>, ou seja, o
            construtor só é visível em classe que pertence ao mesmo
            <stmt>package</stmt> desta classe.</resposta>
	</questao>
	<questao id="1067" objetivo="1.2">
		<introducao>A compilação da classe <stmt>Derivada</stmt>,
            fornecida
            abaixo,<java><![CDATA[package modificador.outro;

import modificador.Base;

public class Derivada extends Base {}]]></java>falha,
            caso a classe <stmt>Base</stmt> seja declarada como segue.<java><![CDATA[package modificador;

public class Base {
    void m() {
        System.out.println("Base.m()");
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1068" objetivo="1.2">
		<introducao>A compilação da classe <stmt>Derivada</stmt>,
            fornecida
            abaixo,<java><![CDATA[package modificador.outro;

import modificador.Base;

public class Derivada {}]]></java>falha,
            caso a classe <stmt>Base</stmt> seja declarada como segue.<java><![CDATA[package modificador;

public class Base {
    void m() {
        System.out.println("Base.m()");
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1069" objetivo="1.2">
		<introducao>A classe <stmt>Base</stmt>
			<java><![CDATA[package modificador;

public class Base {
    public static int m() {
       return 024;
    }
}]]></java>declara
            o método de classe <stmt>m()</stmt> que retorna um valor do
            tipo <stmt>int</stmt> e é visível em qualquer classe do
            universo Java.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1070" objetivo="1.2">
		<introducao>A classe <stmt>Base</stmt>
			<java><![CDATA[package modificador;

public class Base {
    public static int m() {
       return 024;
    }
}]]></java>declara
            o método de classe <stmt>m()</stmt>, que é acessível por
            código de outras classes que fazem parte do mesmo <stmt>package</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1071" objetivo="1.2">
		<introducao>A classe <stmt>Base</stmt>
			<java><![CDATA[package modificador;

public class Base {
    static int m() {
       return 024;
    }
}]]></java>declara
            o método de classe <stmt>m()</stmt> cujo acesso está
            restrito a classes do <stmt>package</stmt> identificado por <stmt>modificador</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1072" objetivo="1.2">
		<introducao>A
            classe<java><![CDATA[package modificador;

public class Base {
    public static int m() {
       return 024;
    }
}]]></java>empregada
            pela classe
            <java><![CDATA[package modificador.outro;

import modificador.Base;

public class Derivada extends Base {
    int i = m();
}]]></java>é
            empregada para fornecer o valor inicial de <stmt>i</stmt>
            que, no caso, é decimal 20.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1073" objetivo="1.2">
		<introducao>A
            classe<java><![CDATA[package modificador;

public class Base {
    static int m() {
       return 024;
    }
}]]></java>empregada
            pela classe
            <java><![CDATA[package modificador.outro;

import modificador.Base;

public class Derivada extends Base {
    int i = m();
}]]></java>é
            empregada para fornecer o valor inicial de <stmt>i</stmt>
            que, no caso, é o valor octal 24.</introducao>
		<resposta valor="f">O método <stmt>m()</stmt> tem controle
            de acesso <it>default</it> e, portanto, só é acessível no
            interior do <stmt>package</stmt> onde é declarado.</resposta>
	</questao>
	<questao id="1074" objetivo="1.2">
		<introducao>A
            classe<java><![CDATA[package modificador;

public class Base {
    protected static int m() {
       return 024;
    }
}]]></java>herdada
            pela
            classe<java><![CDATA[package modificador.outro;

import modificador.Base;

public class Derivada extends Base {
    int i = m();
}
]]></java>declara
            o método <stmt>m()</stmt> com o modificador de acesso
            <stmt>protected</stmt>, o que assegura o acesso realizado
            por código na classe <stmt>Derivada</stmt>, mesmo que esta
            encontra-se declarada em outro <stmt>package</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1075" objetivo="1.2">
		<introducao>A
            classe<java><![CDATA[package modificador;

public class Base {
    protected static int m() {
       return 024;
    }
}]]></java>que
            é herdada pela classe
            <stmt>Derivada</stmt>,<java><![CDATA[package modificador.outro;

import modificador.Base;

public class Derivada extends Base {
    int i = super.m();
}
]]></java>declara
            o método <stmt>m()</stmt> com o modificador de acesso
            <stmt>protected</stmt>. A compilação da classe
            <stmt>Derivada</stmt>, contudo, falha, pois é empregada uma
            referência para se ter acesso ao referido membro.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1076" objetivo="1.2">
		<introducao>Pode-se afirmar que a compilação do código abaixo
            falha. Assuma que <stmt>m()</stmt> é um membro declarado
            <stmt>protected</stmt> que não possui argumentos e retorna
            um <stmt>int</stmt>.<java><![CDATA[package modificador.outro;

import modificador.Base;

public class Derivada extends Base {
    int i = this.m();
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1077" objetivo="1.2">
		<introducao>Pode-se afirmar que a compilação do código abaixo
            falha. Assuma que <stmt>m()</stmt> é um membro declarado
            <stmt>protected</stmt> que não possui argumentos e retorna
            um <stmt>int</stmt>.<java><![CDATA[package modificador.outro;

import modificador.Base;

public class Derivada extends Base {
    int i = new Base().m();
}]]></java>
		</introducao>
		<resposta valor="v">Um membro <stmt>protected</stmt> é
            acessível por código em outro <stmt>package</stmt> através
            de herança.</resposta>
	</questao>
	<questao id="1078" objetivo="1.2">
		<introducao>Assuma que a classe <stmt>Base</stmt> declara o
            método <stmt>m()</stmt> que retorna um <stmt>int</stmt> e
            cujo modificador de acesso é <stmt>protected</stmt>. Em
            conseqüência, a compilação do código abaixo falha.<java><![CDATA[package modificador.outro;

import modificador.Base;

public class Derivada extends Base {
    int i = this.m();
}

class D2 extends Derivada {
    public static void main(String[] args) {
        System.out.println(m());
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1079" objetivo="1.2">
		<introducao>Assuma que a classe <stmt>Base</stmt> declara o
            método <stmt>m()</stmt> que retorna um <stmt>int</stmt> e
            cujo modificador de acesso é <stmt>protected</stmt>. Em
            conseqüência, a compilação do código abaixo falha, em
            particular, na tentativa de acesso ao membro
            <stmt>protected</stmt> ao se iniciar a variável <stmt>i</stmt>.<java><![CDATA[package modificador.outro;

import modificador.Base;

public class Derivada extends Base {
    int i = this.m();
}

class D2 extends Derivada {
    public static void main(String[] args) {
        System.out.println(m());
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1080" objetivo="1.2">
		<introducao>Assuma que a classe <stmt>Base</stmt> declara o
            método <stmt>m()</stmt> que retorna um <stmt>int</stmt> e
            cujo modificador de acesso é <stmt>protected</stmt>. Em
            conseqüência, a compilação do código abaixo falha, em
            particular, no corpo do código do método <stmt>main</stmt>.
            Isto porque o membro <stmt>protected</stmt> herdado pela
            classe <stmt>Derivada</stmt>, pertencente a outro
            <stmt>package</stmt>, não pode ser herdado por classe
            derivada de <stmt>Derivada</stmt>.<java><![CDATA[package modificador.outro;

import modificador.Base;

public class Derivada extends Base {
    int i = this.m();
}

class D2 extends Derivada {
    public static void main(String[] args) {
        System.out.println(m());
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1081" objetivo="1.2">
		<introducao>A unidade de
            compilação<java><![CDATA[package modificador;

import modificador.outro.Derivada;

public class Base {
    protected int m() {
       return 024;
    }
}

class D2 extends Derivada {
    public static void main(String[] args) {
        System.out.println(m());
    }
}]]></java>e
            aquela fornecida
            abaixo<java><![CDATA[package modificador.outro;

import modificador.Base;

public class Derivada extends Base {
    int i = this.m();
}]]></java>são
            compiladas satisfatoriamente.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1082" objetivo="1.2">
		<introducao>A unidade de
            compilação<java><![CDATA[package modificador;

import modificador.outro.Derivada;

public class Base {
    protected int m() {
       return 024;
    }
}

class D2 extends Derivada {
    public static void main(String[] args) {
        System.out.println(m());
    }
}]]></java>e
            aquela fornecida
            abaixo<java><![CDATA[package modificador.outro;

import modificador.Base;

public class Derivada extends Base {
    int i = this.m();
}]]></java>não
            são compiladas satisfatoriamente. Motivo: o
            <stmt>package</stmt> identificado por
            <stmt>modificador</stmt> declara classe herdada por classe
            contida em outro <stmt>package</stmt> e que é herdada por
            classe que é parte do <stmt>package modificador</stmt>,
            formando um ciclo (dependência circular).</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1083" objetivo="1.2">
		<introducao>A unidade de
            compilação<java><![CDATA[package modificador;

import modificador.outro.Derivada;

public class Base {
    protected int m() {
       return 024;
    }
}

class D2 extends Derivada {
    public static void main(String[] args) {
        System.out.println(m());
    }
}]]></java>e
            aquela fornecida
            abaixo<java><![CDATA[package modificador.outro;

import modificador.Base;

public class Derivada extends Base {
    int i = this.m();
}]]></java>não
            são compiladas satisfatoriamente, pois <stmt>m()</stmt> não
            é <stmt>static</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1084" objetivo="1.2">
		<introducao>A unidade de
            compilação<java><![CDATA[package modificador;

import modificador.outro.Derivada;

public class Base {
    protected int m() {
       return 024;
    }
}

class D2 extends Derivada {
    public void main(String[] args) {
        System.out.println(m());
    }
}]]></java>e
            aquela fornecida
            abaixo<java><![CDATA[package modificador.outro;

import modificador.Base;

public class Derivada extends Base {
    int i = this.m();
}]]></java>são
            compiladas satisfatoriamente.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1085" objetivo="1.2">
		<introducao>A unidade de compilação abaixo compila satisfatoriamente.<java><![CDATA[public class Base {
    int m() {
        protected int i = 024;
        return i;
    }
}

class D2 extends Base {
    public void main(String[] args) {
        System.out.println(m());
    }
}]]></java>
		</introducao>
		<resposta valor="f">Modificadores de acesso não são
            aplicáveis em variáveis locais.</resposta>
	</questao>
	<questao id="1086" objetivo="1.2">
		<introducao>A palavra reservada <stmt>final</stmt> evita que um
            método seja sobreposto (<it>overridden</it>) em uma subclasse.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1087" objetivo="1.2">
		<introducao>A compilação do código abaixo falha.<java><![CDATA[class Base {
    public static final void main(String[] args) {
        System.out.println("Base");
    }
}

class Derivada extends Base {
    public static void main(String[] args) {
        System.out.println("Derivada");
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1088" objetivo="1.2">
		<introducao>A compilação do código abaixo falha.<java><![CDATA[class Base {
    public static void main(String[] args) {
        System.out.println("Base");
    }
}

class Derivada extends Base {
    public static void main(String[] args) {
        System.out.println("Derivada");
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1089" objetivo="1.2">
		<introducao>O modificador de acesso <stmt>protected</stmt> tem
            pouco ou nenhum efeito diferente do modificador
            <it>default</it> caso a classe em questão for declarada <stmt>final</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1090">
		<introducao>A compilação da classe abaixo falha.<java><![CDATA[public class Objeto {
    private Object obj = new Objeto();

    public static void main(String[] args) {
        new Objeto();
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1091">
		<introducao>A execução da classe gera uma exceção (<stmt>StackOverflowError</stmt>).<java><![CDATA[public class Objeto {
    private Object obj = new Objeto();

    public static void main(String[] args) {
        new Objeto();
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1092">
		<introducao>A execução da classe abaixo nunca termina (laço &quot;infinito&quot;).<java><![CDATA[public class Objeto {
    private Object obj = new Objeto();

    public static void main(String[] args) {
        new Objeto();
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1093" objetivo="1.2">
		<introducao>A sentença <stmt>abstract void m();</stmt> declara o
            método <stmt>m()</stmt>, que não retorna valor nem recebe
            algum como entrada. Este método é abstrato, ou seja, nenhum
            código é fornecido, não é um método que é acompanhado de um
            corpo de sentenças em Java. Observe a obrigatoriedade do
            <stmt>;</stmt> após o <stmt>)</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1094" objetivo="1.2">
		<introducao>A compilação do código abaixo não falha.<java><![CDATA[abstract class Abstract {
    public abstract void m();    
}

class SubAbstract extends Abstract {}]]></java>
		</introducao>
		<resposta valor="f">A classe <stmt>SubAbstract</stmt> deve
            ser declarada <stmt>abstract</stmt> ou definir o método <stmt>m()</stmt>.</resposta>
	</questao>
	<questao id="1095" objetivo="1.2">
		<introducao>A compilação da unidade de compilação abaixo não falha.<java><![CDATA[abstract class Abstract {
    public abstract void m();
}

class SubAbstract extends Abstract {
    public void m() {}
}]]></java>
		</introducao>
		<resposta valor="f">
			<stmt>abstract</stmt> é palavra reservada, não pode ser
            empregada como identificador (veja declaração <stmt>package</stmt>).</resposta>
	</questao>
	<questao id="1096" objetivo="1.2">
		<introducao>A compilação da unidade de compilação abaixo falha.<java><![CDATA[abstract class Abstract {
    public abstract void m();
}

class SubAbstract extends Abstract {
    public void m() {}
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1097" objetivo="1.2">
		<introducao>A compilação do código abaixo falha.<java><![CDATA[abstract class Abstract {}

abstract class SubAbstract extends Abstract {
    public void m() {}
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1098" objetivo="1.2">
		<introducao>A compilação do código abaixo falha.<java><![CDATA[abstract class Abstract {}

class SubAbstract extends Abstract {
    public static void main(String[] args) {
        Abstract suba = new SubAbstract();
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1099" objetivo="1.2">
		<introducao>Uma classe que estende (<stmt>extends</stmt>) uma
            classe <stmt>abstract</stmt> deve implementar todos os
            métodos abstratos da superclasse ou também ser declarada <stmt>abstract</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1100" objetivo="1.2">
		<introducao>A compilação falha do código abaixo.<java><![CDATA[abstract class Abstract {
    public abstract void m1();
}

abstract class SubAbstract extends Abstract {
    abstract public void m2();
}

class SubSubAbstract extends SubAbstract {
    public void m2() {}
}]]></java>
		</introducao>
		<resposta valor="v">A classe
            <stmt>SubSubAbstract</stmt> não é declarada
            <stmt>abstract</stmt> e não implementa o método
            <stmt>abstract</stmt> (método <stmt>m1()</stmt>) da classe <stmt>Abstract</stmt>.</resposta>
	</questao>
	<questao id="1101" objetivo="1.2">
		<introducao>A classe
            abaixo<java><![CDATA[package modificador;

abstract public class Base {
    abstract void m();
}]]></java>é
            herdada pela classe <stmt>Derivada</stmt>, fornecida na
            unidade de compilação
            seguinte.<java><![CDATA[package modificador.outro;

import modificador.Base;

public class Derivada extends Base {
    public void m() {}
}]]></java>Pode-se
            afirmar que ambas as unidades de compilação acima são
            compiladas sem falha.</introducao>
		<resposta valor="f">O método <stmt>m()</stmt> declarado
            <stmt>abstract</stmt> é visível apenas no interior do
            <stmt>package</stmt> da classe onde declarado. Não é visível
            a classe de outro <stmt>package</stmt> e, portanto, classe
            de outro <stmt>package</stmt> que herda de <stmt>Base</stmt>
            também deverá ser declarada <stmt>abstract</stmt>, pois não
            há como implementar o método <stmt>m()</stmt>.</resposta>
	</questao>
	<questao id="1102" objetivo="1.2">
		<introducao>A classe
            abaixo<java><![CDATA[package modificador;

abstract public class Base {
    abstract protected void m();
}]]></java>é
            herdada pela classe <stmt>Derivada</stmt>, fornecida na
            unidade de compilação
            seguinte.<java><![CDATA[package modificador.outro;

import modificador.Base;

public class Derivada extends Base {
    public void m() {}
}]]></java>Pode-se
            afirmar que ambas as unidades de compilação acima são
            compiladas sem falha.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1103" objetivo="1.2">
		<introducao>O código abaixo não compila.<java><![CDATA[abstract public class Base {
    abstract protected void m();
}

class SubBase extends Base {
    protected int m() {
        return 1;
    }
}]]></java>
		</introducao>
		<resposta valor="v">Observe que o tipo de retorno do
            método <stmt>m()</stmt> é diferente de <stmt>void</stmt>,
            fornecido na superclasse <stmt>abstract</stmt>.</resposta>
	</questao>
	<questao id="1104" objetivo="1.2">
		<introducao>A sentença <stmt>abstract synchronized void
            m();</stmt> é uma declaração inválida de um método abstrato.</introducao>
		<resposta valor="v">
			<stmt>synchronized</stmt> é restrição sobre a implementação
            de um método, enquanto <stmt>abstract</stmt> posterga
            qualquer informação sobre implementação e, portanto, são incompatíveis.</resposta>
	</questao>
	<questao id="1105" objetivo="1.2">
		<introducao>A sentença <stmt>abstract native void m();</stmt> é
            uma declaração inválida de um método abstrato.</introducao>
		<resposta valor="v">
			<stmt>abstract</stmt> e <stmt>native</stmt> são
            incompatíveis em um único método. Um define a assinatura e o
            tipo de retorno, o outro refere-se à implementação.</resposta>
	</questao>
	<questao id="1106" objetivo="1.2">
		<introducao>A sentença <stmt>abstract strictfp void m();</stmt>
            é uma declaração inválida de um método abstrato.</introducao>
		<resposta valor="v">
			<stmt>strictfp</stmt> fornece informação acerca da
            implementação enquanto <stmt>abstract</stmt> é incompatível
            com implementação.</resposta>
	</questao>
	<questao id="1107" objetivo="1.2">
		<introducao>A compilação da unidade abaixo falha.<java><![CDATA[class Base {
    static void m() {};
}

class SubBase extends Base {
    void m() {}
}]]></java>
		</introducao>
		<resposta valor="v">Método <stmt>static</stmt> não pode
            ser sobreposto (<it>overridden</it>).</resposta>
	</questao>
	<questao id="1108" objetivo="1.2">
		<introducao>Método <stmt>abstract</stmt> não pode ser também
            declarado <stmt>static</stmt>.</introducao>
		<resposta valor="v">Soa razoável, afinal, se é
            <stmt>abstract</stmt>, então a implementação virá em uma
            subclasse. Contudo, se é <stmt>static</stmt>, então é método
            de classe, acessível via classe, o que é absurdo, pois a
            implementação só será fornecida em subclasse.</resposta>
	</questao>
	<questao id="1109" objetivo="1.2">
		<introducao>Qualquer combinação de <stmt>abstract</stmt> com
            <stmt>synchronized</stmt>, <stmt>static</stmt>,
            <stmt>native</stmt>, <stmt>final</stmt>,
            <stmt>private</stmt> ou <stmt>strictfp</stmt> são inválidas.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1110" objetivo="1.2">
		<introducao>Um método declarado <stmt>synchronized</stmt>
            significa que um único <it>thread</it> tem acesso ao método
            por vez.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1111" objetivo="1.2">
		<introducao>Sincronização é uma questão de implementação e,
            portanto, <stmt>synchronized</stmt> é incompatível com <stmt>abstract</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1112" objetivo="1.2">
		<introducao>O classe abaixo compila sem falha.<java><![CDATA[abstract class Base {
    abstract void m(); {};
}]]></java>
		</introducao>
		<resposta valor="v">Observe que um método
            <stmt>abstract</stmt> não pode possuir corpo e o trecho
            <stmt>{};</stmt> poderia se confundir com o corpo de
            <stmt>m()</stmt>, o que não é o caso.</resposta>
	</questao>
	<questao id="1113" objetivo="1.2">
		<introducao>As palavras reservadas <stmt>synchronized</stmt> e
            <stmt>abstract</stmt> são incompatíveis e, portanto, o
            código abaixo não compila.<java><![CDATA[abstract class Base {
    abstract void m();
}

class SubBase extends Base {
    synchronized void m() {}
}]]></java>
		</introducao>
		<resposta valor="f">A declaração de um método que emprega,
            ao mesmo tempo, <stmt>synchronized</stmt> e
            <stmt>abstract</stmt> é inválida. Contudo, não é o que
            ocorre neste caso. O método <stmt>m()</stmt> foi
            legitimamente declarado <stmt>abstract</stmt> e a
            implementação deste, em uma subclasse, definida como de
            acesso exclusivo a um único <it>thread</it> por vez. O que
            também é legítimo. O que é errado é a combinação simultânea
            destas palavras reservadas.</resposta>
	</questao>
	<questao id="1114" objetivo="1.2">
		<introducao>Uma variável não pode ser declarada
            <stmt>strictfp</stmt>, contudo, pode ser declarada <stmt>synchronized</stmt>.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1115" objetivo="1.2">
		<introducao>As variáveis de instâncias podem ser declaradas com
            qualquer um dos quatro modificadores de acesso:
            <stmt>protected</stmt>, <stmt>private</stmt> e
            <stmt>public</stmt> (para os explícitos) e implicitamente o
            modificador de acesso de <stmt>package</stmt> ou <it>default</it>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1116" objetivo="1.2">
		<introducao>Uma variável de instância pode ser declarada <stmt>final</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1117" objetivo="1.2">
		<introducao>Uma variável de instância pode ser declarada <stmt>abstract</stmt>.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1118" objetivo="1.2">
		<introducao>Uma variável de instância pode ser declarada <stmt>synchronized</stmt>.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1119" objetivo="1.2">
		<introducao>Uma variável de instância pode ser declarada <stmt>strictfp</stmt>.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1120" objetivo="1.2">
		<introducao>Uma variável de instância pode ser declarada <stmt>native</stmt>.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1121" objetivo="1.2">
		<introducao>Variáveis locais sempre estão no <it>stack</it> e
            não no <it>heap</it>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1122" objetivo="1.2">
		<introducao>Uma variável local existe (vive) apenas no escopo do
            método em que é declarada.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1123" objetivo="1.2">
		<introducao>O valor de uma variável local pode permanecer além
            da execução de um método, por exemplo, se este é transferido
            a outro que o armazena.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1124" objetivo="1.2">
		<introducao>Uma variável local é parte do <it>stack</it>, mesmo
            que esta seja uma referência para um objeto, que reside no <it>heap</it>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1125" objetivo="1.2">
		<introducao>Uma variável local pode ser declarada <stmt>public</stmt>.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1126" objetivo="1.2">
		<introducao>Uma variável local pode ser declarada <stmt>private</stmt>.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1127" objetivo="1.2">
		<introducao>Uma variável local pode ser declarada <stmt>protected</stmt>.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1128" objetivo="1.2">
		<introducao>Uma variável local pode ser declarada com o
            modificador de acesso <it>default</it>.</introducao>
		<resposta valor="f">Embora o modificador de acesso
            <it>default</it> seja implícito, a rigor os modificadores de
            acesso não se aplicam às variáveis locais.</resposta>
	</questao>
	<questao id="1129" objetivo="1.2">
		<introducao>Uma variável local pode ser declarada <stmt>final</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1130" objetivo="1.2">
		<introducao>O código abaixo compila sem falha.<java><![CDATA[class A {
    private int x;
    
    void m() {
        int y = 3;
        x = x + 1;
    }
    
    void k() {
        x = x + y;
    }
}]]></java>
		</introducao>
		<resposta valor="f">A variável <stmt>y</stmt> só é acessível
            no interior do método <stmt>m</stmt>.</resposta>
	</questao>
	<questao id="1131" objetivo="1.2">
		<introducao>A compilação da classe abaixo falha.<java><![CDATA[class A {
    private int x, y;

    void m() {
        int y;
        int x;
        x = x + y;
    }
}]]></java>
		</introducao>
		<resposta valor="v">
			<stmt>x</stmt> e <stmt>y</stmt> são variáveis locais
            utilizadas antes de serem iniciadas.</resposta>
	</questao>
	<questao id="1132" objetivo="1.2">
		<introducao>A compilação do código abaixo falha.<java><![CDATA[class A {
    static int x, y;

    void m() {
        int y;
        int x;
        x = A.x + A.y;
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1133" objetivo="1.2">
		<introducao>A compilação do código abaixo falha.<java><![CDATA[class A {
    static int x, y;

    void m() {
        int x;
        x = this.x + this.y;
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1134" objetivo="1.2">
		<introducao>A compilação do código abaixo falha.<java><![CDATA[class A {
    static int x, y;

    void m() {
        int x;
        x = this.x + this.y;
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1135" objetivo="1.2">
		<introducao>A compilação do código abaixo falha.<java><![CDATA[class A {
    static int x, y;

    static void m() {
        x = this.x + this.y;
    }
}]]></java>
		</introducao>
		<resposta valor="v">Observe que o método
            <stmt>static</stmt> faz emprego de variáveis de instância.</resposta>
	</questao>
	<questao id="1136" objetivo="1.2">
		<introducao>A compilação do código abaixo falha, pois há
            tentativa de se fazer uso das variáveis <stmt>x</stmt> e
            <stmt>y</stmt> sem que tenham sido iniciadas.<java><![CDATA[class A {
    static int x, y;

    static void m() {
        x = x + y;
    }
}]]></java>
		</introducao>
		<resposta valor="f">Valores <it>default</it> são fornecidos
            para variáveis de instância, mesmo que tenham sido
            declaradas <stmt>static</stmt>.</resposta>
	</questao>
	<questao id="1137" objetivo="1.2">
		<introducao>A compilação do código abaixo falha, pois há
            tentativa de se fazer uso das variáveis <stmt>x</stmt> e
            <stmt>y</stmt> sem que tenham sido iniciadas.<java><![CDATA[class A {
    static int x, y;

    static void m() {
        x = x + y;
    }
}]]></java>
		</introducao>
		<resposta valor="f">Apenas variáveis locais exigem que sejam
            iniciadas explicitamente antes de serem empregadas.</resposta>
	</questao>
	<questao id="1138" objetivo="1.2">
		<introducao>Valores <it>default</it> não se aplicam às variáveis locais.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1139" objetivo="1.2">
		<introducao>Após a execução do método <stmt>m()</stmt>, para uma
            instância da classe abaixo,  valor depositado em
            <stmt>y</stmt> é <stmt>4</stmt>.<java><![CDATA[class A {
    int x, y;

    void m() {
        int x, y;
        x = 1;
        x = x + x;
        y = 2;
        y = x + y;
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1140" objetivo="1.2">
		<introducao>Após a execução do método <stmt>m()</stmt>, para uma
            instância da classe abaixo,  valor depositado em
            <stmt>y</stmt> é <stmt>0</stmt>.<java><![CDATA[class A {
    int x, y;

    void m() {
        int x, y;
        x = x + x;
        y = x + y;
    }
}]]></java>
		</introducao>
		<resposta valor="f">Há um erro de compilação, pois as
            variáveis locais não são iniciadas.</resposta>
	</questao>
	<questao id="1141" objetivo="1.2">
		<introducao>O código abaixo não compila.<java><![CDATA[class A {
    int x, y;

    void m(int x, int y) {
        x = x;
        y = y;
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1142" objetivo="1.2">
		<introducao>A compilação da classe <java>class A { final int x;
            }</java> falha.</introducao>
		<resposta valor="v">A variável de instância declarada
            <stmt>final</stmt> não foi iniciada.</resposta>
	</questao>
	<questao id="1143" objetivo="1.2">
		<introducao>A compilação da classe abaixo falha.<java><![CDATA[class A {
    final int x;

    private A() {
        x = 1;
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1144" objetivo="1.2">
		<introducao>O código abaixo compila.<java><![CDATA[class A {
    public final int x,y;
 
    A(int i){ x = y = 2; }
}

class B {
    A a = new A(1);
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1145" objetivo="1.2">
		<introducao>O código abaixo compila.<java><![CDATA[class A {
    public final int x,y;
 
    A(int i){ x = y = 2; }
}

class B extends A {
    A a = new A(1);
}]]></java>
		</introducao>
		<resposta valor="f">Não há construtor <it>default</it> e,
            portanto, as variáveis declaradas como <stmt>final</stmt>
            podem não ser explicitamente iniciadas.</resposta>
	</questao>
	<questao id="1146" objetivo="1.2">
		<introducao>A compilação do código abaixo não falha.<java><![CDATA[class A {
    public final int x = 2;
}

class B extends A {
    int y = A.x;
}]]></java>
		</introducao>
		<resposta valor="f">Não confunda <stmt>final</stmt> com <stmt>static</stmt>.</resposta>
	</questao>
	<questao id="1147" objetivo="1.2">
		<introducao>A compilação do código abaixo não falha.<java><![CDATA[class A {
    public static int x = 2;
}

class B extends A {
    int y = A.x;
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1148" objetivo="1.2">
		<introducao>Uma variável local de um tipo primitivo declarada
            <stmt>final</stmt> irá reter um mesmo valor durante toda a
            sua existência, após iniciada.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1149" objetivo="1.2">
		<introducao>Uma variável que retém uma referência para um objeto
            e é declarada <stmt>final</stmt> não poderá reter nenhuma
            outra referência para outro objeto.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1150" objetivo="1.2">
		<introducao>A compilação das classes abaixo falha.<java><![CDATA[class A {
    public static int x = 2;
}

class B extends A {
    final int y = A.x;
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1151" objetivo="1.2">
		<introducao>Objeto cuja referência é armazenada em uma variável
            declarada <stmt>final</stmt> não pode ter o valor de seus
            membros (variáveis de instância) alterados através da
            referência armazenada nesta variável declarada <stmt>final</stmt>.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1152" objetivo="1.2">
		<introducao>Variáveis de instância declaradas <stmt>final</stmt>
            não necessariamente precisam ser iniciadas na mesma sentença
            que as declara.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1153" objetivo="1.2">
		<introducao>A classe abaixo contém um erro detectado em tempo de compilação.<java><![CDATA[class A {
    public final int x;

    A() {
        final int x;
        this.x = 1;
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1154" objetivo="1.2">
		<introducao>A classe abaixo compila sem falha.<java><![CDATA[class A {
    public final int x;

    A() {
        final int x;
        this.x = 1;
        x += 2;
    }
}]]></java>
		</introducao>
		<resposta valor="f">Há tentativa de se fazer uso de
            <stmt>x</stmt> sem que seja iniciada.</resposta>
	</questao>
	<questao id="1155" objetivo="1.2">
		<introducao>A compilação da classe abaixo falha.<java><![CDATA[class A {
    public int y;
    public int x = y + 2;
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1156" objetivo="1.2">
		<introducao>A compilação da classe abaixo falha.<java><![CDATA[class A {
    public int y;
    public final int x = y + 2;
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1157" objetivo="1.2">
		<introducao>A compilação da classe abaixo falha.<java><![CDATA[class A {
    public int x = y + 2;
    public int y;
}]]></java>
		</introducao>
		<resposta valor="v">Referência  ilegal a elemento
            declarado posteriormente.</resposta>
	</questao>
	<questao id="1158" objetivo="1.2">
		<introducao>O código abaixo não compila, pois existe tentativa
            de alterar o valor da variável de referência <stmt>a</stmt>.<java><![CDATA[class A {
    public int x;
    public int y;
}

class B {
    final A a = new A();
    int b = a.x = 2;
}]]></java>
		</introducao>
		<resposta valor="f">A variável de referência não pode ter o
            seu valor alterado, não o objeto referenciado por esta.</resposta>
	</questao>
	<questao id="1159" objetivo="1.2">
		<introducao>Em uma interface, uma variável é sempre
            <stmt>final</stmt>, mesmo que esta não tenha sido
            explicitamente declarada.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1160" objetivo="1.2">
		<introducao>O código abaixo compila sem falha.<java><![CDATA[interface Sentido {
    byte norte;
}

class Orientacao implements Sentido {
    Orientacao() {
        norte = 'N';
    }
}]]></java>
		</introducao>
		<resposta valor="f">Variável <stmt>norte</stmt> não é
            iniciada. Variável declarada em uma interface é
            implicitamente <stmt>final</stmt>.</resposta>
	</questao>
	<questao id="1161" objetivo="1.2">
		<introducao>Uma variável declarada em uma interface, sempre é
            declarada <stmt>public static final</stmt>, independente de
            ser explicitamente declarada assim ou não.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1162" objetivo="1.2">
		<introducao>O código abaixo compila sem falha.<java><![CDATA[interface Sentido {
    private char n = 'n';
}

class Orientacao implements Sentido {
    Orientacao() {
        System.out.println(n);
    }
}]]></java>
		</introducao>
		<resposta valor="f">Variável de interface sempre é <stmt>public</stmt>.</resposta>
	</questao>
	<questao id="1163" objetivo="1.2">
		<introducao>Pode-se afirmar que a execução do construtor
            <stmt>Orientacao</stmt> exibe o resultado <stmt>false</stmt>.<java><![CDATA[interface Sentido {
    char NORTE = 1;
    char SUL = 2;
    char LESTE = 3;
    char OESTE = 4;
    char[] ca = new char[]{NORTE, SUL, LESTE, OESTE};
}

class Orientacao implements Sentido {
    Orientacao() {
        NORTE = 2;
        System.out.println(ca[0] == 2);
    }
}]]></java>
		</introducao>
		<resposta valor="f">Este código não compila. Há tentativa de
            se alterar o valor de uma variável <stmt>final</stmt>.</resposta>
	</questao>
	<questao id="1164" objetivo="1.2">
		<introducao>Pode-se afirmar que a execução do construtor
            <stmt>Orientacao</stmt> exibe o resultado <stmt>true</stmt>.<java><![CDATA[interface Sentido {
    char NORTE = 1;
    char SUL = 2;
    char LESTE = 3;
    char OESTE = 4;
    char[] ca = new char[]{NORTE, SUL, LESTE, OESTE};
}

class Orientacao implements Sentido {
    Orientacao() {
        NORTE = 2;
        System.out.println(ca[0] == 2);
    }
}]]></java>
		</introducao>
		<resposta valor="f">Este código não compila. Há tentativa de
            se alterar o valor de uma variável <stmt>final</stmt>.</resposta>
	</questao>
	<questao id="1165" objetivo="1.2">
		<introducao>Uma classe declarada <stmt>final</stmt> não pode ser
            herdada. Um método declarado <stmt>final</stmt> não pode ser
            sobreposto (<it>overridden</it>) e uma variável, seja local
            ou de instância, declarada <stmt>final</stmt>, não pode ter
            o seu valor alterado.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1166" objetivo="1.2">
		<introducao>Uma variável local pode ser declarada <stmt>transient</stmt>.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1167" objetivo="1.2">
		<introducao>Uma variável de instância pode ser declarada <stmt>transitent</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1168" objetivo="1.2">
		<introducao>Uma variável, seja local ou de instância, pode ser
            declarada <stmt>transient</stmt>.</introducao>
		<resposta valor="f">Apenas variáveis de instância podem ser
            declaradas <stmt>transient</stmt>.</resposta>
	</questao>
	<questao id="1169" objetivo="1.2">
		<introducao>Todas as variáveis locais são implicitamente
            declaradas <stmt>transient</stmt>.</introducao>
		<resposta valor="f">Este modificador só se aplica a
            variáveis de instância.</resposta>
	</questao>
	<questao id="1170" objetivo="1.2">
		<introducao>Variáveis de instância podem ser declaradas
            <stmt>transient</stmt> com o propósito de indicar que não
            fazem parte do estado persistente do objeto.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1171" objetivo="1.2">
		<introducao>Uma classe que implementa a interface abaixo e cujos
            objetos correspondentes forem serializados não irá armazenar
            a variável <stmt>NORTE</stmt>.</introducao>
		<resposta valor="f">Esta interface é inválida.
            <stmt>transient</stmt> é modificador inválido para variável
            de interface.</resposta>
	</questao>
	<questao id="1172" objetivo="1.2">
		<introducao>A classe abaixo não compila. Observe que a variável
            <stmt>x</stmt> (declarada <stmt>transient</stmt>) tem o seu
            valor alterado no interior do construtor.<java><![CDATA[class Orientacao {
    transient static int x = 1;

    Orientacao() {
        x = 2;
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1173" objetivo="1.2">
		<introducao>A classe abaixo não compila. Observe que
            <stmt>transient</stmt> e <stmt>static</stmt> são
            modificadores incompatíveis.<java><![CDATA[class Orientacao {
    transient static int x = 1;

    Orientacao() {
        x = 2;
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1174" objetivo="1.2">
		<introducao>A classe abaixo não compila.<java><![CDATA[class Orientacao {
    transient static int x = 1;

    Orientacao() {
        x = 2;
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1175" objetivo="1.2">
		<introducao>A classe abaixo não compila porque
            <stmt>transient</stmt> e <stmt>final</stmt> são
            modificadores incompatíveis.<java><![CDATA[class Orientacao {
    transient final int x = 1;

    Orientacao() {
        x = 2;
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1176" objetivo="1.2">
		<introducao>O código abaixo compila.<java><![CDATA[class Orientacao {
    static int x = 1;

    static void Orientacao() {
        System.out.println("NORTE");
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1177" objetivo="1.2">
		<introducao>O código abaixo compila.<java><![CDATA[class Orientacao {
    static int x = 1;

    static Orientacao() {
        System.out.println("NORTE");
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1178" objetivo="1.2">
		<introducao>A classe abaixo não compila.<java><![CDATA[class Numero {
    transient volatile static public boolean b = false;
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1179" objetivo="1.2">
		<introducao>A classe abaixo não compila.<java><![CDATA[class Numero {
    final transient static protected boolean b = false;
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1180" objetivo="1.2">
		<introducao>A classe abaixo não compila.<java><![CDATA[class Numero {
    final static volatile boolean b = false;
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1181" objetivo="1.2">
		<introducao>Em Java, <it>threads</it> que fazem acesso a
            variáveis compartilhadas podem manter cópias privadas destas variáveis.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1182" objetivo="1.2">
		<introducao>Cópias privadas de variáveis compartilhadas por
            <it>threads</it> podem exigir mecanismos de sincronização
            para assegurar a consistência de informações. A palavra
            reservada <stmt>synchronized</stmt> é empregada para tal.
            Alternativamente, embora com uma semântica diferente, pode
            ser suficiente a declaração das variáveis em questão com o
            modificador <stmt>volatile</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1183" objetivo="1.2">
		<introducao>A compilação da classe abaixo falha.<java><![CDATA[class Numero {
    transient volatile boolean b = false;
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1184" objetivo="1.2">
		<introducao>A compilação da classe abaixo falha.<java><![CDATA[class Numero {
    transient volatile boolean b = false;
    
    boolean obtemBoolean() {
        boolean a = true;
        return !a;
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1185" objetivo="1.2">
		<introducao>Os modificadores <stmt>volatile</stmt> e
            <stmt>transiente</stmt> podem ser aplicados a uma mesma variável.</introducao>
		<resposta valor="f">O certo é <stmt>transient</stmt>.
            Observe a última letra &quot;sobrando&quot;.</resposta>
	</questao>
	<questao id="1186" objetivo="1.2">
		<introducao>Os modificadores <stmt>volatile</stmt> e
            <stmt>transient</stmt> podem fazer parte de uma mesma
            declaração de uma variável.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1187" objetivo="1.2">
		<introducao>Os modificadores <stmt>volatile</stmt> e
            <stmt>transient</stmt> podem fazer parte de uma mesma
            declaração de um método.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1188" objetivo="1.2">
		<introducao>Pode-se empregar um membro <stmt>static</stmt> de
            uma classe sem a existência de pelo menos uma instância
            desta classe.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1189" objetivo="1.2">
		<introducao>Uma variável declarada <stmt>static</stmt> será
            compartilhada por todas as instâncias que eventualmente
            existirem da classe na qual foi declarada.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1190" objetivo="1.2">
		<introducao>Cada variável declarada <stmt>static</stmt> possui
            uma única cópia compartilhada entre todas as instâncias da
            classe em questão, independente do número de instâncias, que
            pode ser zero ou mais.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1191" objetivo="1.2">
		<introducao>A compilação do código abaixo falha.<java><![CDATA[class A {
    final static transient boolean Boolean = B.Boolean;
}

class B {
    final static transient boolean Boolean = A.Boolean;
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1192" objetivo="1.2">
		<introducao>A compilação do código abaixo falha.<java><![CDATA[class A {
    static boolean b = B.b;
}

class B {
    static boolean b = A.b;
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1193" objetivo="1.2">
		<introducao>A unidade de compilação formada pelas classes
            <stmt>A</stmt> e <stmt>B</stmt> é fornecida abaixo. Pode-se
            afirmar que a compilação desta não falha e que, a execução
            de <stmt>java A</stmt> produz a mensagem <stmt>A</stmt> e a
            execução de <stmt>B</stmt> produz a mensagem <stmt>B</stmt>.<java><![CDATA[class A {
    static boolean b = B.b;

    public static void main(String[] args) {
        System.out.println("A");
    }
}

class B {
    static boolean b = A.b;

    public static void main(String[] args) {
        System.out.println("B");
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1194" objetivo="1.2">
		<introducao>A compilação do código abaixo falha.<java><![CDATA[class A {
    static int a = 1;

    A() {
        a++;
    }
}

class UsaA {
    public static void main(String[] args) {
        new A();
        new A();
        System.out.println(A.a != new A().a);
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1195" objetivo="1.2">
		<introducao>A execução do código abaixo exibe o valor <stmt>false</stmt>.<java><![CDATA[class A {
    static int a = 1;

    A() {
        a++;
    }
}

class UsaA {
    public static void main(String[] args) {
        new A();
        new A();
        System.out.println(A.a != new A().a);
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1196" objetivo="1.2">
		<introducao>A compilação do código abaixo falha.<java><![CDATA[class A {
    static int a = 1;

    A() {
        a++;
    }
}

class UsaA {
    public static void main(String[] args) {
        A a = new A();
        new A();
        System.out.println(A.a != a.a);
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1197" objetivo="1.2">
		<introducao>A execução do código abaixo resulta na exibição de <stmt>true</stmt>.<java><![CDATA[class A {
    static int a = 1;

    A() {
        a++;
    }
}

class UsaA {
    public static void main(String[] args) {
        A a = new A();
        new A();
        System.out.println(A.a != a.a);
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1198" objetivo="1.2">
		<introducao>A classe abaixo não compila.<java><![CDATA[class A {
    int a = 1;

    static void adicionaUm() {
        a++;
    }
}]]></java>
		</introducao>
		<resposta valor="v">Tentativa de empregar variável de
            instância que não é <stmt>static</stmt> em método declarado <stmt>static</stmt>.</resposta>
	</questao>
	<questao id="1199" objetivo="1.2">
		<introducao>Não é permitido o acesso a uma variável de instância
            em um método declarado <stmt>static</stmt> ou método de
            classe sem que este acesso seja feito através de uma
            referência a um objeto da classe em questão.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1200" objetivo="1.2">
		<introducao>A classe abaixo não compila.<java><![CDATA[class transiente {
    int x = 1;
    
    public static void main(String[] args) {
        System.out.println("x: " + x);
    }
}]]></java>
		</introducao>
		<resposta valor="v">
			<stmt>x</stmt> é variável de instância e o método
            <stmt>main</stmt> é declarado <stmt>static</stmt>.</resposta>
	</questao>
	<questao id="1201" objetivo="1.2">
		<introducao>A classe abaixo não compila.<java><![CDATA[class transiente {
    int x = 1;
    
    public void main(String[] args) {
        System.out.println("x: " + x);
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1202" objetivo="1.2">
		<introducao>O valor impresso pela execução da classe abaixo é 26.<java><![CDATA[class transiente {
    int x = 1;
    int y = 5;

    public static void main(String[] args) {
        for (int i = 0; i < y; i++) {
            x += y;
        }
        System.out.println("x: " + x);
    }
}]]></java>
		</introducao>
		<resposta valor="f">A compilação falha. Método
            <stmt>static</stmt> tenta fazer uso de variável de instância.</resposta>
	</questao>
	<questao id="1203" objetivo="1.2">
		<introducao>O método <stmt>igual()</stmt> fornecido abaixo
            sempre irá retornar o valor <stmt>true</stmt>.<java><![CDATA[class transiente {
    int x = 1;
    int y = 5;
    
    boolean igual() {
        return this.x = x;
    }
}]]></java>
		</introducao>
		<resposta valor="f">A classe não compila. Observe que
                <stmt>this.x == x</stmt> é diferente de <stmt>this.x = x</stmt>.</resposta>
	</questao>
	<questao id="1204" objetivo="1.2">
		<introducao>O método <stmt>igual()</stmt> fornecido abaixo
            sempre irá retornar o valor <stmt>true</stmt>.<java><![CDATA[class transiente {
    int x = 1;
    int y = 5;
    
    static boolean igual() {
        return (this.x == x);
    }
}]]></java>
		</introducao>
		<resposta valor="f">Observe que o método <stmt>static</stmt>
            tenta fazer uso de variável de instância, o que provoca um
            erro em tempo de compilação.</resposta>
	</questao>
	<questao id="1205" objetivo="1.2">
		<introducao>Métodos e variáveis (não locais) podem ser
            declaradas com o modificador <stmt>static</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1206" objetivo="1.2">
		<introducao>Variáveis locais podem ser declaradas <stmt>static</stmt>.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1207" objetivo="1.2">
		<introducao>O método <stmt>igual()</stmt> da classe transcrita
            abaixo pode retornar o valor <stmt>true</stmt>.<java><![CDATA[class transiente {
    int x = 1;
    int y = 5;

    boolean igual() {
        static int y = 2;
        return (this.x != (y - 1));
    }
}]]></java>
		</introducao>
		<resposta valor="f">A classe não compila. Variável local não
            pode ser declarada <stmt>static</stmt>.</resposta>
	</questao>
	<questao id="1208" objetivo="4.1">
		<introducao>Se uma classe é declarada <stmt>public</stmt>, então
            esta deve ser a única na unidade de compilação.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1209" objetivo="4.1">
		<introducao>Em uma unidade de compilação que possui pelo menos
            duas classes declaradas <stmt>public</stmt>, só uma delas
            pode possuir o método <stmt>main</stmt>.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1210" objetivo="4.1">
		<introducao>Quando mais de uma classe é declarada
            <stmt>public</stmt> em uma mesma unidade de compilação,
            então o nome do arquivo desta unidade deve coincidir com o
            nome da primeira classe <stmt>public</stmt> encontrada no arquivo.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1211" objetivo="4.1">
		<introducao>Só pode existir uma classe declarada
            <stmt>public</stmt> por arquivo.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1212" objetivo="4.1">
		<introducao>Toda unidade de compilação, ou arquivo contendo
            código em Java, deve possuir uma classe declarada <stmt>public</stmt>.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1213" objetivo="4.1">
		<introducao>Necessariamente todo arquivo em Java deve possuir
            uma classe declarada <stmt>public</stmt>.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1214" objetivo="4.1">
		<introducao>Em uma unidade de compilação só pode existir, no
            máximo, uma classe declarada <stmt>public</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1215" objetivo="4.1">
		<introducao>Em um arquivo contendo código em Java podem existir
            várias classes.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1216" objetivo="4.1">
		<introducao>Podem coexistir, em um mesmo arquivo, classes
            declaradas com distintos modificadores de acesso:
            <stmt>public</stmt>, <stmt>private</stmt>,
            <stmt>protected</stmt> e <it>default</it>. Observe que este
            último é implícito.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1217" objetivo="4.1">
		<introducao>A compilação do código abaixo falha.<java><![CDATA[public class Teste {}
public class B extends Teste {}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1218" objetivo="4.1">
		<introducao>A código abaixo deve estar, necessariamente, em um
            arquivo identificado por <bd>Teste.java</bd>.<java><![CDATA[public class Teste {}
public class B extends Teste {}]]></java>
		</introducao>
		<resposta valor="f">Duas classes declaradas
            <stmt>public</stmt> não podem coexistir em um mesmo arquivo.</resposta>
	</questao>
	<questao id="1219" objetivo="4.1">
		<introducao>A compilação do código abaixo falha.<java><![CDATA[class Teste {}
class B extends Teste {}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1220" objetivo="4.1">
		<introducao>A compilação do código abaixo falha.<java><![CDATA[public class Teste {}
class B extends Teste {}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1221" objetivo="4.1">
		<introducao>A compilação do código abaixo falha.<java><![CDATA[class Teste {}
private class B extends Teste {}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1222" objetivo="4.1">
		<introducao>A compilação do código abaixo falha.<java><![CDATA[public class Teste {}
protected class B extends Teste {}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1223" objetivo="4.1">
		<introducao>O código abaixo deve, necessariamente, estar em um
            arquivo identificado por <bd>Teste.java</bd>.<java><![CDATA[class Teste {}
class B extends Teste {}]]></java>
		</introducao>
		<resposta valor="f">Não há classe declarada
            <stmt>public</stmt> e, portanto, nenhuma restrição ao nome
            do arquivo que contém a unidade de compilação acima.</resposta>
	</questao>
	<questao id="1224" objetivo="4.1">
		<introducao>O código abaixo deve, necessariamente, estar em um
            arquivo identificado por <bd>B.java</bd>.<java><![CDATA[class Teste {}
public class B extends Teste {}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1225" objetivo="4.1">
		<introducao>O código abaixo deve, necessariamente, estar em um
            arquivo identificado por <bd>B.java</bd>.<java><![CDATA[public class Teste {}
class B extends Teste {}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1226" objetivo="4.1">
		<introducao>O código abaixo pode estar em um arquivo
            identificado por <bd>$ok.java</bd>.<java><![CDATA[class Teste {}
class B extends Teste {}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1227" objetivo="4.1">
		<introducao>O nome de um arquivo contendo código em Java deve
            coincidir com o nome da única classe declarada
            <stmt>public</stmt> que pode existir em uma unidade de compilação.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1228" objetivo="4.1">
		<introducao>Se uma classe pertente a um <stmt>package</stmt>,
            então a declaração do <stmt>package</stmt> deve ser a
            primeira linha (exclua comentários e espaços em branco) do
            arquivo que contém a classe. </introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1229" objetivo="4.1">
		<introducao>Para cada classe não declarada <stmt>public</stmt>
            em uma unidade de compilação pode existir uma declaraçao de
            <stmt>package</stmt> correspondente e, neste caso, esta
            declaração deve imediatamente preceder a declaração da(s)
            classe(s) em questão.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1230" objetivo="4.1">
		<introducao>A unidade de compilação abaixo declara a classe
            <stmt>Teste</stmt> pertentence ao <stmt>package</stmt>
            identificado por <stmt>misc.testes</stmt>.<java><![CDATA[package misc;
package testes;

public class Teste {}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1231" objetivo="4.1">
		<introducao>A declaração de um <stmt>package</stmt> é
            necessariamente terminada por ponto-e-vírgula (<stmt>;</stmt>).</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1232" objetivo="4.1">
		<introducao>A unidade de compilação abaixo declara a classe
            <stmt>Teste</stmt> pertentence ao <stmt>package</stmt>
            identificado por <stmt>misc</stmt>.<java><![CDATA[package misc;

public class Teste {}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1233" objetivo="4.1">
		<introducao>A unidade de compilação abaixo declara a classe
            <stmt>Teste</stmt> pertentence ao <stmt>package</stmt>
            identificado por <stmt>final</stmt>.<java><![CDATA[package final;

public class Teste {}]]></java>
		</introducao>
		<resposta valor="f">Observe que <stmt>final</stmt> é palavra
            reservada e, portanto, não pode ser empregada como identificador.</resposta>
	</questao>
	<questao id="1234" objetivo="4.1">
		<introducao>A unidade de compilação abaixo declara a classe
            <stmt>Teste</stmt> pertentence ao <stmt>package</stmt>
            identificado por <stmt>x</stmt>.<java><![CDATA[package x

public class Teste {}]]></java>
		</introducao>
		<resposta valor="f">Falta o ponto-e-vírgula para demarcar o
            fim da declaração do <stmt>package</stmt>.</resposta>
	</questao>
	<questao id="1235" objetivo="4.1">
		<introducao>A unidade de compilação abaixo declara a classe
            <stmt>Teste</stmt> pertentence ao <stmt>package</stmt>
            identificado por <stmt>Teste</stmt>.<java><![CDATA[package Teste;

public class Teste {}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1236" objetivo="4.1">
		<introducao>O nome de uma classe deve ser diferente do nome do
            <stmt>package</stmt> ao qual pertente.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1237" objetivo="4.1">
		<introducao>O código abaixo deve estar em uma unidade de
            compilação necessariamente denominada de
            <bd>Teste1.java</bd> e declara duas classes, de
            <stmt>package</stmt>s distintos. Um identificado por
            <stmt>misc</stmt> e o outro por <stmt>testes</stmt>.<java><![CDATA[package misc;
public class Teste1 {}

package testes;
class Teste2 {}]]></java>
		</introducao>
		<resposta valor="f">Só pode existir uma única declaração de
            <stmt>package</stmt> por unidade de compilação.</resposta>
	</questao>
	<questao id="1238" objetivo="4.1">
		<introducao>A declaração de uma classe de vir necessariamente
            após a declaração de sentenças <stmt>import</stmt>, se for o
            caso da existência destas.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1239" objetivo="4.1">
		<introducao>Uma declaração <stmt>import</stmt> pode seguir a
            declaração de uma classe e, neste caso, esta declaração só
            terá efeito para as classes que seguirem a declaração.</introducao>
		<resposta valor="f">Declarações <stmt>import</stmt> devem
            vir antes da declaração de qualquer classe.</resposta>
	</questao>
	<questao id="1240" objetivo="4.1">
		<introducao>A compilação do código abaixo falha.<java><![CDATA[package misc;
public class Teste {}

import java.io.File;
class Teste2 {}]]></java>
		</introducao>
		<resposta valor="v">Declaração <stmt>import</stmt> deve
            preceder a declaração de todas as classes.</resposta>
	</questao>
	<questao id="1241" objetivo="4.1">
		<introducao>A compilação do código abaixo falha.<java><![CDATA[package misc;
import java.io.File;
public class Teste {}
class Teste2 {}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1242" objetivo="4.1">
		<introducao>A compilação do código abaixo falha.<java><![CDATA[package misc;
import java.lang.String;
public class Teste {}
class Teste2 {}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1243" objetivo="4.1">
		<introducao>A compilação do código abaixo falha, pois a classe
            <stmt>Teste</stmt> não faz uso da classe <stmt>String</stmt>.<java><![CDATA[package misc;
import java.lang.String;
public class Teste {}
]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1244" objetivo="4.1">
		<introducao>A compilação do código abaixo falha, pois a classe
            <stmt>String</stmt> nem pertence ao <stmt>package</stmt>
            identificado por <stmt>java.lang</stmt>, mas àquele
            identificado por <stmt>java.util</stmt>.<java><![CDATA[package misc;
import java.lang.String;
public class Teste {}
]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1245" objetivo="4.1">
		<introducao>A sentença <stmt>package</stmt> e as sentenças
            <stmt>import</stmt> que eventualmente estejam presentes em
            uma unidade de compilação aplicam-se a todas as classes ali declaradas.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1246" objetivo="4.1">
		<introducao>Só pode existir uma única declaração
            <stmt>package</stmt> por arquivo.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1247" objetivo="4.1">
		<introducao>Podem existir zero ou mais declarações
            <stmt>import</stmt> por arquivo.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1248" objetivo="4.1">
		<introducao>O código abaixo compila satisfatoriamente.<java><![CDATA[package misc;

import java.lang.String;

public class Teste {
    public static void main(String[] args) {
        System.out.println("Ok");
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1249" objetivo="4.1">
		<introducao>O código abaixo compila satisfatoriamente.<java><![CDATA[import java.lang.String;

package misc;

public class Teste {
    public static void main(String[] args) {
        System.out.println("Ok");
    }
}]]></java>
		</introducao>
		<resposta valor="f">Observe que a declaração
            <stmt>package</stmt> deve preceder todas as demais.</resposta>
	</questao>
	<questao id="1250" objetivo="4.1">
		<introducao>Em uma unidade de compilação pertencente a
            determinado <stmt>package</stmt>, a declaração deste é a
            primeira do arquivo correspondente.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1251" objetivo="4.1">
		<introducao>A compilação do código abaixo falha.<java><![CDATA[// Package miscelâneas
package misc;

// Empregada por convenção da empresa (não é obrigatório)
import java.lang.String;

class Teste {
    public static void main(String[] args) {
        System.out.println("Ok");
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1252" objetivo="4.1">
		<introducao>Embora de utilidade questionável, a compilação do
            código abaixo não falha.<java><![CDATA[package misc.ok.t01.k2.go;

class Teste {}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1253" objetivo="4.1">
		<introducao>A compilação do código abaixo falha.<java><![CDATA[package misc.ok.t01.k2.go;

class Teste { }]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1254" objetivo="4.1">
		<introducao>Em um arquivo que contém uma declaração
            <stmt>package</stmt>, uma ou mais declarações
            <stmt>import</stmt> e a declaração de classes, a declaração
            <stmt>package</stmt> deve preceder as declarações
            <stmt>import</stmt> e só então podem seguir as declarações
            das classes.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1255" objetivo="4.1">
		<introducao>A compilação do código abaixo falha.<java><![CDATA[package misc;

import misc.*;

class Teste {}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1256" objetivo="4.1">
		<introducao>A compilação do código abaixo falha.<java><![CDATA[class Teste {}

package misc;

import misc.*;
]]></java>
		</introducao>
		<resposta valor="v">A ordem das declarações está invertida.</resposta>
	</questao>
	<questao id="1257" objetivo="4.1">
		<introducao>A sentença <stmt>package x;</stmt> é suficiente para
            compor uma unidade de compilação cuja compilação não falha,
            embora de pouca utilidade.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1258" objetivo="4.1">
		<introducao>Uma declaração <stmt>package</stmt> aplica-se a
            todas as classes de um arquivo.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1259" objetivo="4.1">
		<introducao>Uma declaração <stmt>import</stmt> aplica-se a todas
            as classes de um arquivo.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1260" objetivo="4.1">
		<introducao>Todas as classes declaradas em um arquivo que contém
            uma declaração <stmt>package</stmt> pertencem a um mesmo <stmt>package</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1261" objetivo="4.1">
		<introducao>O código abaixo exibe todos os argumentos fornecidos
            na linha de comandos, um por linha.<java><![CDATA[package misc;

include java.lang.*;

class Teste {
    public static void main(String[] args) {
        for (int i = 0; i < args.length; i++) {
            System.out.println(args[i]);
        }
    }
}]]></java>
		</introducao>
		<resposta valor="f">Em Java não existe &quot;include&quot;,
            que é elemento da linguagem C. Em Java tem-se <stmt>import</stmt>.</resposta>
	</questao>
	<questao id="1262" objetivo="4.1">
		<introducao>A declaração <stmt>package ufg.inf.*</stmt> ou a
            declaração <stmt>package ufg.inf.Aluno</stmt> deve estar
            presente em uma unidade de compilação que faz uso da classe <stmt>Aluno</stmt>.</introducao>
		<resposta valor="f">Não é <stmt>package</stmt>, mas
            <stmt>import</stmt> a palavra reservada correta.</resposta>
	</questao>
	<questao id="1263" objetivo="4.1">
		<introducao>A declaração <stmt>import ufg.inf.*</stmt> ou a
            declaração <stmt>import ufg.inf.Aluno</stmt> deve estar
            presente em uma unidade de compilação que faz uso da classe
            <stmt>Aluno</stmt>. Assuma que a unidade de compilação
            pertente ao <stmt>package</stmt> denominado
            <stmt>ufg.inf.academico</stmt> e que a classe
            <stmt>Aluno</stmt> está declarada no <stmt>package</stmt>
            identificado por <stmt>ufg.inf</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1264" objetivo="4.1">
		<introducao>Assuma que a classe <stmt>Departamento</stmt> é
            declarada no <stmt>package</stmt> identificado por
            <stmt>ufg.inf.orgaos</stmt>. Dessa forma, para se criar uma
            instância de <stmt>Departamento</stmt> pode se empregar
                <stmt>new Departamento()</stmt> ou
            <stmt>ufg.inf.orgaos.Departamento()</stmt>, caso esta classe
            possua um construtor <it>default</it> declarado como <stmt>public</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1265" objetivo="4.1">
		<introducao>A compilação do código abaixo não falha.<java><![CDATA[package misc;

class Teste implements java.lang.Runnable {

    public void run() {
    }

    public static void main(String[] args) {
        for (int i = 0; i < args.length; i++) {
            System.out.println(args[i]);
        }
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1266" objetivo="4.1">
		<introducao>A compilação do código abaixo não falha.<java><![CDATA[package misc;

class Teste implements Runnable {

    public void run() {
    }

    public static void main(String[] args) {
        for (int i = 0; i < args.length; i++) {
            System.out.println(args[i]);
        }
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1267" objetivo="4.1">
		<introducao>A compilação do código abaixo não falha.<java><![CDATA[package misc;

import java.lang.Runnable;

class Teste implements java.lang.Runnable {

    public void run() {
    }

    public static void main(String[] args) {
        for (int i = 0; i < args.length; i++) {
            System.out.println(args[i]);
        }
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1268" objetivo="4.1">
		<introducao>A compilação do código abaixo não falha.<java><![CDATA[package misc;

import java.lang.Runnable;

class Teste implements Runnable {

    public void run() {
    }

    public static void main(String[] args) {
        for (int i = 0; i < args.length; i++) {
            System.out.println(args[i]);
        }
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1269" objetivo="4.1">
		<introducao>A compilação do código abaixo não falha.<java><![CDATA[package misc;

import java.lang.Runnable;
import java.lang.*;

class Teste implements Runnable {

    public void run() {
    }

    public static void main(String[] args) {
        for (int i = 0; i < args.length; i++) {
            System.out.println(args[i]);
        }
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1270" objetivo="4.1">
		<introducao>Para fazer uso da classe <stmt>String</stmt>, embora
            não seja necessário, pode ser utilizada a declaração
                <stmt>import java.lang.String;</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1271" objetivo="4.1">
		<introducao>Para fazer uso da classe <stmt>String</stmt>, embora
            não seja necessário, pode ser utilizada a declaração
                <stmt>import java.lang.String.*;</stmt>.</introducao>
		<resposta valor="f">
			<stmt>String</stmt> é uma classe e não um <stmt>package</stmt>.</resposta>
	</questao>
	<questao id="1272" objetivo="4.1">
		<introducao>Para fazer uso da classe <stmt>String</stmt>, embora
            não seja necessário, pode ser utilizada a declaração
                <stmt>import java.lang;</stmt>.</introducao>
		<resposta valor="f">Observe que <stmt>lang</stmt> não é uma
            classe, mas um <stmt>package</stmt>.</resposta>
	</questao>
	<questao id="1273" objetivo="4.1">
		<introducao>Embora desnecessária, pode ser empregada a
            declaração <stmt>import</stmt> abaixo.<java><![CDATA[import java.lang;

class Teste {
    public static void main(String[] args) {
        for (int i = 0; i < args.length; i++) {
            System.out.println(args[i]);
        }
    }
}]]></java>
		</introducao>
		<resposta valor="f">Observe que <stmt>lang</stmt> é um
            <stmt>package</stmt> e não uma classe.</resposta>
	</questao>
	<questao id="1274" objetivo="4.1">
		<introducao>A declaração <stmt>import</stmt> deve ser
            acompanhada do nome de um <stmt>package</stmt> seguido do
            operador <stmt>.</stmt> e um <stmt>*</stmt> ou,
            opcionalmente, a classe ou interface de interesse deve ser
            explicitamente fornecida.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1275" objetivo="4.1">
		<introducao>Em uma declaração <stmt>import</stmt> deve ser
            fornecido uma classe ou interface ou todo o conjunto de
            classes e interfaces, em ambos os casos, de uma determinado <stmt>package</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1276" objetivo="4.1">
		<introducao>Se <stmt>brasil</stmt> é o nome de um
            <stmt>package</stmt>, então está errada a declaração
                <stmt>import brasil;</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1277" objetivo="4.1">
		<introducao>Se <stmt>brasil</stmt> é o nome de um
            <stmt>package</stmt>, então está errada a declaração
                <stmt>import brasil.*;</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1278" objetivo="4.1">
		<introducao>Se <stmt>brasil.go.ufg.Aluno</stmt> é o nome de uma
            classe, então a referência para um objeto desta classe pode
            ser declarada como <stmt>brasil.go.ufg.Aluno refAluno;</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1279" objetivo="4.1">
		<introducao>Se <stmt>brasil.go.ufg.Aluno</stmt> é o nome de uma
            classe, então a referência para um objeto desta classe pode
            ser declarada como <stmt>Aluno refAluno;</stmt> desde que a
            classe na qual esta sentença está inserida pertença ao mesmo
            <stmt>package</stmt> da classe <stmt>Aluno</stmt> ou faça
            uso da declaração <stmt>import brasil.go.ufg.*;</stmt> ou <stmt>brasil.go.ufg.Aluno;</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1280" objetivo="4.1">
		<introducao>Sabendo-se que nos <stmt>package</stmt>s
            <stmt>java.awt</stmt> e <stmt>java.util</stmt> existem a
            classe <stmt>List</stmt>. Um código que faz uso das
            declarações <stmt>import</stmt> para ambos os
            <stmt>package</stmt> não pode fazer uso de sentenças como
                <stmt>List l = new List();</stmt> pois o compilador,
            neste caso, não sabe a qual <stmt>List</stmt> a sentença se refere.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1281" objetivo="4.1">
		<introducao>O código abaixo, contido no arquivo
            <bd>main1.java</bd>, compila sem falhas.<java><![CDATA[package main;

class main {
    public static void main(String[] args) {
        System.out.println("class main");
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1282" objetivo="4.1">
		<introducao>A compilação do código abaixo, contido no arquivo
            <bd>main1.java</bd>, falha. Observe que o
            <stmt>package</stmt>, a classe e o método <stmt>main</stmt>
            compartilham o mesmo identificador.<java><![CDATA[package main;

class main {
    public static void main(String[] args) {
        System.out.println("class main");
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1283" objetivo="4.1">
		<introducao>A compilação do código abaixo falha.<java><![CDATA[public class main3 {
    static void main(String[] args) {
        System.out.println("Ok!");
    }
}]]></java>
		</introducao>
		<resposta valor="f">Observe, contudo, que a classe
            <stmt>main3</stmt> não pode ser fornecida à máquina virtual
            Java para a execução.</resposta>
	</questao>
	<questao id="1284" objetivo="4.1">
		<introducao>A execução da classe abaixo gera um
            <stmt>Error</stmt>, em particular, <stmt>NoSuchMethodError</stmt>.<java><![CDATA[public class main4 {
    static public void main(String $args[]) {
        System.out.println("Ok!");
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1285" objetivo="4.1">
		<introducao>O programa abaixo, quando executado, fica em
            execução indefinidamente.<java><![CDATA[public class main5 {
    public static void main(String[] args) {
        System.out.println("Ok");
        main(3);
    }

    public static void main(int $i) {
        System.out.println("main("+$i+")");
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1286" objetivo="4.1">
		<introducao>O programa abaixo, quando executado, exibe na tela a
            mensagem <stmt>Ok3</stmt>. <java><![CDATA[public class main5 {
    public static void main(String[] args) {
        System.out.print("Ok");
        main(3);
    }

    public static void main(int $i) {
        System.out.println(+$i);
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1287" objetivo="4.1">
		<introducao>A compilação do código abaixo falha.<java><![CDATA[public class main5 {
    public static void main(String[] args) {
        System.out.print("Ok");
        main(3);
    }

    public static void main(int $i) {
        System.out.println(+$i);
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1288" objetivo="4.1">
		<introducao>O código abaixo não compila.<java><![CDATA[public class main6 {
    static public void main(String []$i) {
       System.out.println("ok");
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1289" objetivo="4.1">
		<introducao>Quando fornecida à maquina virtual Java, a classe
            abaixo gera o erro <stmt>NoSuchMethodError</stmt>.<java><![CDATA[public class main6 {
    static public void main(String []$i) {
       System.out.println("ok");
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1290" objetivo="4.1">
		<introducao>Quando fornecida à maquina virtual Java, a classe
            abaixo gera o erro <stmt>NoSuchMethodError</stmt>.<java><![CDATA[public class main7 {
    public static void main(final String $s[]) {
        System.out.println("main7");
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1291" objetivo="4.1">
		<introducao>A classe abaixo compila e, quando fornecida à
            máquina virtual Java para execução, não gera nenhum erro ou exceção.<java><![CDATA[final public class main8 {
    static final public void main(final String $s[]) {
        System.out.println("main8");
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1292" objetivo="4.1">
		<introducao>O código abaixo, quando executado, exibe a mensagem
                <stmt>&quot;Nenhum argumento fornecido&quot;</stmt> caso
            nenhuma argumento tenha sido fornecido à aplicação ou a
            lista de argumentos, em caso contrário, um por linha.<java><![CDATA[public class main10 {
    public static void main(String[] args) {
        if (args == null) {
            System.out.println("Nenhum argumento fornecido");
        } else {
            for (int i = 0; i < args.length; i++) {
                System.out.println(i + ": " + args[i]);
            }
        }
    }
}]]></java>
		</introducao>
		<resposta valor="f">Observe que o método <stmt>main</stmt>
            jamais será chamado com a referência  <stmt>args</stmt>
            contendo o valor <stmt>null</stmt>. Quando argumentos não
            são fornecidos sabe-se pelo número de elementos fornecidos
            pelo <it>array</it>.</resposta>
	</questao>
	<questao id="1293" objetivo="4.1">
		<introducao>A compilação do código abaixo falha.<java><![CDATA[public class main11 {
    private static int n = -1;

    public static void main(String[] args) {
        if (n == -1) {
            n = args.length;
        }

        if (n == 0) {
            return;
        }

        n = n - 1;
        main(args);
        System.out.println(args[n]);
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1294" objetivo="4.1">
		<introducao>Quando executado, o código abaixo exibe todos os
            argumentos fornecidos na linha de comandos, um por linha, e
            na ordem em que foram fornecidos.<java><![CDATA[A compilação do código abaixo falha.<java><![CDATA[public class main11 {
    private static int n = -1;

    public static void main(String[] args) {
        if (n == -1) {
            n = args.length;
        }

        if (n == 0) {
            return;
        }

        n = n - 1;
        main(args);
        System.out.println(args[n]);
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1295" objetivo="4.1">
		<introducao>O código abaixo, quando executado, pode gerar a
            exceção <stmt>ArrayIndexOutOfBoundsException</stmt>.<java><![CDATA[public class main12 {
    public static void main(String[] args) {
        System.out.println(args[0]);
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1296" objetivo="4.1">
		<introducao>Quando se executa o comando <bd>java
            MinhaClasse</bd>, a máquina virtual Java procura pelo método
            <stmt>main</stmt> nesta classe, conforme a assinatura
            esperada, ou seja, uma método de nome <stmt>main</stmt> que
            retorna <stmt>void</stmt> e é declarado <stmt>static</stmt>
            e <stmt>public</stmt>, além de receber como argumento um
            <it>array</it> de elementos do tipo <stmt>String</stmt>.
            Caso não encontre, o erro <stmt>NoSuchMethodError</stmt> é gerado.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1297" objetivo="4.2">
		<introducao>
			<stmt>java.lang.Runnable</stmt> é uma classe.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1298" objetivo="4.2">
		<introducao>
			<stmt>java.lang.Runnable</stmt> é uma interface.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1299" objetivo="4.2">
		<introducao>O código abaixo compila.<java><![CDATA[package run;

public abstract class C1 extends java.lang.Runnable {}]]></java>
		</introducao>
		<resposta valor="f">
			<stmt>Runnable</stmt> é uma interface. Portanto, só pode ser
            estendida por outra interface.</resposta>
	</questao>
	<questao id="1300" objetivo="4.2">
		<introducao>O código abaixo compila.<java><![CDATA[package run;

public class C1 implements java.lang.Runnable {}]]></java>
		</introducao>
		<resposta valor="f">
			<stmt>C1</stmt> não implementa o método <stmt>public void
            run()</stmt> e nem é declarada <stmt>abstract</stmt>.</resposta>
	</questao>
	<questao id="1301" objetivo="4.2">
		<introducao>O código abaixo compila.<java><![CDATA[package run;

public abstract class C1 implements java.lang.Runnable {}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1302" objetivo="4.2">
		<introducao>A classe abaixo implementa a interface <stmt>Runnable</stmt>.<java><![CDATA[public class C1 {
    public void run() {}
}]]></java>
		</introducao>
		<resposta valor="f">Apenas contém o método <stmt>run</stmt>,
            que é suficiente para implementar a interface, mas observe
            que a declaração da classe não a trata como uma
            implementação de qualquer que seja a interface.</resposta>
	</questao>
	<questao id="1303" objetivo="4.2">
		<introducao>Para que uma classe implemente a interface
            <stmt>Runnable</stmt> é necessário que esta classe
            implemente o único método desta interface: <stmt>public void run()</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1304" objetivo="4.2">
		<introducao>A interface <stmt>Runnable</stmt> é declarada no <stmt>package</stmt>
			<stmt>java.util</stmt>.</introducao>
		<resposta valor="f">
			<stmt>Runnable</stmt> é declarada em <stmt>java.lang</stmt>.</resposta>
	</questao>
	<questao id="1305" objetivo="4.2">
		<introducao>
			<stmt>Runnable</stmt> é declarada em <stmt>java.lang</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1306" objetivo="4.2">
		<introducao>A classe abaixo implementa a interface <stmt>Runnable</stmt>.<java><![CDATA[public class C1 implements Runnable {
    public void run() {}
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1307" objetivo="4.2">
		<introducao>O código abaixo compila satisfatoriamente.<java><![CDATA[import java.util.Runnable;

public class C1 implements Runnable {
    public void run() {}
}]]></java>
		</introducao>
		<resposta valor="f">O correto é <stmt>java.lang.Runnable</stmt>.</resposta>
	</questao>
	<questao id="1308" objetivo="4.2">
		<introducao>O código abaixo compila satisfatoriamente.<java><![CDATA[public class C1 implements java.util.Runnable {
    public void run() {}
}]]></java>
		</introducao>
		<resposta valor="f">O correto é <stmt>java.lang.Runnable</stmt>.</resposta>
	</questao>
	<questao id="1309" objetivo="4.2">
		<introducao>A classe abaixo compila satisfatoriamente.<java><![CDATA[public class C1 implements Runnable {
    public void run(int i) {
        System.out.println("i: " + i);
    }
}]]></java>
		</introducao>
		<resposta valor="f">Observe que <stmt>C1</stmt> não
            implementa o método <stmt>public void run()</stmt> da
            interface <stmt>Runnable</stmt>.</resposta>
	</questao>
	<questao id="1310" objetivo="4.2">
		<introducao>A classe abaixo compila satisfatoriamente.<java><![CDATA[public class C1 implements java.lang.Runnable {
    public void run(int i) {
        System.out.println("i: " + i);
    }
}]]></java>
		</introducao>
		<resposta valor="f">Observe que <stmt>C1</stmt> não
            implementa o método <stmt>public void run()</stmt> da
            interface <stmt>Runnable</stmt>.</resposta>
	</questao>
	<questao id="1311" objetivo="4.2">
		<introducao>A classe abaixo compila satisfatoriamente.<java><![CDATA[public class C1 implements java.lang.Runable {
    public void run() {}
}]]></java>
		</introducao>
		<resposta valor="f">Observe que não existe a interface
            <stmt>java.lang.Runable</stmt>, mas <stmt>java.lang.Runnable</stmt>.</resposta>
	</questao>
	<questao id="1312" objetivo="4.2">
		<introducao>A compilação do código abaixo falha.<java><![CDATA[interface Runnable {
    public void run();
}

public class C1 implements java.lang.Runnable {
    public void run() {}
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1313" objetivo="4.2">
		<introducao>A compilação do código abaixo falha.<java><![CDATA[interface Runnable {
    public void run() {}
}

public class C1 implements java.lang.Runnable {
    public void run() {}
}]]></java>
		</introducao>
		<resposta valor="v">Todo método declarado em uma
            interface é <stmt>abstract</stmt> e, portanto, não possui
            corpo. Imediatamente após o parênteses deve seguir o ponto-e-vírgula.</resposta>
	</questao>
	<questao id="1314" objetivo="4.2">
		<introducao>A compilação do código abaixo falha.<java><![CDATA[interface Documento {
    int idDoc = 1;
    
    abstract public String título();
    public abstract String id() {
        return idDoc;
    }
}]]></java>
		</introducao>
		<resposta valor="v">Interface não implementa método.</resposta>
	</questao>
	<questao id="1315" objetivo="4.2">
		<introducao>A compilação do código abaixo falha.<java><![CDATA[interface Documento {
    int idDoc = 1;
    
    abstract public String título();
    public abstract String id() {}
    }
}]]></java>
		</introducao>
		<resposta valor="v">Interface só possui método <stmt>abstract</stmt>.</resposta>
	</questao>
	<questao id="1316" objetivo="4.2">
		<introducao>Uma interface pode possuir apenas métodos <stmt>abstract</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1317" objetivo="4.2">
		<introducao>Uma classe pode possuir ou não métodos declarados <stmt>abstract</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1318" objetivo="4.2">
		<introducao>Uma classe que não é declarada <stmt>abstract</stmt>
            e implementa a interface <stmt>Runnable</stmt>
            necessariamente implementa o método <stmt>public void run()</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1319" objetivo="4.2">
		<introducao>Todos os métodos de uma interface são <stmt>public</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1320" objetivo="4.2">
		<introducao>Os métodos de uma classe podem ser declarados
            <stmt>public</stmt>, <stmt>protected</stmt> ou <stmt>private</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1321" objetivo="4.2">
		<introducao>Método de uma interface <stmt>A</stmt> declarado
            <stmt>protected</stmt> só é visível em uma interface que
            implementa (<stmt>implements</stmt>) a interface <stmt>A</stmt>.</introducao>
		<resposta valor="f">Todos os métodos de uma interface são
            <stmt>public</stmt> e interface não implementa outra interface.</resposta>
	</questao>
	<questao id="1322" objetivo="4.2">
		<introducao>Método de uma interface <stmt>A</stmt> declarado
            <stmt>protected</stmt> só é visível em uma interface que
            estende (<stmt>extends</stmt>) a interface <stmt>A</stmt>.</introducao>
		<resposta valor="f">Todo método de interface é <stmt>public</stmt>.</resposta>
	</questao>
	<questao id="1323" objetivo="4.2">
		<introducao>Mesmo que não sejam declarados, todos os métodos de
            uma interface são, ao mesmo tempo, <stmt>public</stmt> e <stmt>abstract</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1324" objetivo="4.2">
		<introducao>Método de uma interface não pode ser <stmt>static</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1325" objetivo="4.2">
		<introducao>A interface abaixo é inválida.<java><![CDATA[interface Identificador {
    public abstract int getValidade();

    final public int id();
}]]></java>
		</introducao>
		<resposta valor="v">Método de interface não pode ser <stmt>final</stmt>.</resposta>
	</questao>
	<questao id="1326" objetivo="4.2">
		<introducao>A interface abaixo é inválida.<java><![CDATA[interface Identificador {
    public abstract int getValidade();

    public static int id();
}]]></java>
		</introducao>
		<resposta valor="v">Método de interface não pode ser <stmt>static</stmt>.</resposta>
	</questao>
	<questao id="1327" objetivo="4.2">
		<introducao>Uma classe que implemente a interface
            <stmt>java.lang.Runnable</stmt> deve implementar o método
                <stmt>public static void main(String[])</stmt>.</introducao>
		<resposta valor="f">O método é <stmt>public void run()</stmt>.</resposta>
	</questao>
	<questao id="1328" objetivo="4.2">
		<introducao>Mesmo que não sejam explicitamente declarados com os
            modificadores <stmt>public</stmt> e <stmt>abstract</stmt>,
            todo método de uma interface sempre é <stmt>public</stmt> e <stmt>abstract</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1329" objetivo="4.2">
		<introducao>Todas as variáveis definidas em uma interface devem
            ser <stmt>public</stmt>, <stmt>static</stmt> e <stmt>final</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1330" objetivo="4.2">
		<introducao>A declaração <stmt>final int Zero = 0;</stmt>
            extraída de uma interface, permite-nos concluir que
            <stmt>X</stmt> também é <stmt>public</stmt> e <stmt>static</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1331" objetivo="4.2">
		<introducao>A declaração <stmt>int Zero = 0;</stmt> extraída de
            uma interface, permite-nos concluir que <stmt>X</stmt>
            também é <stmt>public</stmt>, <stmt>final</stmt> e <stmt>static</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1332" objetivo="4.2">
		<introducao>Todas as variáveis declaradas em uma interface são constantes.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1333" objetivo="4.2">
		<introducao>A declaração de uma variável em uma interface deve
            incluir um valor inicial que jamais será mudado.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1334" objetivo="4.2">
		<introducao>O método de uma interface pode ser declarado <stmt>final</stmt>.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1335" objetivo="4.2">
		<introducao>O método de uma interface pode ser declarado <stmt>native</stmt>.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1336" objetivo="4.2">
		<introducao>O método de uma interface pode ser declarado <stmt>synchronized</stmt>.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1337" objetivo="4.2">
		<introducao>O método de uma interface pode ser declarado <stmt>strictfp</stmt>.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1338" objetivo="4.2">
		<introducao>O método de uma interface pode ser declarado <stmt>private</stmt>.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1339" objetivo="4.2">
		<introducao>Uma interface pode estender zero ou mais interfaces.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1340" objetivo="4.2">
		<introducao>Embora sem utilidade, o código abaixo compila satisfatoriamente.<java><![CDATA[interface Identificador {
}

interface Documento extends Identificador {
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1341" objetivo="4.2">
		<introducao>Embora sem utilidade, o código abaixo compila satisfatoriamente.<java><![CDATA[interface Identificador {}
interface IDEstendido {}
interface Documento extends Identificador, IDEstendido {}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1342" objetivo="4.2">
		<introducao>Embora sem utilidade, o código abaixo compila satisfatoriamente.<java><![CDATA[interface IA {}
interface IB {}
interface C extends IA, IB {}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1343" objetivo="4.2">
		<introducao>Embora sem utilidade, o código abaixo compila satisfatoriamente.<java><![CDATA[interface IA {}
interface IB {}
interface C implements IA, IB {}]]></java>
		</introducao>
		<resposta valor="f">Uma interface pode estender, mas não
            pode implementar outra interface.</resposta>
	</questao>
	<questao id="1344" objetivo="4.2">
		<introducao>Embora sem utilidade, o código abaixo compila satisfatoriamente.<java><![CDATA[interface IA {}
interface IB {}
class C implements IA, IB {}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1345" objetivo="4.2">
		<introducao>Embora sem utilidade, o código abaixo compila satisfatoriamente.<java><![CDATA[interface IA {}
interface IB {}
class C extends IA implements IB {}]]></java>
		</introducao>
		<resposta valor="f">Classe estende apenas classes.</resposta>
	</questao>
	<questao id="1346" objetivo="4.2">
		<introducao>O código abaixo compila satisfatoriamente.<java><![CDATA[interface IA {}
interface IB {}
class C implements IA {}
interface IC extends IA, IB {}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1347" objetivo="4.2">
		<introducao>O código abaixo compila satisfatoriamente.<java><![CDATA[interface IA {}
interface IB {}
class C implements IA, IB {}
interface IC extends IA, IB {}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1348" objetivo="4.2">
		<introducao>O código abaixo compila satisfatoriamente.<java><![CDATA[interface IA {}
interface IB {}
class C implements IA {}
interface IC extends IA, IB, C {}]]></java>
		</introducao>
		<resposta valor="f">Interface estende apenas interfaces.</resposta>
	</questao>
	<questao id="1349" objetivo="4.2">
		<introducao>Uma interface não pode estender
            (<stmt>extends</stmt>) duas ou mais interfaces.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1350" objetivo="4.2">
		<introducao>Uma classe <stmt>C</stmt> pode ser herdada por uma
            interface <stmt>I</stmt>. Ou seja, <stmt>I extends C</stmt>.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1351" objetivo="4.2">
		<introducao>Uma interface é declarada pela palavra reservada <stmt>interface</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1352" objetivo="4.2">
		<introducao>Uma interface pode implementar uma classe.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1353" objetivo="4.2">
		<introducao>Uma interface não pode implementar duas ou mais classes.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1354" objetivo="4.2">
		<introducao>Uma interface não pode implementar duas ou mais interfaces.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1355" objetivo="4.2">
		<introducao>A declaração <stmt>public abstract interface
                AparelhoEletrico {}</stmt> é válida.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1356" objetivo="4.2">
		<introducao>O emprego da palavra reservada <stmt>abstract</stmt>
            na declaração de uma interface pode ser considerado redundante.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1357" objetivo="4.2">
		<introducao>É desnecessário fornecer a palavra reservada
            <stmt>abstract</stmt> quando se declara uma interface.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1358" objetivo="4.2">
		<introducao>As declarações <stmt>interface Pasta {}</stmt> e
                <stmt>public abstract interface Pasta {}</stmt> são equivalentes.</introducao>
		<resposta valor="f">O modificador <stmt>public</stmt> não é
            implícito na declaração de uma interface, ao contrário de <stmt>abstract</stmt>.</resposta>
	</questao>
	<questao id="1359" objetivo="4.2">
		<introducao>As declarações <stmt>interface Pasta {}</stmt> e
                <stmt>abstract interface Pasta {}</stmt> são equivalentes.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1360" objetivo="4.2">
		<introducao>As declarações <stmt>interface Pasta {}</stmt> e
                <stmt>abstract Pasta {}</stmt> são equivalentes.</introducao>
		<resposta valor="f">Observe que falta a palavra reservada <stmt>interface</stmt>.</resposta>
	</questao>
	<questao id="1361" objetivo="4.2">
		<introducao>É opcional a declaração empregando
            <stmt>public</stmt> e <stmt>abstract</stmt> tanto para os
            métodos de uma interface quanto para a declaração de interfaces.</introducao>
		<resposta valor="f">É verdade apenas para os métodos.</resposta>
	</questao>
	<questao id="1362" objetivo="4.2">
		<introducao>Ao contrário de uma classe que possui métodos
            declarados <stmt>abstract</stmt>, é permitido declarar uma
            interface sem a palavra reservada <stmt>abstract</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1363" objetivo="4.2">
		<introducao>As declarações <stmt>public int get()</stmt>,
                <stmt>int get()</stmt>, <stmt>abstract int get()</stmt>,
                <stmt>public abstract int get()</stmt> e <stmt>abstract
                public int get()</stmt> são todas equivalentes quando
            consideradas métodos de uma interface.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1364" objetivo="4.2">
		<introducao>A interface abaixo compila sem falha.<java><![CDATA[interface Lógica {
    boolean VERDADEIRO = true;
    boolean FALSO = false;
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1365" objetivo="4.2">
		<introducao>A interface abaixo compila sem falha.<java><![CDATA[interface Lógica {
    boolean VERDADEIRO = true;
    public static final boolean FALSO = false;
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1366" objetivo="4.2">
		<introducao>A interface abaixo define uma variável
            <stmt>public</stmt> e outra visível apenas no pacote em questão.<java><![CDATA[interface Lógica {
    boolean VERDADEIRO = true;
    public static final boolean FALSO = false;
}]]></java>
		</introducao>
		<resposta valor="f">Ambas são <stmt>public</stmt>.</resposta>
	</questao>
	<questao id="1367" objetivo="4.2">
		<introducao>Se a sentença <stmt>boolean VERDADEIRO =
            true;</stmt> é uma declaração no interior de uma interface,
            então pode-se dizer que <stmt>VERDADEIRO</stmt> também é
            <stmt>final</stmt>, <stmt>public</stmt> e <stmt>static</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1368" objetivo="4.2">
		<introducao>O código abaixo não compila. Observe que há uma
            tentativa de se fazer uso de uma variável não estática por
            meio de um método <stmt>static</stmt>.<java><![CDATA[interface Lógica {
    boolean VERDADEIRO = true;
    boolean FALSO = false;
}

class C implements Lógica {
    public static void main(String[] args) {
        System.out.println(VERDADEIRO);
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1369" objetivo="4.2">
		<introducao>Em uma interface, as seguintes declarações são
            equivalentes: <stmt>int x = 0;</stmt>, <stmt>public int x =
            0;</stmt>, <stmt>static int x = 0;</stmt>, <stmt>final int x
                = 0;</stmt>, <stmt>public static int x = 0;</stmt>,
                <stmt>static public int x = 0;</stmt>, <stmt>static
                final int x = 0;</stmt>, <stmt>final static int x =
            0;</stmt>, <stmt>public static final int x = 0;</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1370" objetivo="4.2">
		<introducao>A compilação do código abaixo falha.<java><![CDATA[interface Lógica {
    boolean VERDADEIRO = true;
    boolean FALSO = false;
}

class C implement Lógica {
    public static void main(String[] args) {
        System.out.println(VERDADEIRO);
    }
}]]></java>
		</introducao>
		<resposta valor="v">O correto é
            <stmt>implements</stmt>, com a letra <stmt>s</stmt>.</resposta>
	</questao>
	<questao id="1371" objetivo="4.2">
		<introducao>A compilação do código abaixo falha.<java><![CDATA[interface Lógica {
    boolean VERDADEIRO = true;
    boolean FALSO = false;
}

class C extends Lógica {
    public static void main(String[] args) {
        System.out.println(VERDADEIRO);
    }
}]]></java>
		</introducao>
		<resposta valor="v">O correto é <stmt>implements</stmt>
            e não <stmt>extends</stmt>.</resposta>
	</questao>
	<questao id="1372" objetivo="4.2">
		<introducao>O código abaixo não compila.<java><![CDATA[interface Lógica {
    boolean VERDADEIRO = true;
    boolean FALSO = false;
}

class C implements Lógica {
    boolean VERDADEIRO = Lógica.VERDADEIRO;
    public static void main(String[] args) {
        System.out.println(VERDADEIRO);
    }
}]]></java>
		</introducao>
		<resposta valor="v">Observe que a função
            <stmt>main</stmt> é <stmt>static</stmt> e tenta fazer uso da
            variável de instância <stmt>VERDADEIRO</stmt>.</resposta>
	</questao>
	<questao id="1373" objetivo="4.2">
		<introducao>Uma classe pode estender no máximo uma classe</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1374" objetivo="4.2">
		<introducao>A compilação do código abaixo não falha.<java><![CDATA[interface A {}
interface B {}
interface C {}
class D implements A, B, C {}]]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1375" objetivo="4.2">
		<introducao>Pode-se dizer que a classificação (hierarquia)
            define o quê é uma classe, enquanto a implementação de uma
            interface diz qual o papel esta classe pode desempenhar.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1376" objetivo="4.2">
		<introducao>O código abaixo compila.<java><![CDATA[interface A implements C {}
interface B implements A {}
interface C implements B {}]]></java>
		</introducao>
		<resposta valor="f">Interface não implementa absolutamente nada.</resposta>
	</questao>
	<questao id="1377" objetivo="4.2">
		<introducao>O código abaixo compila satisfatoriamente.<java><![CDATA[interface A extends C {}
interface B {}
interface C extends B {}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1378" objetivo="4.2">
		<introducao>Uma classe não pode estender mais do que outra
            classe em Java.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1379" objetivo="4.2">
		<introducao>A sentença <stmt>class C extends A, B implements D
            {}</stmt> é válida caso <stmt>A</stmt> e <stmt>B</stmt> não
            formem uma dependência cíclica juntamente com <stmt>C</stmt>
            e, ao mesmo tempo, <stmt>D</stmt> seja uma interface.</introducao>
		<resposta valor="f">Uma classe estende no máximo uma classe.</resposta>
	</questao>
	<questao id="1380" objetivo="4.2">
		<introducao>A compilação do código abaixo falha.<java><![CDATA[interface A extends B {
    void A();
}

interface B extends C {
    void B();
}

interface C {
    void C();
}

class S implements A, B, C {
    public void A() {}
    public void B() {}
    public void C() {}
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1381" objetivo="4.2">
		<introducao>A compilação do código abaixo falha.<java><![CDATA[interface A extends B {
    void A();
}

interface B extends C {
    void B();
}

interface C {
    void C();
}

class S implements A, B {
    public void A() {}
    public void B() {}
}]]></java>
		</introducao>
		<resposta valor="v">Falta a implementação do método
                <stmt>void C()</stmt>.</resposta>
	</questao>
	<questao id="1382" objetivo="4.2">
		<introducao>A compilação do código abaixo falha.<java><![CDATA[interface A extends B {
    void A();
}

interface B extends C {
    void B();
}

interface C {
    void C();
}

abstract class S implements A, B, C {
    public void A() {}
    public void B() {}
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1383" objetivo="4.2">
		<introducao>A compilação do código abaixo falha.<java><![CDATA[interface A extends B {
    void A();
}

interface B extends C {
    void B();
}

interface C {
    void C();
}

class S implements A {
    public void A() {}
}]]></java>
		</introducao>
		<resposta valor="v">Falta a implementação dos métodos
            <stmt>B()</stmt> e <stmt>C()</stmt>.</resposta>
	</questao>
	<questao id="1384" objetivo="4.2">
		<introducao>O método de uma interface não precisa,
            necessariamente, ser explicitamente declarado
            <stmt>abstract</stmt>, ao contrário de um método
            <stmt>abstract</stmt> de uma classe.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1385" objetivo="4.2">
		<introducao>O código abaixo compila satisfatoriamente.<java><![CDATA[interface A {
    void A();
}

abstract class S implements A {
    public void A() {}
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1386" objetivo="4.2">
		<introducao>A compilação do código abaixo falha.<java><![CDATA[interface A {
    void A();
}

class SubS implements A {
   void A() {}
}]]></java>
		</introducao>
		<resposta valor="v">O método da classe
            <stmt>SubS</stmt> tem mais restrição de acesso do que o
            método da interface <stmt>A</stmt>.</resposta>
	</questao>
	<questao id="1387" objetivo="4.2">
		<introducao>A compilação do código abaixo falha.<java><![CDATA[interface A {
    void A();
}

class SubS implements A {
   protected void A() {}
}]]></java>
		</introducao>
		<resposta valor="v">O método da classe
            <stmt>SubS</stmt> tem mais restrição de acesso do que o
            método da interface <stmt>A</stmt>.</resposta>
	</questao>
	<questao id="1388" objetivo="4.2">
		<introducao>A compilação do código abaixo falha.<java><![CDATA[interface A {
    void A();
}

class SubS implements A {
   private void A() {}
}]]></java>
		</introducao>
		<resposta valor="v">O método da classe
            <stmt>SubS</stmt> tem mais restrição de acesso do que o
            método da interface <stmt>A</stmt>.</resposta>
	</questao>
	<questao id="1389" objetivo="4.2">
		<introducao>Os métodos de uma interface que é implementada por
            uma classe são declarados explicitamente <stmt>public</stmt>
            quando da definição da classe.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1390" objetivo="5.1">
		<introducao>Operadores permitem obter novos valores de um ou
            mais operandos.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1391" objetivo="5.1">
		<introducao>Operadores em Java podem ser sobrecarregados (<it>overloaded</it>).</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1392" objetivo="5.1">
		<introducao>Operadores em Java não podem ser sobrecarregados (<it>overloaded</it>).</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1393" objetivo="5.1">
		<introducao>Não há sobrecarga (<it>overload</it>) de nenhum
            operador de Java conforme a linguagem foi definida.</introducao>
		<resposta valor="f">Observe que o operador <stmt>+</stmt>
            pode ser empregado para concatenar objetos da classe <stmt>String</stmt>.</resposta>
	</questao>
	<questao id="1394" objetivo="5.1">
		<introducao>O operador <stmt>+</stmt> pode ser empregado para
            concatenar objetos da classe <stmt>String</stmt> e para a
            operação regular de soma aritmética. Este é um exemplo de
            sobrecarga (<it>overload</it>) de operador em Java.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1395" objetivo="5.1">
		<introducao>Se <stmt>x</stmt> é uma variável do tipo primitivo
            <stmt>int</stmt>, então a sentença <stmt>x=6;</stmt> é uma
            atribuição válida em Java.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1396" objetivo="5.1">
		<introducao>Variáveis são repositórios de bits.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1397" objetivo="5.1">
		<introducao>Uma variável do tipo <stmt>double</stmt> é um
            repositório de 64 bits que descreve um valor deste tipo
            conforme o padrão IEEE 754.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1398" objetivo="5.1">
		<introducao>Para as variáveis cujo tipo é primitivo, o conjunto
            de bits representa um valor numérico. Exceto para as
            variáveis do tipo <stmt>boolean</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1399" objetivo="5.1">
		<introducao>Uma variável do tipo <stmt>byte</stmt> que, em
            determinado instante retém o valor decimal 10, armazena um
            conjunto de 8 bits cuja seqüência neste momento é <bd>00001010</bd>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1400" objetivo="5.1">
		<introducao>Uma variável do tipo referência armazena em seus
            bits o objeto correspondente.</introducao>
		<resposta valor="f">Armazena apenas uma <it>referência</it>
            para o objeto.</resposta>
	</questao>
	<questao id="1401" objetivo="5.1">
		<introducao>Uma variável do tipo referência armazena em seus
            bits um valor que permite acesso ao objeto correspondente.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1402" objetivo="5.1">
		<introducao>O padrão de bits correspondente a uma variável de
            referência é um formato dependente da implementação da
            máquina virtual Java.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1403" objetivo="5.1">
		<introducao>Necessariamente uma variável de referência é uma
            variável de 32 bits que designa um endereço na memória onde
            o objeto correspondente pode ser encontrado.</introducao>
		<resposta valor="f">O formato de uma variável de referência
            é dependente da implementação da máquina virtual Java corresondente.</resposta>
	</questao>
	<questao id="1404" objetivo="5.1">
		<introducao>O valor de uma variável de referência não é o objeto correspondente.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1405" objetivo="5.1">
		<introducao>O valor de uma variável de referência representa um
            objeto no <it>heap</it> ou o valor <stmt>null</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1406" objetivo="5.1">
		<introducao>A sentença <stmt>File f = null;</stmt> significa que
            a variável <stmt>f</stmt> não está se referindo a nenhum
            objeto imediatamente após a execução desta sentença.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1407" objetivo="5.1">
		<introducao>As sentenças <stmt>FIle f = null;</stmt> e
                <stmt>File f = (null)0;</stmt> são equivalentes.</introducao>
		<resposta valor="f">A segunda sentença não compila.</resposta>
	</questao>
	<questao id="1408" objetivo="5.1">
		<introducao>O código abaixo não compila.<java><![CDATA[public class Assign {
    String s1 = null;
    String s2 = (null)0;
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1409" objetivo="5.1">
		<introducao>Em Java, o sinal de igualdade da matemática é
            empregado como operador de atribuição (<it>assignment</it>).</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1410" objetivo="5.1">
		<introducao>Em Java, o operador de igualdade é <stmt>=</stmt>.</introducao>
		<resposta valor="f">Este é o operador de atribuição.</resposta>
	</questao>
	<questao id="1411" objetivo="5.1">
		<introducao>Uma atribuição em Java emprega o operador <stmt>=</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1412" objetivo="5.1">
		<introducao>Há vários operadores de atribuição compostos. Por
            exemplo, <stmt><![CDATA[>>>=]]></stmt> e <stmt><![CDATA[&=]]></stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1413" objetivo="5.1">
		<introducao>Pode-se atribuir um valor a uma variável de tipo
            primitivo usando uma literal ou uma expressão. Por exemplo,
                <stmt>int k = 9 + x;</stmt> declara a variável do tipo
            <stmt>int</stmt> e a inicia com uma expressão que envolve o
            emprego de uma literal.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1414" objetivo="5.1">
		<introducao>Na sentença <stmt>byte b = 8;</stmt> a literal
            <stmt>8</stmt> é do tipo <stmt>int</stmt>. Contudo, a
            atribuição não provoca um erro, embora esteja sendo
            depositado em uma variável de apenas 8 bits. Neste caso, o
            compilador automaticamente realiza a conversão do tipo
            <stmt>int</stmt> para o tipo <stmt>byte</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1415" objetivo="5.1">
		<introducao>As sentenças <stmt>char c = 5;</stmt> e <stmt>char c
                = (char)5;</stmt> são equivalentes.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1416" objetivo="5.1">
		<introducao>As sentenças <stmt>short s = 5;</stmt> e <stmt>short
                s = (short)5;</stmt> são equivalentes.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1417" objetivo="5.1">
		<introducao>As sentenças <stmt>byte b = 5;</stmt> e <stmt>byte b
                = (byte)5;</stmt> são equivalentes.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1418" objetivo="5.1">
		<introducao>O resultado de uma expressão envolvendo uma variável
            ou literal do tamanho de um <stmt>int</stmt> ou menor que
            resulta em uma expressão do tipo <stmt>int</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1419" objetivo="5.1">
		<introducao>Ao se adicionar duas variáveis do tipo
            <stmt>byte</stmt> a expressão resultante é do tipo <stmt>byte</stmt>.</introducao>
		<resposta valor="f">O tipo resultante é <stmt>int</stmt>.</resposta>
	</questao>
	<questao id="1420" objetivo="5.1">
		<introducao>Se as variáveis <stmt>a</stmt> e <stmt>b</stmt> são
            do tipo <stmt>byte</stmt>, então <stmt>a+b</stmt> é do tipo <stmt>int</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1421" objetivo="5.1">
		<introducao>Se as variáveis <stmt>a</stmt> e <stmt>b</stmt> são
            do tipo <stmt>short</stmt>, então <stmt>a+b</stmt> é do tipo <stmt>int</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1422" objetivo="5.1">
		<introducao>Se as variáveis <stmt>a</stmt> e <stmt>b</stmt> são
            do tipo <stmt>char</stmt>, então <stmt>a+b</stmt> é do tipo <stmt>int</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1423" objetivo="5.1">
		<introducao>O código abaixo não compila.<java><![CDATA[public class Assign {
    char c1 = 5;
    char c2 = 5;
    char c3 = c1 + c2;
}]]></java>
		</introducao>
		<resposta valor="v">A expressão <stmt>c1+c2</stmt> é do
            tipo <stmt>int</stmt> e exige <it>casting</it> explícito
            para que a atribuição seja considerada válida.</resposta>
	</questao>
	<questao id="1424" objetivo="5.1">
		<introducao>No código abaixo, <stmt>5+4</stmt> é uma expressão
            do tipo <stmt>int</stmt> que é corretamente atribuída a uma
            variável do tipo <stmt>char</stmt>. A expressão
            <stmt>5+c1</stmt> também é uma expressão do tipo
            <stmt>int</stmt>, contudo, a atribuição à variável
            <stmt>c2</stmt> falha em tempo de compilação.  Deve existir
            um <it>casting</it> explícito desta expressão ou o tipo de
            <stmt>c2</stmt> deve ser alterado para <stmt>int</stmt>,
            como na terceira atribuição, que é válida.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1425" objetivo="5.1">
		<introducao>Se você multiplicar uma variável do tipo
            <stmt>short</stmt> por uma variável do tipo
            <stmt>byte</stmt> a expressão resultante é do tipo <stmt>int</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1426" objetivo="5.1">
		<introducao>Em uma expressão que divide uma variável do tipo
            <stmt>short</stmt> por uma do tipo <stmt>byte</stmt> o tipo
            resultante é <stmt>int</stmt> e, portanto, só pode ser
            atribuído a uma variável do tipo <stmt>int</stmt>,
            <stmt>float</stmt> ou <stmt>double</stmt> sem a existência
            de um <it>casting</it> explícito.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1427" objetivo="5.1">
		<introducao>O código abaixo não compila, pois a expressão do
            tipo <stmt>int</stmt> que não é uma constante é atribuída a
            uma variável do tipo <stmt>char</stmt>.<java><![CDATA[public class Assign {
    char c1 = 5 + 4;
    char c2 = 0 + c1;
}]]></java>
		</introducao>
		<resposta valor="f">A expressão é uma constante, uma literal
            do tipo <stmt>int</stmt> e, portanto, pode ser atribuída a
            uma variável do tipo <stmt>char</stmt> sem o
            <it>casting</it> explícito. A conversão é automaticamente
            realizada pelo compilador.</resposta>
	</questao>
	<questao id="1428" objetivo="5.1">
		<introducao>O código abaixo não compila. Observe que há uma
            tentativa de se atribuir à variável <stmt>s</stmt> do tipo
            <stmt>short</stmt> uma expressão do tipo <stmt>int</stmt>.<java><![CDATA[public class Assign {
    char c1 = 5 + 4;
    char c2 = 3;
    short s = c1 + c2;
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1429" objetivo="5.1">
		<introducao>A sentença <stmt>byte b = 34;</stmt> compila
            corretamente, mesmo o valor <stmt>34</stmt> correspondente a
            um <stmt>int</stmt>. Implicitamente o compilador realiza a
            conversão sem perda de precisão.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1430" objetivo="5.1">
		<introducao>A sentença <stmt>byte b = 340;</stmt> não compila
            corretamente. O valor <stmt>340</stmt> não pode ser
            depositado em uma variável do tipo <stmt>byte</stmt> sem
            perda de precisão e, desta forma, o compilador não realiza
            uma conversão automática. Para que haja uma atribuição como
            esta será necessário que seja explicitamente fornecido o
            <it>casting</it> como em <stmt>byte b = (byte)340;</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1431" objetivo="5.1">
		<introducao>O código abaixo compila satisfatoriamente.<java><![CDATA[public class Assign {
    byte c1 = (byte)340;
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1432" objetivo="5.1">
		<introducao>O código abaixo compila satisfatoriamente.<java><![CDATA[public class Assign {
    short s = (byte)340;
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1433" objetivo="5.1">
		<introducao>O valor exibido pela execução do código abaixo é <stmt>340</stmt>.<java><![CDATA[public class Assign {
    static short s1 = (byte)340;

    public static void main(String[] args) {
        System.out.println(s1);
    }
}]]></java>
		</introducao>
		<resposta valor="f">O valor <stmt>340</stmt> primeiro é
            convertido para o tipo <stmt>byte</stmt>, de apenas 8 bits
            (conversão com perda de precisão). O resultado desta
            conversão é que é depositado na variável do tipo <stmt>short</stmt>.</resposta>
	</questao>
	<questao id="1434" objetivo="5.1">
		<introducao>O código abaixo compila satisfatoriamente.<java><![CDATA[public class Assign {
    static byte b = 340 - 300;
}]]></java>
		</introducao>
		<resposta valor="v">Observe que <stmt>340-300</stmt>
            resulta na constante <stmt>30</stmt> que é uma literal do
            tipo <stmt>int</stmt> e, portanto, convertida
            automaticamente pelo compilador para o tipo
            <stmt>byte</stmt>, pois não há perda de precisão.</resposta>
	</questao>
	<questao id="1435" objetivo="5.1">
		<introducao>Ao se atribuir uma constante do tipo
            <stmt>int</stmt> a uma variável do tipo <stmt>short</stmt>,
            <stmt>byte</stmt> ou <stmt>char</stmt>, a atribuição não
            provoca erro em tempo de compilação caso o valor resultante
            seja possível de ser armazenado na variável em questão,
            mesmo que não tenha sido explicitamente fornecido o
            <it>casting</it> correspondente.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1436" objetivo="5.1">
		<introducao>Se uma constante do tipo <stmt>int</stmt> não for
            possível de ser armazenada em uma variável do tipo
            <stmt>short</stmt>, por exemplo, então só será permitida
            caso o <it>casting</it> tenha sido explicitamente fornecido.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1437" objetivo="5.1">
		<introducao>A sentença <stmt>byte b = 2;</stmt> é válida, mesmo
            o valor <stmt>2</stmt> sendo do tipo <stmt>int</stmt>. Por
            outro lado, <stmt>float f = 1.0;</stmt> não é válida, pois o
            valor <stmt>1.0</stmt> é do tipo <stmt>double</stmt>, mesmo
            sendo um valor (constante) possível de ser armazenada em uma
            variável do tipo <stmt>float</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1438" objetivo="5.1">
		<introducao>O código abaixo não compila.<java><![CDATA[public class Assign {
    byte b = 340 - 300;
    float f = 1.0;
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1439" objetivo="5.1">
		<introducao>A sentença <stmt>float f = 0;</stmt> é válida,
            enquanto <stmt>float f = 0.0;</stmt> não.</introducao>
		<resposta valor="v">Observe que <stmt>0.0</stmt> é do
            tipo <stmt>double</stmt>.</resposta>
	</questao>
	<questao id="1440" objetivo="5.1">
		<introducao>As atribuições envolvendo constantes em
            ponto-flutuante são diferentes daquelas envolvendo
            constantes inteiras.  Constantes inteiras do tipo
            <stmt>int</stmt> que podem ser armazenadas em variáveis de
            tipos de menos bits que um <stmt>int</stmt> podem ser
            atribuídas a estas variáveis sem <it>casting</it> explícito.
            Por outro lado, constantes em ponto-flutuante do tipo
            <stmt>double</stmt>, mesmo que possam ser armazenadas em
            variáveis do tipo <stmt>float</stmt> como a constante
            <stmt>0.0</stmt>, por exemplo, exige o <it>casting</it>
            explícito ou um erro em tempo de compilação é provocado.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1441" objetivo="5.1">
		<introducao>Literais em ponto-flutuante são valores do tipo <stmt>double</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1442" objetivo="5.1">
		<introducao>Literais em ponto-flutuante são valores de 64 bits (<stmt>double</stmt>).</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1443" objetivo="5.1">
		<introducao>A literal <stmt>2.3</stmt> é um valor do tipo <stmt>float</stmt>.</introducao>
		<resposta valor="f">
			<stmt>double</stmt>
		</resposta>
	</questao>
	<questao id="1444" objetivo="5.1">
		<introducao>A literal <stmt>2.3</stmt> é um valor do tipo <stmt>double</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1445" objetivo="5.1">
		<introducao>A sentença <stmt>float f = 1.2;</stmt> não compila.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1446" objetivo="5.1">
		<introducao>A sentença <stmt>float f = 0.0;</stmt> não compila.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1447" objetivo="5.1">
		<introducao>A sentença <stmt>float f = 0;</stmt> não compila.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1448" objetivo="5.1">
		<introducao>A sentença <stmt>float f = 0.0;</stmt> não compila,
            enquanto <stmt>float f = 0;</stmt> compila.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1449" objetivo="5.1">
		<introducao>A literal <stmt>-0.0</stmt> é do tipo <stmt>double</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1450" objetivo="5.1">
		<introducao>A sentença <stmt>float f = -0.0;</stmt> não compila.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1451" objetivo="5.1">
		<introducao>A sentença <stmt>float f = +0.0;</stmt> não compila.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1452" objetivo="5.1">
		<introducao>A sentença <stmt>float f = -0.0f;</stmt> não compila.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1453" objetivo="5.1">
		<introducao>A sentença <stmt>float f = +0.0;</stmt> não compila.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1454" objetivo="5.1">
		<introducao>A sentença <stmt>float f = 0 + 0;</stmt> não compila.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1455" objetivo="5.1">
		<introducao>A sentença <stmt>float f = (float)(0.0 + 0);</stmt>
            não compila.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1456" objetivo="5.1">
		<introducao>A sentença <stmt>float f = (float)(0.0) + 0;</stmt>
            não compila.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1457" objetivo="5.1">
		<introducao>A sentença <stmt>float f = (float)(0.0) + 0d;</stmt>
            não compila.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1458" objetivo="5.1">
		<introducao>A sentença <stmt>float f = (float)(0.0) + 0D;</stmt>
            não compila.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1459" objetivo="5.1">
		<introducao>A sentença <stmt>float f = (float)0d;</stmt> não compila.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1460" objetivo="5.1">
		<introducao>A sentença <stmt>float f = (float)0;</stmt> não compila.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1461" objetivo="5.1">
		<introducao>A sentença <stmt>float f = 0.0f;</stmt> não compila.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1462" objetivo="5.1">
		<introducao>A sentença <stmt>float f = 0.0(float);</stmt> não compila.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1463" objetivo="5.1">
		<introducao>A sentença <stmt>double d = 0.0;</stmt> não compila.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1464" objetivo="5.1">
		<introducao>A sentença <stmt>double d = 0.0d;</stmt> não compila.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1465" objetivo="5.1">
		<introducao>A sentença <stmt>double d = (double)0.0;</stmt> não compila.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1466" objetivo="5.1">
		<introducao>A sentença <stmt>double d = 0.0f;</stmt> não compila.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1467" objetivo="5.1">
		<introducao>A sentença <stmt>double d = (float)0.0f;</stmt> não compila.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1468" objetivo="5.1">
		<introducao>A sentença <stmt>double d = 0.0F;</stmt> não compila.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1469" objetivo="5.1">
		<introducao>A sentença <stmt>double d = 0;</stmt> não compila.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1470" objetivo="5.1">
		<introducao>Embora seja possível armazenar o valor
            <stmt>3.14</stmt> em uma variável do tipo
            <stmt>float</stmt>, observe que o valor correspondente a
            esta literal é do tipo <stmt>double</stmt> e, portanto, a
            atribuição desta literal a uma variável do tipo
            <stmt>float</stmt> provoca um erro em tempo de compilação.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1471" objetivo="5.1">
		<introducao>Em Java, os números em ponto-flutuante podem ser de
            dois tipos: <stmt>float</stmt> e <stmt>double</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1472" objetivo="5.1">
		<introducao>O tipo <stmt>long</stmt> de 64 bits pode ser
            empregado para reter um valor em ponto-flutuante.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1473" objetivo="5.1">
		<introducao>A sentença <stmt>byte b = 128;</stmt> não compila.</introducao>
		<resposta valor="v">Observe que o valor 128 é muito grande para
            ser armazenado em uma variável do tipo <stmt>byte</stmt>.</resposta>
	</questao>
	<questao id="1474" objetivo="5.1">
		<introducao>Uma variável do tipo <stmt>byte</stmt> é pequena
            para armazenar o valor <stmt>128</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1475" objetivo="5.1">
		<introducao>A sentença <stmt>byte b = (byte)128;</stmt> não compila.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1476" objetivo="5.1">
		<introducao>A sentença <stmt>byte b = (byte)256;</stmt> compila,
            embora o valor <stmt>256</stmt> seja maior do que o maior
            dos valores possível de ser armazenado em um <stmt>byte</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1477" objetivo="5.1">
		<introducao>Quando <stmt>(byte)256</stmt> é atribuído a uma
            variável do tipo <stmt>byte</stmt>, primeiro o valor 256 do
            tipo <stmt>int</stmt> é subtraído de seus 24 bits mais
            significativos. Ou seja, <stmt>00000000 00000000 00000001
            00000000</stmt> resulta em <stmt>00000000</stmt>, que é
            depositado na variável <stmt>byte</stmt>, ou seja, o valor
            decimal 0.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1478" objetivo="5.1">
		<introducao>A sentença <stmt>byte b = (byte)128;</stmt> faz com
            que o valor 128 do tipo <stmt>int</stmt>, cuja representação
            binária é <stmt>00000000 00000000 00000000 10000000</stmt>,
            tenha os seus 24 bits mais significativos simplesmente
            retirados, o que resulta em <stmt>10000000</stmt>.
            Enganosamente pode-se especular que, neste caso, nenhuma
            perda ocorre. Contudo, convém lembrar, <stmt>10000000</stmt>
            não representa o valor 128 mas o valor -128, pois o bit mais
            significativo representa o bit de sinal e, neste caso, o
            número é negativo. Para saber qual número este representa
            inverte-se o valor binário e soma-se 1, o que resulta em
            <stmt>10000000</stmt>. Cujo valor decimal é 128 e, uma vez
            aplicado o sinal, resulta em -128.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1479" objetivo="5.1">
		<introducao>A sentença <stmt>byte b = 2;</stmt> seguida da
            sentença <stmt>b += 5;</stmt> não compila.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1480" objetivo="5.1">
		<introducao>O operador de atribuição composto permite adicionar
            ao valor de uma variável do tipo <stmt>byte</stmt> uma
            literal do tipo <stmt>int</stmt> sem o emprego explícito do
            operador de <it>cast</it>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1481" objetivo="5.1">
		<introducao>A sentença <stmt>b = (byte)(b+2);</stmt> não compila.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1482" objetivo="5.1">
		<introducao>A sentença <stmt>b += 2;</stmt> não compila.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1483" objetivo="5.1">
		<introducao>A sentença <stmt>b += 2.0;</stmt> não compila caso a
            variável <stmt>b</stmt> seja do tipo <stmt>byte</stmt>.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1484" objetivo="5.1">
		<introducao>A sentença <stmt>b = b + 2.0;</stmt> não compila.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1485" objetivo="5.1">
		<introducao>A sentença <stmt>b += 1.0;</stmt> compila, enquanto
                <stmt>b = b + 1.0;</stmt> não compila. Assuma que
            <stmt>b</stmt> é uma variável do tipo <stmt>byte</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1486" objetivo="5.1">
		<introducao>A sentença <stmt>b += 1.0;</stmt> compila, enquanto
                <stmt>b = b + 1.0;</stmt> não compila. Assuma que
            <stmt>b</stmt> é uma variável do tipo <stmt>float</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1487" objetivo="5.1">
		<introducao>A sentença <stmt>char c = 2.3;</stmt> não compila.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1488" objetivo="5.1">
		<introducao>A sentença <stmt>c += 2.3;</stmt> não compila.
            Assuma que <stmt>c</stmt> é uma variável do tipo <stmt>char</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1489" objetivo="5.1">
		<introducao>A sentença <stmt>char c = 2;</stmt> não compila.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1490" objetivo="5.1">
		<introducao>Seja <stmt>c</stmt> é uma variável do tipo
            <stmt>char</stmt>. Em conseqüência, <stmt>c +=
            (int)5;</stmt> não compila.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1491" objetivo="5.1">
		<introducao>Seja <stmt>c</stmt> é uma variável do tipo
            <stmt>char</stmt>. Em conseqüência, <stmt>c +=
            (double)5;</stmt> não compila.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1492" objetivo="5.1">
		<introducao>Seja <stmt>c</stmt> é uma variável do tipo
            <stmt>char</stmt>. Em conseqüência, <stmt>c += 5.3;</stmt>
            não compila.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1493" objetivo="5.1">
		<introducao>Seja <stmt>c</stmt> é uma variável do tipo
            <stmt>char</stmt>. Em conseqüência, <stmt>c += 5D;</stmt>
            não compila.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1494" objetivo="5.1">
		<introducao>Seja <stmt>c</stmt> é uma variável do tipo
            <stmt>char</stmt>. Em conseqüência, <stmt>c += 5D +
            2f;</stmt> não compila.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1495" objetivo="5.1">
		<introducao>Seja <stmt>c</stmt> é uma variável do tipo
            <stmt>byte</stmt>. Em conseqüência, <stmt>c +=
            (int)5;</stmt> não compila.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1496" objetivo="5.1">
		<introducao>Seja <stmt>c</stmt> é uma variável do tipo
            <stmt>byte</stmt>. Em conseqüência, <stmt>c +=
            (long)5;</stmt> não compila.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1497" objetivo="5.1">
		<introducao>Seja <stmt>c</stmt> é uma variável do tipo
            <stmt>char</stmt>. Em conseqüência, <stmt>c +=
            (long)5F;</stmt> não compila.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1498" objetivo="5.1">
		<introducao>Quando se faz uma atribuição a uma variável do tipo
            primitivo <stmt>char</stmt>, <stmt>byte</stmt>,
            <stmt>short</stmt>, <stmt>int</stmt> e <stmt>long</stmt> via
            atribuição composta, por exemplo <stmt>+=</stmt>, então não
            é necessário explicitamente realizar o <it>casting</it> do
            lado direito desta atribuição. </introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1499" objetivo="5.1">
		<introducao>Do lado direito de uma atribuição composta, cujo
            lado esquerdo possui uma variável do tipo
            <stmt>short</stmt>, pode seguir qualquer literal de qualquer
            tipo primitivo e, mesmo assim, a sentença resultante compila satisfatoriamente.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1500" objetivo="5.1">
		<introducao>A sentença <stmt>byte b = (int)100f;</stmt> não compila.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1501" objetivo="5.1">
		<introducao>A sentença <stmt>byte b = (long)100f;</stmt> não compila.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1502" objetivo="5.1">
		<introducao>A sentença <stmt>byte b = 100f;</stmt> não compila.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1503" objetivo="5.1">
		<introducao>A sentença <stmt>char c = (int)100;</stmt> não compila.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1504" objetivo="5.1">
		<introducao>A sentença <stmt>char c = (long)100;</stmt> não compila.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1505" objetivo="5.1">
		<introducao>A sentença <stmt>char c = (int)100f;</stmt> não compila.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1506" objetivo="5.1">
		<introducao>A sentença <stmt>char c = (int)100D;</stmt> não compila.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1507" objetivo="5.1">
		<introducao>A sentença <stmt>char c = (int)100s;</stmt> não compila.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1508" objetivo="5.1">
		<introducao>A sentença <stmt>char c = 100c;</stmt> não compila.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1509" objetivo="5.1">
		<introducao>Se um valor do tipo <stmt>int</stmt>,
            <stmt>short</stmt>, <stmt>byte</stmt> ou <stmt>char</stmt> é
            atribuído a uma variável de qualquer um destes tipos, então
            não é necessário fazer uso explícito de <it>casting</it>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1510" objetivo="5.1">
		<introducao>Um valor do tipo <stmt>int</stmt> pode ser atribuído
            diretamente a uma variável do tipo <stmt>char</stmt> sem
            moldagem (<it>casting</it>) explítica.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1511" objetivo="5.1">
		<introducao>Um valor do tipo <stmt>short</stmt> pode ser
            atribuído diretamente a uma variável do tipo
            <stmt>byte</stmt> sem moldagem (<it>casting</it>) explítica.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1512" objetivo="5.1">
		<introducao>A sentença <stmt>byte b =
            (int)(long)(float)100D;</stmt> compila satisfatoriamente.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1513" objetivo="5.1">
		<introducao>Um valor do tipo <stmt>long</stmt> pode ser
            atribuído diretamente a uma variável do tipo
            <stmt>byte</stmt> sem moldagem (<it>casting</it>) explítica.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1514" objetivo="5.1">
		<introducao>Um valor do tipo <stmt>long</stmt> pode ser
            atribuído diretamente a uma variável do tipo
            <stmt>int</stmt> sem moldagem (<it>casting</it>) explítica.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1515" objetivo="5.1">
		<introducao>Um valor do tipo <stmt>long</stmt> pode ser
            atribuído diretamente a uma variável do tipo
            <stmt>char</stmt> sem moldagem (<it>casting</it>) explítica.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1516" objetivo="5.1">
		<introducao>Um valor do tipo <stmt>byte</stmt> pode ser
            atribuído diretamente a uma variável do tipo
            <stmt>char</stmt> sem moldagem (<it>casting</it>) explítica.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1517" objetivo="5.1">
		<introducao>A sentença <stmt>byte b = 0D;</stmt> não compila,
            pois há tentativa de se atribuir a uma variável do tipo
            <stmt>byte</stmt> um valor do tipo <stmt>double</stmt> sem
            moldagem (<it>casting</it>) explícita.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1518" objetivo="5.1">
		<introducao>A sentença <stmt>char c = (byte)0D;</stmt> não compila.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1519" objetivo="5.1">
		<introducao>A sentença <stmt>double d = (char)1;</stmt> não compila.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1520" objetivo="5.1">
		<introducao>A sentença <stmt>double d = (byte)1;</stmt> não compila.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1521" objetivo="5.1">
		<introducao>A sentença <stmt>double d = (short)1;</stmt> não compila.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1522" objetivo="5.1">
		<introducao>A sentença <stmt>double d = (int)1;</stmt> não compila.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1523" objetivo="5.1">
		<introducao>A sentença <stmt>double d = (float)1;</stmt> não compila.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1524" objetivo="5.1">
		<introducao>A sentença <stmt>double d = (double)1;</stmt> não compila.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1525" objetivo="5.1">
		<introducao>A sentença <stmt>double d = (float)1d;</stmt> não compila.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1526" objetivo="5.1">
		<introducao>Não há sufixo para designar literais do tipo
            <stmt>boolean</stmt>, <stmt>char</stmt>, <stmt>byte</stmt>,
            <stmt>short</stmt> e <stmt>int</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1527" objetivo="5.1">
		<introducao>Não há sufixo para designar literais do tipo <stmt>boolean</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1528" objetivo="5.1">
		<introducao>Não há sufixo para designar literais do tipo <stmt>char</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1529" objetivo="5.1">
		<introducao>Não há sufixo para designar literais do tipo <stmt>short</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1530" objetivo="5.1">
		<introducao>Não há sufixo para designar literais do tipo <stmt>int</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1531" objetivo="5.1">
		<introducao>Não há sufixo para designar literais do tipo <stmt>long</stmt>.</introducao>
		<resposta valor="f">Os sufixos são <stmt>l</stmt> ou <stmt>L</stmt>.</resposta>
	</questao>
	<questao id="1532" objetivo="5.1">
		<introducao>Não há sufixo para designar literais do tipo <stmt>float</stmt>.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1533" objetivo="5.1">
		<introducao>Não há sufixo para designar literais do tipo <stmt>double</stmt>.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1534" objetivo="5.1">
		<introducao>O sufixo <stmt>L</stmt> designa uma literal do tipo <stmt>long</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1535" objetivo="5.1">
		<introducao>O sufixo <stmt>l</stmt> designa uma literal do tipo <stmt>long</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1536" objetivo="5.1">
		<introducao>O sufixo <stmt>D</stmt> designa uma literal do tipo <stmt>double</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1537" objetivo="5.1">
		<introducao>O sufixo <stmt>d</stmt> designa uma literal do tipo <stmt>double</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1538" objetivo="5.1">
		<introducao>O sufixo <stmt>ld</stmt> designa uma literal do tipo
                <stmt>long double</stmt>.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1539" objetivo="5.1">
		<introducao>O sufixo <stmt>L</stmt> designa uma literal do tipo
                <stmt>long int</stmt>.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1540" objetivo="5.1">
		<introducao>O sufixo <stmt>b</stmt> designa uma literal do tipo <stmt>byte</stmt>.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1541" objetivo="5.1">
		<introducao>Quando se observa o código abaixo
            <java><![CDATA[int a = 6;
int b = a;]]></java>pode-se
            afirmar que o padrão de 32 bits correspondente ao valor 6 é
            copiado para a variável <stmt>a</stmt> e, em seguida, este
            mesmo padrão de bits, agora copiado da variável
            <stmt>a</stmt> é depositado na variável <stmt>b</stmt> e
            que, não existe nenhum outro relacionamento entre estas
            variáveis, exceto o fato de compartilharem, talvez por um
            período exíguo de tempo, um mesmo valor.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1542" objetivo="5.1">
		<introducao>Quando se observa o código abaixo
            <java><![CDATA[int a = 6;
int b = a;]]></java>pode-se
            afirmar que posteriores atribuições à variável
            <stmt>b</stmt> irão refletir no valor armazenado na variável <stmt>a</stmt>.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1543" objetivo="5.1">
		<introducao>Quando se observa o código abaixo
            <java><![CDATA[int a = 6;
int b = a;]]></java>pode-se
            afirmar que posteriores atribuições à variável
            <stmt>a</stmt> irão refletir no valor armazenado na variável <stmt>b</stmt>.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1544" objetivo="5.1">
		<introducao>Após a execução das sentenças abaixo, a alteração do
            conteúdo de qualquer uma destas variáveis não irá afetar o
            conteúdo da outra.<java><![CDATA[int a = 6;
int b = a;]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1545" objetivo="5.1">
		<introducao>A saída produzida pela execução do código abaixo é <stmt>5</stmt>.<java><![CDATA[class Teste {
    public static void main(String[] args) {
        byte i = 2;
        byte j = i;
        j = 5;
        System.out.println(i);
    }
}]]></java>
		</introducao>
		<resposta valor="f">Não há nenhum relacionamento entre as
            variáveis <stmt>i</stmt> e <stmt>j</stmt>. Alteração do
            valor armazenado em uma não irá afetar o valor da outra.</resposta>
	</questao>
	<questao id="1546" objetivo="5.1">
		<introducao>A saída produzida pela execução do código abaixo é <stmt>2</stmt>.<java><![CDATA[class Teste {
    public static void main(String[] args) {
        byte i = 2;
        byte j = i;
        j = 5;
        System.out.println(i);
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1547" objetivo="5.1">
		<introducao>Quando se atribui o valor de uma variável a outra
            variável tem-se, a partir desta atribuição, um
            relacionamento entre estas variáveis de tal forma que,
            quando uma é alterada, o valor da outra também é alterado
            para o mesmo valor.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1548" objetivo="5.1">
		<introducao>Quando de declara duas variáveis em Java, reserva-se
            espaço não compartilhado para os padrões de bits correspondentes.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1549" objetivo="5.1">
		<introducao>Atribuições envolvendo variáveis primitivas, um do
            lado direito e outra do lado esquerdo de uma atribuição como
            em <stmt>a = b;</stmt> não significa que, a partir deste
            momento, que estas variáveis compartilham a mesma memória.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1550" objetivo="5.1">
		<introducao>A atribuição <stmt>a = b;</stmt> é adequadamente
            interpretada como a cópia do padrão de bits armazenado na
            variável <stmt>b</stmt> para aqueles bits da variável
            <stmt>a</stmt>. Após esta atribuição, alteração do valor de
            uma destas variáveis não irá afetar o valor armazenado na outra.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1551" objetivo="5.1">
		<introducao>Pode-se criar um objeto e depositar a referência
            para este objeto em uma variável através de como como <java><![CDATA[String str = new String();]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1552" objetivo="5.1">
		<introducao>A sentença <stmt>String str;</stmt> cria uma
            variável do tipo referência do tipo <stmt>String</stmt>,
            cujo identificador é <stmt>str</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1553" objetivo="5.1">
		<introducao>Quando se declara uma variável do tipo referência, é
            obrigatória a definição do tipo classe, tipo interface ou
            tipo <it>array</it> correspondente.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1554" objetivo="5.1">
		<introducao>Os tipos em Java estão organizados naqueles
            primitivos e de referência.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1555" objetivo="5.1">
		<introducao>A atribuição abaixo, quando executada,
            correspondente a três ações: (a) cria uma variável
            referência para o tipo <stmt>String</stmt>; (b) cria um
            objeto <stmt>String</stmt> no <it>heap</it> e, por último,
            (c) atribui o objeto criado à variável referência <stmt>str</stmt>.<java><![CDATA[String str = new String();]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1556" objetivo="5.1">
		<introducao>Uma variável referência pode referenciar qualquer
            objeto que é descendente do tipo declarado da referência.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1557" objetivo="5.1">
		<introducao>O código abaixo compila satisfatoriamente, todas as
            atribuições às variáveis referência são válidas.<java><![CDATA[class A {}
class B extends A {}

class Teste {
    public static void main(String[] args) {
        B b1 = new B();
        B b2 = new A();
        A a1 = new A();
        A a2 = new B();
    }
}]]></java>
		</introducao>
		<resposta valor="f">Observe que a segunda atribuição é inválida.
            As demais estão corretas.</resposta>
	</questao>
	<questao id="1558" objetivo="5.1">
		<introducao>O código abaixo compila satisfatoriamente, todas as
            atribuições às variáveis referência são válidas.<java><![CDATA[class A {}
class B extends A {}

class Teste {
    public static void main(String[] args) {
        B b1 = new B();
        A a1 = new A();
        A a2 = new B();
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1559" objetivo="5.1">
		<introducao>O código abaixo compila.<java><![CDATA[class A {
    public void fazA() {}
}

class B extends A {
    public void fazB() {}
}

class Teste {
    public static void main(String[] args) {
        new B().fazB();
        new B().fazA();
        new A().fazA();
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1560" objetivo="5.1">
		<introducao>O código abaixo compila e executa sem gerar exceção.<java><![CDATA[class A {
    public void fazA() {}
}

class B extends A {
    public void fazB() {}
}

class Teste {
    public static void main(String[] args) {
        A a = new A();
        ((B)a).fazB();
    }
}]]></java>
		</introducao>
		<resposta valor="f">Compila, mas gera a exceção <stmt>ClassCastException</stmt>.</resposta>
	</questao>
	<questao id="1561" objetivo="5.1">
		<introducao>O código abaixo não compila.<java><![CDATA[class A {
    public void fazA() {}
}

class B extends A {
    public void fazB() {}
}

class Teste {
    public static void main(String[] args) {
        A a = new A();
        ((B)a).fazB();
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1562" objetivo="5.1">
		<introducao>O código abaixo compila e gera a exceção <stmt>ClassCastException</stmt>.<java><![CDATA[class A {
    public void fazA() {}
}

class B extends A {
    public void fazB() {}
}

class Teste {
    public static void main(String[] args) {
        A a = new A();
        ((B)a).fazB();
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1563" objetivo="5.1">
		<introducao>Quando se cria uma variável referência para o tipo
            classe <stmt>A</stmt> e tenta-se atribuir a esta variável um
            objeto do tipo <stmt>B</stmt> e o código resultante compila,
            então pode-se afirmar que <stmt>B</stmt> é um tipo classe
            derivado de <stmt>A</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1564" objetivo="5.1">
		<introducao>Se a compilação do código abaixo falha, então a
            classe <stmt>A</stmt> não é derivada de <stmt>B</stmt>.<java><![CDATA[A a = new B();]]></java>
		</introducao>
		<resposta valor="f">Se esta sentença não compila, então
            <stmt>B</stmt> não é derivada de <stmt>A</stmt>.</resposta>
	</questao>
	<questao id="1565" objetivo="5.1">
		<introducao>Se a compilação do código abaixo falha, então a
            classe <stmt>B</stmt> não é derivada de <stmt>A</stmt>.<java><![CDATA[A a = new B();]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1566" objetivo="5.1">
		<introducao>Em uma variável referência pode existir uma
            referência para qualquer objeto que é do tipo classe
            declarado ou qualquer classe derivada deste tipo classe.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1567" objetivo="5.1">
		<introducao>Um objeto da classe <stmt>B</stmt>, derivada de
            <stmt>A</stmt>, pode ser tratado como uma instância de
            <stmt>A</stmt>. De fato, tudo que <stmt>A</stmt> faz,
            <stmt>B</stmt> também faz. O sentido oposto não é verdade.
            Ou seja, nem tudo que <stmt>B</stmt> faz pode ser feito por
            <stmt>A</stmt>. Daí ser proibida a atribuição de um objeto
            do tipo <stmt>A</stmt> a uma variável referência do tipo <stmt>B</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1568" objetivo="5.1">
		<introducao>O conteúdo de uma variável referência é um padrão de
            bits. Quando há uma atribuição <stmt>a = b;</stmt> onde
            ambas as variáveis são referências, o padrão de bits da
            variável <stmt>b</stmt> é copiado sobre o padrão de bits da
            variável <stmt>a</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1569" objetivo="5.1">
		<introducao>Pode-se ter acesso a um objeto no <it>heap</it>
            através de uma ou mais variáveis referência que referenciam
            o objeto desejado.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1570" objetivo="5.1">
		<introducao>Se <stmt>b</stmt> é uma variável referência cujo
            padrão de bits indica um objeto <stmt>Obj</stmt> no
            <it>heap</it>, então a sentença <stmt>a = b;</stmt> faz com
            que um novo objeto seja criado no <it>head</it>, cujo
            conteúdo é o mesmo de <stmt>Obj</stmt> e a referência para o
            objeto criado é depositada na variável <stmt>a</stmt>.</introducao>
		<resposta valor="f">Apenas o padrão de bits de <stmt>b</stmt> é
            copiado sobre aquele de <stmt>a</stmt>.</resposta>
	</questao>
	<questao id="1571" objetivo="5.1">
		<introducao>O código abaixo compila e, quando executado, gera
            uma exceção.<java><![CDATA[class Ponto {
    public int x = 0;
    public int y = 0;
}

public class Teste {
    public static void main(String[] args) {
        Ponto p1 = new Ponto();
        Ponto p2 = new Ponto();
        p2.x = 10;
        System.out.println("p1.x = " + p1.x + " p2.x = " + p2.x);
        Ponto p3 = p1;
        p3.x = 10;
        System.out.println("p1.x = " + p1.x + " p2.x = " + p2.x);
    }
}]]></java>
		</introducao>
		<resposta valor="f">Compila e executa sem exceções.</resposta>
	</questao>
	<questao id="1572" objetivo="5.1">
		<introducao>O código abaixo não compila.<java><![CDATA[class Ponto {
    public int x = 0;
    public int y = 0;
}

public class Teste {
    public static void main(String[] args) {
        Ponto p1 = new Ponto();
        Ponto p2 = new Ponto();
        p2.x = 10;
        System.out.println("p1.x = " + p1.x + " p2.x = " + p2.x);
        Ponto p3 = p1;
        p3.x = 10;
        System.out.println("p1.x = " + p1.x + " p2.x = " + p2.x);
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1573" objetivo="5.1">
		<introducao>O código abaixo, quando executado, mostra que o
            valor em <stmt>p1.x</stmt> é 0, na primeira impressão e, na
            segunda, o valor é alterado para 10.<java><![CDATA[class Ponto {
    public int x = 0;
    public int y = 0;
}

public class Teste {
    public static void main(String[] args) {
        Ponto p1 = new Ponto();
        Ponto p2 = new Ponto();
        p2.x = 10;
        System.out.println("p1.x = " + p1.x + " p2.x = " + p2.x);
        Ponto p3 = p1;
        p3.x = 10;
        System.out.println("p1.x = " + p1.x + " p2.x = " + p2.x);
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1574" objetivo="5.1">
		<introducao>O código abaixo, quando executado, nas duas ocasiões
            em que imprime o valor de <stmt>p2.x</stmt>, o valor exibido
            é o mesmo.<java><![CDATA[class Ponto {
    public int x = 0;
    public int y = 0;
}

public class Teste {
    public static void main(String[] args) {
        Ponto p1 = new Ponto();
        Ponto p2 = new Ponto();
        p2.x = 10;
        System.out.println("p1.x = " + p1.x + " p2.x = " + p2.x);
        Ponto p3 = p1;
        p3.x = 10;
        System.out.println("p1.x = " + p1.x + " p2.x = " + p2.x);
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1575" objetivo="5.1">
		<introducao>O código abaixo cria dois objetos no <it>heap</it> e
            três referências para estes dois objetos. Duas variáveis
            referência referenciam o mesmo objeto. Através de qualquer
            uma destas variáveis é possível ter acesso ao objeto
            correspondente. No código abaixo, as variáveis
            <stmt>p1</stmt> e <stmt>p3</stmt> referenciam o mesmo
            objeto. Quando se executa a sentença <stmt>p3.x = 10;</stmt>
            tem-se que o valor do membro <stmt>x</stmt> do objeto em
            questão é alterado. Qualquer referência a este objeto que
            obtenha o membro <stmt>x</stmt> irá retornar o valor
            depositado por esta atribuição. Em conseqüência, o acesso a
            este membro via <stmt>p1</stmt> irá indicar que houve uma
            mudança, conforme a saída produzida por este código.<java><![CDATA[class Ponto {
    public int x = 0;
    public int y = 0;
}

public class Teste {
    public static void main(String[] args) {
        Ponto p1 = new Ponto();
        Ponto p2 = new Ponto();
        p2.x = 10;
        System.out.println("p1.x = " + p1.x + " p2.x = " + p2.x);
        Ponto p3 = p1;
        p3.x = 10;
        System.out.println("p1.x = " + p1.x + " p2.x = " + p2.x);
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1576" objetivo="5.1">
		<introducao>
			<it>Strings</it> em Java, representadas pela classe
            <stmt>String</stmt>, são objetos imutáveis
            (<it>immutable</it>), ou seja, não se alteram.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1577" objetivo="5.1">
		<introducao>O código abaixo produz como saída a seqüência de
            caracteres <stmt>OK</stmt>.<java><![CDATA[public class Assign3 {
    public static void main(String[] args) {
        String s1 = new String("Ok");
        String s2 = s1;
        s2.toUpperCase();
        System.out.println(s1);
    }
}]]></java>
		</introducao>
		<resposta valor="f">Produz <stmt>Ok</stmt> com a segunda letra minúscula.</resposta>
	</questao>
	<questao id="1578" objetivo="5.1">
		<introducao>O código abaixo cria um único objeto no <it>heap</it>.<java><![CDATA[public class Assign3 {
    public static void main(String[] args) {
        String s1 = new String("Ok");
        String s2 = s1;
        s2.toUpperCase();
        System.out.println(s1);
    }
}]]></java>
		</introducao>
		<resposta valor="f">Cria dois.</resposta>
	</questao>
	<questao id="1579" objetivo="5.1">
		<introducao>O código abaixo cria dois objetos no <it>heap</it>.
            A sentença <stmt>s2.toUpperCase();</stmt> cria o segundo
            objeto, cujo conteúdo é <stmt>OK</stmt>.<java><![CDATA[public class Assign3 {
    public static void main(String[] args) {
        String s1 = new String("Ok");
        String s2 = s1;
        s2.toUpperCase();
        System.out.println(s1);
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1580" objetivo="5.1">
		<introducao>A saída produzida pelo código abaixo é <stmt>CASA</stmt>.<java><![CDATA[public class Teste  {
    public static void main(String[] args) {
        String s1 = "C";
        String s2 = s1;
        s2 = s2 + "ASA";
        System.out.println(s1);
    }
}]]></java>
		</introducao>
		<resposta valor="f">O objeto referenciado por <stmt>s1</stmt>
            não é alterado, pois um objeto <stmt>String</stmt> é imutável.</resposta>
	</questao>
	<questao id="1581" objetivo="5.1">
		<introducao>A saída produzida pelo código abaixo é <stmt>CASA</stmt>.<java><![CDATA[public class Teste  {
    public static void main(String[] args) {
        String s1 = "C";
        String s2 = s1;
        s2 = s2 + "ASA";
        System.out.println(s2);
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1582" objetivo="5.1">
		<introducao>A saída produzida pelo código abaixo é <stmt>C</stmt>.<java><![CDATA[public class Teste  {
    public static void main(String[] args) {
        String s1 = "C";
        String s2 = s1;
        s2 = s2 + "ASA";
        System.out.println(s1);
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1583" objetivo="5.1">
		<introducao>O código abaixo não compila.<java><![CDATA[public class Teste  {
    public static void main(String[] args) {
        String s1 = "C";
        String s2 = s1;
        s2 = s2 + "ASA";
        System.out.println(s1);
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1584" objetivo="5.1">
		<introducao>O código abaixo cria dois objetos
            <stmt>String</stmt> no <it>heap</it>.<java><![CDATA[public class Teste  {
    public static void main(String[] args) {
        String s1 = new String("C");
        String s2 = s1;
        s2 = s2 + "ASA";
        System.out.println(s1);
    }
}]]></java>
		</introducao>
		<resposta valor="v">Um referenciado por <stmt>s1</stmt> e outro
            referenciado por <stmt>s2</stmt> após a segunda atribuição a
            esta variável.</resposta>
	</questao>
	<questao id="1585" objetivo="5.1">
		<introducao>Quando se emprega o operador de concatenação um novo
            objeto <stmt>String</stmt> é criado.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1586" objetivo="5.1">
		<introducao>Operadores de comparação sempre resultam em um valor
            do tipo <stmt>byte</stmt>.</introducao>
		<resposta valor="f">O tipo é <stmt>boolean</stmt>.</resposta>
	</questao>
	<questao id="1587" objetivo="5.1">
		<introducao>Operadores de comparação sempre resultam em um valor
            do tipo <stmt>Boolean</stmt>.</introducao>
		<resposta valor="f">O correto é <stmt>boolean</stmt>.</resposta>
	</questao>
	<questao id="1588" objetivo="5.1">
		<introducao>Uma comparação dá origem ao valor <stmt>true</stmt>
            ou <stmt>false</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1589" objetivo="5.1">
		<introducao>Uma comparação resulta no valor 0, que representa
            <stmt>false</stmt>, ou em um valor diferente e zero,
            usualmente 1, que representa <stmt>true</stmt>.</introducao>
		<resposta valor="f">Java não é C/C++. Em Java, comparação
            resulta em um valor do tipo <stmt>boolean</stmt>, ou seja,
            apenas <stmt>true</stmt> ou <stmt>false</stmt>.</resposta>
	</questao>
	<questao id="1590" objetivo="5.1">
		<introducao>O código abaixo compila e, quando executado, produz <stmt>false</stmt>.<java><![CDATA[public class Teste {
    public static void main(String[] args) {
        boolean b = 3 == 2;
        System.out.println(b);
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1591" objetivo="5.1">
		<introducao>O código abaixo não compila.<java><![CDATA[public class Teste {
    public static void main(String[] args) {
        boolean b = 3 == 2;
        System.out.println(b);
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1592" objetivo="5.1">
		<introducao>O código abaixo gera uma exceção quando executado.<java><![CDATA[public class Teste {
    public static void main(String[] args) {
        boolean b = 3 == 2;
        System.out.println(b);
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1593" objetivo="5.1">
		<introducao>O código abaixo cria uma variável de tipo primitivo,
            <stmt>boolean</stmt>, iniciada com o valor
            <stmt>false</stmt>, decorrente da condição <stmt>3 ==
            2</stmt> que é falsa.<java><![CDATA[public class Teste {
    public static void main(String[] args) {
        boolean b = 3 == 2;
        System.out.println(b);
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1594" objetivo="5.1">
		<introducao>O código abaixo não compila.<java><![CDATA[public class Op10 {
    public static void main(String[] args) {
        boolean b = 3 = 2;
        System.out.println(b);
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1595" objetivo="5.1">
		<introducao>>A saída produzida pela execução do código abaixo é <stmt>false</stmt>.<java><![CDATA[public class Op10 {
    public static void main(String[] args) {
        boolean b = 3 = 2;
        System.out.println(b);
    }
}]]></java>
		</introducao>
		<resposta valor="f">O código não compila. Observe que não há
            conversão possível entre o tipo <stmt>int</stmt> e o tipo <stmt>boolean</stmt>.</resposta>
	</questao>
	<questao id="1596" objetivo="5.1">
		<introducao>O código abaixo compila e, quando executado, produz <stmt>true</stmt>.<java><![CDATA[public class Op10 {
    public static void main(String[] args) {
        boolean b = 3 = 2;
        System.out.println(b);
    }
}]]></java>
		</introducao>
		<resposta valor="f">O código não compila. Observe que não há
            conversão possível entre o tipo <stmt>int</stmt> e o tipo <stmt>boolean</stmt>.</resposta>
	</questao>
	<questao id="1597" objetivo="5.1">
		<introducao>Há quatro operadores numéricos de comparação:
            <stmt><![CDATA[>]]></stmt>, <stmt><![CDATA[>=]]></stmt>,
            <stmt><![CDATA[<]]></stmt> e <stmt><![CDATA[<=]]></stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1598" objetivo="5.1">
		<introducao>Os quatro operadores numéricos de comparação podem
            ser empregados para comparar qualquer combinação de
            inteiros, números ponto-flutuante e caracteres.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1599" objetivo="5.1">
		<introducao>O código abaixo não compila.<java><![CDATA[public class Teste {
    public static void main(String[] args) {
        System.out.println(3 > 2);
        System.out.println(3 >= 3);
        System.out.println(3 < 2);
        System.out.println(3 <= 2);
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1600" objetivo="5.1">
		<introducao>A saída produzida pelo código abaixo é
            <stmt>true</stmt>, <stmt>true</stmt>, <stmt>false</stmt> e
            <stmt>false</stmt>, um por linha.<java><![CDATA[public class Teste {
    public static void main(String[] args) {
        System.out.println(3 > 2);
        System.out.println(3 >= 3);
        System.out.println(3 < 2);
        System.out.println(3 <= 2);
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1601" objetivo="5.1">
		<introducao>O código abaixo compila.<java><![CDATA[public class Teste {
    public static void main(String[] args) {
        System.out.println('A' > 'B');
        System.out.println('A' > 4);
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1602" objetivo="5.1">
		<introducao>A saída produzida pelo código abaixo é, na ordem,
            <stmt>false</stmt> seguido de <stmt>true</stmt>.<java><![CDATA[public class Teste {
    public static void main(String[] args) {
        System.out.println('A' > 'B');
        System.out.println('A' > 4);
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1603" objetivo="5.1">
		<introducao>É possível comparar um inteiro e um caractere em
            Java, ou seja, um valor do tipo <stmt>int</stmt> com outro
            do tipo <stmt>char</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1604" objetivo="5.1">
		<introducao>É possível comparar um ponto-flutuente e um
            caractere em Java, ou seja, um valor do tipo
            <stmt>double</stmt> com outro do tipo <stmt>char</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1605" objetivo="5.1">
		<introducao>O código abaixo não compila.<java><![CDATA[public class Teste {
    public static void main(String[] args) {
        System.out.println(3.14 > ('y' - 2));
        System.out.println(3L > 'a' % 3);
        System.out.println(1e1 > 2 * 'x');
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1606" objetivo="5.1">
		<introducao>Quando executado, o código abaixo gera uma exceção.<java><![CDATA[public class Teste {
    public static void main(String[] args) {
        System.out.println(3.14 > ('y' - 2));
        System.out.println(3L > 'a' % 3);
        System.out.println(1e1 > 2 * 'x');
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1607" objetivo="5.1">
		<introducao>Quando se compara um caractere com outro caractere,
            a comparação é realizada conforme o valor UNICODE dos caracteres.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1608" objetivo="5.1">
		<introducao>Quando se compara um caractere com um valor inteiro,
            por exemplo, uma variável do tipo <stmt>char</stmt> e outra
            do tipo <stmt>double</stmt>, a comparação é realizada
            conforme o valor UNICODE do caracter e o valor
            <stmt>double</stmt> em questão.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1609" objetivo="5.1">
		<introducao>O operador <stmt>instanceOf</stmt> é empregado para
            verificar se um objeto é de um tipo particular.</introducao>
		<resposta valor="f">O correto é <stmt>instanceof</stmt>.</resposta>
	</questao>
	<questao id="1610" objetivo="5.1">
		<introducao>O operador <stmt>instanceof</stmt> é empregado para
            verificar se um objeto é de um tipo particular.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1611" objetivo="5.1">
		<introducao>Apenas as variáveis do tipo referência podem ser
            empregadas como operandos para o operador <stmt>instanceof</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1612" objetivo="5.1">
		<introducao>A sentença <stmt>4 instanceof int</stmt> retorna o
            valor <stmt>true</stmt>.</introducao>
		<resposta valor="f">Operandos devem ser variáveis do tipo referência.</resposta>
	</questao>
	<questao id="1613" objetivo="5.1">
		<introducao>O código abaixo não compila.<java><![CDATA[public class Op14 {
    public static void main(String[] args) {
        System.out.println(4 instanceof int);
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1614" objetivo="5.1">
		<introducao>A sentença <stmt>&quot;A&quot; instanceof
            String</stmt> resulta no valor <stmt>true</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1615" objetivo="5.1">
		<introducao>Os operandos do operador <stmt>instanceof</stmt>
            necessariamente são do tipo referência ou do tipo <stmt>null</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1616" objetivo="5.1">
		<introducao>Um operando de <stmt>instanceof</stmt> ou é
            <stmt>null</stmt> ou um tipo referência.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1617" objetivo="5.1">
		<introducao>Se um operando de <stmt>instanceof</stmt> não é
            <stmt>null</stmt> e também não é um tipo referência, então
            um erro em tempo de execução ocorre.</introducao>
		<resposta valor="f">O erro é de compilação.</resposta>
	</questao>
	<questao id="1618" objetivo="5.1">
		<introducao>Se um operando de <stmt>instanceof</stmt> não é
            <stmt>null</stmt> e também não é um tipo referência, então
            um erro em tempo de compilação ocorre.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1619" objetivo="5.1">
		<introducao>A sentença <stmt>&quot;A&quot; instanceof
            null</stmt> é válida.</introducao>
		<resposta valor="f">O tipo <stmt>null</stmt> não pode ser o
            operando que segue o operador <stmt>instanceof</stmt>.</resposta>
	</questao>
	<questao id="1620" objetivo="5.1">
		<introducao>A sentença <stmt>null instanceof Boolean</stmt> é válida.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1621" objetivo="5.1">
		<introducao>Embora o operando <stmt>null</stmt> possa ser
            empregado com o operador <stmt>instanceof</stmt>,
            <stmt>null</stmt> não pode seguir este operador.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1622" objetivo="5.1">
		<introducao>A sentença <stmt>System.out.println(new int[] { 1 }
                instanceof int[]);</stmt> não compila.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1623" objetivo="5.1">
		<introducao>A sentença <stmt>System.out.println(new int[] { 1 }
                instanceof int[]);</stmt> compila.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1624" objetivo="5.1">
		<introducao>A sentença <stmt>System.out.println(new int[] { 1 }
                instanceof int[]);</stmt> produz como resultado <stmt>true</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1625" objetivo="5.1">
		<introducao>A sentença <stmt>System.out.println(new int[] { 1 }
                instanceof int[]);</stmt> produz como resultado <stmt>false</stmt>.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1626" objetivo="5.1">
		<introducao>Embora possa parecer estranha, a sentença
                <stmt>System.out.println(new int[] { 1 } instanceof
            int[]);</stmt> é válida. O operador <stmt>instanceof</stmt>
            pode possuir como argumento qualquer tipo referência ou o
            tipo <stmt>null</stmt>. Os tipos de referência incluem: tipo
            classe, tipo interface e tipo <it>array</it>. Portanto,
            <stmt>int[]</stmt> é um operando legal de
            <stmt>instanceof</stmt> assim como <stmt>Boolean[]</stmt>,
            por exemplo.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1627" objetivo="5.1">
		<introducao>O código abaixo compila.<java><![CDATA[interface IntAluno {}
class Aluno implements IntAluno {}

public class Op15 {
    public static void main(String[] args) {
        Aluno a = new Aluno();
        System.out.println(a instanceof IntAluno);
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1628" objetivo="5.1">
		<introducao>O código abaixo, quando executado, produz a saída <stmt>true</stmt>.<java><![CDATA[interface IntAluno {}
class Aluno implements IntAluno {}

public class Teste {
    public static void main(String[] args) {
        Aluno a = new Aluno();
        System.out.println(a instanceof IntAluno);
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1629" objetivo="5.1">
		<introducao>O código abaixo não compila.<java><![CDATA[class A {}
class SubA extends A {}
public class Teste extends SubA {
    public static void main(String[] args) {
        System.out.println(SubA instanceof A);
    }
}]]></java>
		</introducao>
		<resposta valor="v">O operador do lado esquerdo de
            <stmt>instanceof</stmt> deve ser um objeto.</resposta>
	</questao>
	<questao id="1630" objetivo="5.1">
		<introducao>O código abaixo compila.<java><![CDATA[class A {}
class SubA extends A {}

public class Teste extends SubA {
    public static void main(String[] args) {
        System.out.println(new SubA() instanceof A);
        System.out.println(new Teste() instanceof A);
        System.out.println(new A() instanceof A);
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1631" objetivo="5.1">
		<introducao>A saída produzida pelo código abaixo não inclui <stmt>false</stmt>.<java><![CDATA[class A {}
class SubA extends A {}

public class Teste extends SubA {
    public static void main(String[] args) {
        System.out.println(new SubA() instanceof A);
        System.out.println(new Teste() instanceof A);
        System.out.println(new A() instanceof A);
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1632" objetivo="5.1">
		<introducao>O operador <stmt>instanceof</stmt> retorna um valor
            do tipo <stmt>boolean</stmt> conforme o objeto fornecido do
            lado esquerdo seja uma instância do tipo classe, tipo
            interface ou tipo <it>array</it> fornecido do lado direito.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1633" objetivo="5.1">
		<introducao>Pode-se afirmar que qualquer que seja a variável do
            tipo referência identificada por <stmt>var</stmt>, a
            sentença <stmt>var instanceof Object</stmt> será verdadeira.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1634" objetivo="5.1">
		<introducao>O código abaixo compila.<java><![CDATA[interface I {}
class A implements I {}
class B extends A {}
public class Teste extends B {
    public static void main(String[] args) {
        System.out.println(new Teste() instanceof I);
        System.out.println(new B() instanceof I);
        System.out.println(new A() instanceof I);
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1635" objetivo="5.1">
		<introducao>A saída produzida pelo código abaixo não inclui <stmt>false</stmt>.<java><![CDATA[interface I {}
class A implements I {}
class B extends A {}
public class Teste extends B {
    public static void main(String[] args) {
        System.out.println(new Teste() instanceof I);
        System.out.println(new B() instanceof I);
        System.out.println(new A() instanceof I);
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1636" objetivo="5.1">
		<introducao>O código abaixo não compila.<java><![CDATA[class A {}
class B {}
class C extends B {}

public class Teste extends C {
    public static void main(String[] args) {
        System.out.println(new Teste() instanceof A);
        System.out.println(new C() instanceof A);
        System.out.println(new B() instanceof A);
        System.out.println(new A() instanceof B);
        System.out.println(new B() instanceof C);
        System.out.println(new C() instanceof B);
        System.out.println(new Teste() instanceof B);
        System.out.println(new Teste() instanceof C);
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1637" objetivo="5.1">
		<introducao>As quatro sentenças iniciais do método
            <stmt>main</stmt> abaixo provocam erros de compilação.<java><![CDATA[class A {}
class B {}
class C extends B {}

public class Teste extends C {
    public static void main(String[] args) {
        System.out.println(new Teste() instanceof A);
        System.out.println(new C() instanceof A);
        System.out.println(new B() instanceof A);
        System.out.println(new A() instanceof B);
        System.out.println(new B() instanceof C);
        System.out.println(new C() instanceof B);
        System.out.println(new Teste() instanceof B);
        System.out.println(new Teste() instanceof C);
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1638" objetivo="5.1">
		<introducao>A única sentença do método <stmt>main</stmt> abaixo
            provoca um erro de compilação, pois as classes
            <stmt>Teste</stmt> e <stmt>A</stmt> não fazem parte de uma
            mesma hierarquia. Ou seja, nenhuma é descendente da outra. <java><![CDATA[class A {}
class B {}
class C extends B {}

public class Teste extends C {
    public static void main(String[] args) {
        System.out.println(new Teste() instanceof A);
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1639" objetivo="5.1">
		<introducao>Embora sempre retorne o valor <stmt>false</stmt>, o
            operando esquerdo de <stmt>instanceof</stmt> pode ser
            <stmt>null</stmt> e, neste caso, qualquer tipo referência
            pode seguir o lado direito.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1640" objetivo="5.1">
		<introducao>O código abaixo compila.<java><![CDATA[interface I {}
public class Teste {
    public static void main(String[] args) {
        System.out.println(null instanceof int[]);
        System.out.println(null instanceof I);
        System.out.println(null instanceof Teste);
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1641" objetivo="5.1">
		<introducao>A saída produzida pelo código abaixo é
            exclusivamente formada por valores <stmt>false</stmt>.<java><![CDATA[interface I {}
public class Teste {
    public static void main(String[] args) {
        System.out.println(null instanceof int[]);
        System.out.println(null instanceof I);
        System.out.println(null instanceof Teste);
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1642" objetivo="5.1">
		<introducao>A saída do código abaixo é <stmt>false</stmt>.<java><![CDATA[public class Op20 {
    public static void main(String[] args) {
        String s1 = "String";
        String s2;
        boolean b1 = s1 instanceof String;
        boolean b2 = s2 instanceof String;
        System.out.println(s1 && s2);
    }
}]]></java>
		</introducao>
		<resposta valor="f">O código não compila. Há tentativa de usar
            <stmt>s2</stmt> sem que um valor inicial tenha sido fornecido.</resposta>
	</questao>
	<questao id="1643" objetivo="5.1">
		<introducao>A saída produzida pelo código abaixo é <stmt>true</stmt>.<java><![CDATA[public class Op20 {
    static String s1 = "String";
    static String s2;

    public static void main(String[] args) {
        boolean b1 = s1 instanceof String;
        boolean b2 = s2 instanceof String;
        System.out.println(b1 && b2);
    }
}]]></java>
		</introducao>
		<resposta valor="f">Embora <stmt>s2</stmt> seja uma variável do
            tipo referência de <stmt>String</stmt>, o valor armazenado
            nesta variável é <stmt>null</stmt> que, naturalmente, não é
            instância de nenhum tipo classe, interface ou <it>array</it>.</resposta>
	</questao>
	<questao id="1644" objetivo="5.1">
		<introducao>A saída produzida pelo código abaixo é <stmt>false</stmt>.<java><![CDATA[public class Op20 {
    static String s1 = "String";
    static String s2;

    public static void main(String[] args) {
        boolean b1 = s1 instanceof String;
        boolean b2 = s2 instanceof String;
        System.out.println(b1 && b2);
    }
}]]></java>
		</introducao>
		<resposta valor="v">Embora <stmt>s2</stmt> seja uma variável do
            tipo referência de <stmt>String</stmt>, o valor armazenado
            nesta variável é <stmt>null</stmt> que, naturalmente, não é
            instância de nenhum tipo classe, interface ou <it>array</it>.</resposta>
	</questao>
	<questao id="1645" objetivo="5.1">
		<introducao>Ao empregar o operador <stmt>instanceof</stmt>
            deve-se ter o cuidado de verificar se o tipo da variável do
            tipo referência faz parte da hierarquia que inclui o tipo
            referência fornecido no lado direitor deste operador. Se não
            for o caso, então o código não compila.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1646" objetivo="5.1">
		<introducao>O valor armazenado em uma variável do tipo
            referência é o que será considerado quando da avaliação do
            operador <stmt>instanceof</stmt>. Por exemplo, em <stmt>a
                instanceof b</stmt>, o tipo de <stmt>a</stmt> e o tipo
            <stmt>b</stmt> serão considerados em tempo de compilação e,
            durante a execução, o que estiver armazenado em
            <stmt>a</stmt> será considerado com o tipo <stmt>b</stmt>.
            Em conseqüência, <stmt>a instanceof b</stmt> pode resultar
            em <stmt>false</stmt> mesmo que <stmt>b a;</stmt> seja a
            declaração de <stmt>a</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1647" objetivo="5.1">
		<introducao>Dado que <stmt>A</stmt> é uma classe e <stmt>A
            v;</stmt> é a declaração da variável <stmt>v</stmt>, pode-se
            afirmar que sempre <stmt>v instanceof A</stmt> resulta em <stmt>true</stmt>.</introducao>
		<resposta valor="f">Pode-se afirmar que este código não causa um
            erro de compilação. Contudo, durante a execução, a variável
            <stmt>v</stmt> pode assumir a referência <stmt>null</stmt>,
            que irá conduzir ao valor <stmt>false</stmt>.</resposta>
	</questao>
	<questao id="1648" objetivo="5.1">
		<introducao>Dado que <stmt>A</stmt> é uma classe e <stmt>A
            v;</stmt> é a declaração da variável <stmt>v</stmt>, pode-se
            afirmar que, se <stmt>v != null</stmt> é <stmt>true</stmt>,
            então <stmt>v instanceof A</stmt> é <stmt>true</stmt>.</introducao>
		<resposta valor="v">Se <stmt>v != null</stmt>, então
            <stmt>v</stmt> contém uma referência para um objeto do tipo
            <stmt>A</stmt> ou para algum objeto descendente de
            <stmt>A</stmt> e, em ambos os casos, <stmt>v instanceof
            A</stmt> resulta em <stmt>true</stmt>. Observe que
            <stmt>v</stmt> não pode assumir a referência para um objeto
            que é ancestral de <stmt>A</stmt> pois tal tentativa
            resultará, em tempo de execução, na exceção <stmt>ClassCastException</stmt>.</resposta>
	</questao>
	<questao id="1649" objetivo="5.1">
		<introducao>O código abaixo não compila.<java><![CDATA[class B {}
class A extends B {}

public class Op21 {
    public static void main(String[] args) {
        B b = new B();
        A v = (A)b;
        System.out.println(v instanceof A);
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1650" objetivo="5.1">
		<introducao>A saída produzida pelo código abaixo é <stmt>false</stmt>.<java><![CDATA[class B {}
class A extends B {}

public class Op21 {
    public static void main(String[] args) {
        B b = new B();
        A v = (A)b;
        System.out.println(v instanceof A);
    }
}]]></java>
		</introducao>
		<resposta valor="f">Este código gera a exceção
            <stmt>ClassCastException</stmt> quando se tenta depositar na
            variável <stmt>v</stmt> uma referência para um objeto que é
            ancestral do tipo de referência de <stmt>v</stmt>.</resposta>
	</questao>
	<questao id="1651" objetivo="5.1">
		<introducao>Um <it>array</it> sempre é uma instância de
            <stmt>Object</stmt> e, dessa forma, <stmt>new char[]{ 'a' }
                instanceof Object</stmt> resulta em <stmt>true</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1652" objetivo="5.1">
		<introducao>O código abaixo compila e deposita na variável
            <stmt>b</stmt> o valor <stmt>true</stmt>.<java><![CDATA[public class Teste {
    boolean b = new char[] { 'a' } instanceof Object;
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1653" objetivo="5.1">
		<introducao>O código abaixo não compila.<java><![CDATA[public class Teste {
    boolean b = new char[] { 'a' } instanceof Object;
}]]></java>
		</introducao>
		<resposta valor="f">Todo <it>array</it> é instância de
            <stmt>Object</stmt>, mesmo que o <it>array</it> seja de um
            tipo primitivo.</resposta>
	</questao>
	<questao id="1654" objetivo="5.1">
		<introducao>Todo <it>array</it> é instância de
            <stmt>Object</stmt>, mesmo que os componentes do
            <it>array</it> sejam de um tipo primitivo.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1655" objetivo="5.1">
		<introducao>Se <stmt>A</stmt> é uma classe, então <stmt>new A[]
                { new A() } instanceof A</stmt> resulta em <stmt>true</stmt>.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1656" objetivo="5.1">
		<introducao>Se <stmt>A</stmt> é uma classe, então <stmt>new A[]
                { new A() } instanceof Object</stmt> resulta em <stmt>true</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1657" objetivo="5.1">
		<introducao>Se <stmt>A</stmt> é uma classe, então <stmt>(new A[]
                { new A() })[0] instanceof A</stmt> resulta em <stmt>true</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1658" objetivo="5.1">
		<introducao>O classe abaixo compila e quando uma instância é
            criada, deposita em <stmt>v</stmt> o valor  <stmt>true</stmt>.<java><![CDATA[public class Teste {
    boolean v = (new Teste[] { new Teste() })[0] instanceof Object;
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1659" objetivo="5.1">
		<introducao>Os operadores de igualdade são <stmt>==</stmt>
            (igual a) e <stmt>!=</stmt> (diferente de). Eles avaliam
            dois operandos e retornam um valor do tipo <stmt>boolean</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1660" objetivo="5.1">
		<introducao>Os operadores de igualdade (<stmt>==</stmt> e
            <stmt>!=</stmt>) comparam dois números, inclusive do tipo
            <stmt>char</stmt>, dois valores do tipo <stmt>boolean</stmt>
            ou duas referências. Não se pode realizar comparações com
            tipos incompatíveis, por exemplo, <stmt>char</stmt> e <stmt>boolean</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1661" objetivo="5.1">
		<introducao>O código abaixo não compila.<java><![CDATA[public class Teste {
    public static void main(String[] args) {
        byte b = 1;
        short s = 1;
        int i = 1;
        long l = 1;
        char c = 'A';

        boolean bool = b == s && s == i && i == l && l == c;
        System.out.println(bool);
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1662" objetivo="5.1">
		<introducao>O código abaixo imprime o valor <stmt>true</stmt>.<java><![CDATA[public class Teste {
    public static void main(String[] args) {
        byte b = 1;
        short s = 1;
        int i = 1;
        long l = 1;
        char c = 'A';

        boolean bool = b == s && s == i && i == l && l == c;
        System.out.println(bool);
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1663" objetivo="5.1">
		<introducao>O código abaixo produz na saída <stmt>IGUAIS</stmt>.<java><![CDATA[public class Teste {
    public static void main(String[] args) {
        String s = "casa";
        Character c = new Character('c');
        if (c == s) {
            System.out.println("IGUAIS");
        } else {
            System.out.println("DIFERENTES");
        }
    }
}]]></java>
		</introducao>
		<resposta valor="f">O código não compila.</resposta>
	</questao>
	<questao id="1664" objetivo="5.1">
		<introducao>O código abaixo produz na saída <stmt>DIFERENTES</stmt>.<java><![CDATA[public class Teste {
    public static void main(String[] args) {
        String s = "casa";
        Character c = new Character('c');
        if (c == s) {
            System.out.println("IGUAIS");
        } else {
            System.out.println("DIFERENTES");
        }
    }
}]]></java>
		</introducao>
		<resposta valor="f">O código não compila.</resposta>
	</questao>
	<questao id="1665" objetivo="5.1">
		<introducao>O código abaixo não compila, pois não é possível
            comparar uma referência do tipo <stmt>String</stmt> e uma
            referência do tipo <stmt>Character</stmt>.<java><![CDATA[public class Teste {
    public static void main(String[] args) {
        String s = "casa";
        Character c = new Character('c');
        if (c == s) {
            System.out.println("IGUAIS");
        } else {
            System.out.println("DIFERENTES");
        }
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1666" objetivo="5.1">
		<introducao>O tipo do valor resultante do operador de igualdade
            <stmt>==</stmt> é <stmt>int</stmt>.</introducao>
		<resposta valor="f">
			<stmt>boolean</stmt>
		</resposta>
	</questao>
	<questao id="1667" objetivo="5.1">
		<introducao>O tipo do valor resultante do operador
            <stmt>!=</stmt> é <stmt>int</stmt>.</introducao>
		<resposta valor="f">
			<stmt>boolean</stmt>
		</resposta>
	</questao>
	<questao id="1668" objetivo="5.1">
		<introducao>A comparação de um valor do tipo <stmt>float</stmt>
            com um valor do tipo <stmt>short</stmt> provoca um erro de compilação.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1669" objetivo="5.1">
		<introducao>A comparação de um valor do tipo <stmt>double</stmt>
            com um valor do tipo <stmt>char</stmt> pode provocar uma
            exceção em tempo de execução.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1670" objetivo="5.1">
		<introducao>O código abaixo produz como saída <stmt>IGUAIS</stmt>.<java><![CDATA[public class Op25 {
    public static void main(String[] args) {
        boolean b = false;
        if (b == 0) {
            System.out.println("IGUAIS");
        } else {
            System.out.println("DIFERENTES");
        }
    }
}]]></java>
		</introducao>
		<resposta valor="f">O código não compila. Observe que não é
            possível comparar um valor do tipo <stmt>int</stmt> com um
            valor do tipo <stmt>boolean</stmt>.</resposta>
	</questao>
	<questao id="1671" objetivo="5.1">
		<introducao>O código abaixo produz como saída <stmt>DIFERENTES</stmt>.<java><![CDATA[public class Op25 {
    public static void main(String[] args) {
        boolean b = false;
        if (b == 0) {
            System.out.println("IGUAIS");
        } else {
            System.out.println("DIFERENTES");
        }
    }
}]]></java>
		</introducao>
		<resposta valor="f">O código não compila. Observe que não é
            possível comparar um valor do tipo <stmt>int</stmt> com um
            valor do tipo <stmt>boolean</stmt>.</resposta>
	</questao>
	<questao id="1672" objetivo="5.1">
		<introducao>A comparação <stmt>false == 0</stmt> resulta no
            valor <stmt>true</stmt> do tipo <stmt>boolean</stmt>.</introducao>
		<resposta valor="f">A comparação entre <stmt>boolean</stmt> e
            <stmt>int</stmt> é incompatível.</resposta>
	</questao>
	<questao id="1673" objetivo="5.1">
		<introducao>Os tipos <stmt>boolean</stmt> e <stmt>int</stmt> são
            incompatíveis para a comparação.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1674" objetivo="5.1">
		<introducao>O código abaixo produz como saída <stmt>IGUAIS</stmt>.<java><![CDATA[public class Teste {
    public static void main(String[] args) {
        boolean b = false;
        if (b = true) {
            System.out.println("IGUAIS");
        } else {
            System.out.println("DIFERENTES");
        }
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1675" objetivo="5.1">
		<introducao>O código abaixo produz como saída <stmt>DIFERENTES</stmt>.<java><![CDATA[public class Teste {
    public static void main(String[] args) {
        boolean b = false;
        if (b = true) {
            System.out.println("IGUAIS");
        } else {
            System.out.println("DIFERENTES");
        }
    }
}]]></java>
		</introducao>
		<resposta valor="f">O código compila e produz
            <stmt>IGUAIS</stmt> quando executado.</resposta>
	</questao>
	<questao id="1676" objetivo="5.1">
		<introducao>O código abaixo não compila.<java><![CDATA[public class Teste {
    public static void main(String[] args) {
        boolean b = false;
        if (b = true) {
            System.out.println("IGUAIS");
        } else {
            System.out.println("DIFERENTES");
        }
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1677" objetivo="5.1">
		<introducao>O código abaixo gera exceção quando executado.<java><![CDATA[public class Teste {
    public static void main(String[] args) {
        boolean b = false;
        if (b = true) {
            System.out.println("IGUAIS");
        } else {
            System.out.println("DIFERENTES");
        }
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1678" objetivo="5.1">
		<introducao>Se <stmt>b</stmt> é uma variável do tipo
            <stmt>boolean</stmt>, então a atribuição <stmt>b =
            true</stmt> pode aparecer como condição em um <stmt>if</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1679" objetivo="5.1">
		<introducao>Se <stmt>b</stmt> é uma variável do tipo
            <stmt>char</stmt>, então a atribuição <stmt>b = true</stmt>
            pode aparecer como condição em um <stmt>if</stmt>.</introducao>
		<resposta valor="f">A condição de um <stmt>if</stmt> exige um
            valor do tipo <stmt>boolean</stmt>.</resposta>
	</questao>
	<questao id="1680" objetivo="5.1">
		<introducao>O código
            <java><![CDATA[int i = 1;
if (i = 2) {}]]></java>não compila.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1681" objetivo="5.1">
		<introducao>O código
            <java><![CDATA[byte i = 1;
if (i = 2) {}]]></java>não compila.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1682" objetivo="5.1">
		<introducao>O código
            <java><![CDATA[short i = 1;
if (i = 2) {}]]></java>não compila.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1683" objetivo="5.1">
		<introducao>O código
            <java><![CDATA[long i = 1;
if (i = 2) {}]]></java>não compila.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1684" objetivo="5.1">
		<introducao>O código
            <java><![CDATA[float i = 1;
if (i = 2) {}]]></java>não compila.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1685" objetivo="5.1">
		<introducao>O código
            <java><![CDATA[double i = 1;
if (i = 2) {}]]></java>não compila.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1686" objetivo="5.1">
		<introducao>O código
            <java><![CDATA[String s1, s2;
if (s1 = s2) {}]]></java>não compila.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1687" objetivo="5.1">
		<introducao>A saída produzida pelo código abaixo é <stmt>true</stmt>.<java><![CDATA[public class Teste {
    public static void main(String[] args) {
        String s1 = (new String("casa")).intern();
        String s2 = (new String("casa")).intern();
        System.out.println(s1 == s2);
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1688" objetivo="5.1">
		<introducao>A saída produzida pelo código abaixo é <stmt>true</stmt>.<java><![CDATA[public class Teste {
    public static void main(String[] args) {
        String s1 = new String("casa");
        String s2 = new String("casa");
        System.out.println(s1 == s2);
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1689" objetivo="5.1">
		<introducao>A saída produzida pelo código abaixo é <stmt>true</stmt>.<java><![CDATA[public class Teste {
    public static void main(String[] args) {
        String s1 = "casa".intern();
        String s2 = "casa".intern();
        System.out.println(s1 == s2);
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1690" objetivo="5.1">
		<introducao>A saída produzida pelo código abaixo é <stmt>true</stmt>.<java><![CDATA[public class Teste {
    public static void main(String[] args) {
        String s1 = "casa";
        String s2 = "casa";
        System.out.println(s1 == s2);
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1691" objetivo="5.1">
		<introducao>A divisão por zero <stmt>1/0</stmt> gera uma exceção.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1692" objetivo="5.1">
		<introducao>O código abaixo, quando executado, gera uma exceção.<java><![CDATA[public class Teste {
    public static void main(String[] args) {
        System.out.println(1/0);
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1693" objetivo="5.1">
		<introducao>O código abaixo, quando executado, gera uma exceção.<java><![CDATA[public class Teste {
    public static void main(String[] args) {
        System.out.println(1.0/0);
    }
}]]></java>
		</introducao>
		<resposta valor="f">Observe que o resultado é <stmt>Float.POSITIVE_INFINITY</stmt>.</resposta>
	</questao>
	<questao id="1694" objetivo="5.1">
		<introducao>O código abaixo, quando executado, gera uma exceção.<java><![CDATA[public class Teste {
    public static void main(String[] args) {
        System.out.println(1/0.0);
    }
}]]></java>
		</introducao>
		<resposta valor="f">Observe que o resultado é <stmt>Float.POSITIVE_INFINITY</stmt>.</resposta>
	</questao>
	<questao id="1695" objetivo="5.1">
		<introducao>O código abaixo, quando executado, gera uma exceção.<java><![CDATA[public class Teste {
    public static void main(String[] args) {
        System.out.println(1f/0);
    }
}]]></java>
		</introducao>
		<resposta valor="f">Observe que o resultado é <stmt>Float.POSITIVE_INFINITY</stmt>.</resposta>
	</questao>
	<questao id="1696" objetivo="5.1">
		<introducao>O código abaixo, quando executado, gera uma exceção.<java><![CDATA[public class Teste {
    public static void main(String[] args) {
        System.out.println(1/0f);
    }
}]]></java>
		</introducao>
		<resposta valor="f">Observe que o resultado é <stmt>Float.POSITIVE_INFINITY</stmt>.</resposta>
	</questao>
	<questao id="1697" objetivo="5.1">
		<introducao>A comparação de igualdade
                <stmt>Double.POSITIVE_INFINITY !=
            Float.POSITIVE_INFINITY</stmt> correspondente ao valor
            <stmt>true</stmt> do tipo <stmt>boolean</stmt>.</introducao>
		<resposta valor="f">O resultado é <stmt>false</stmt>.</resposta>
	</questao>
	<questao id="1698" objetivo="5.1">
		<introducao>A comparação de igualdade
                <stmt>Double.POSITIVE_INFINITY ==
            Float.POSITIVE_INFINITY</stmt> correspondente ao valor
            <stmt>true</stmt> do tipo <stmt>boolean</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1699" objetivo="5.1">
		<introducao>A execução do código abaixo gera uma exceção.<java><![CDATA[public class Op28 {
    public static void main(String[] args) {
        System.out.println(1D/0 == Float.POSITIVE_INFINITY);
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1700" objetivo="5.1">
		<introducao>A execução do código abaixo não compila. Observe que
            <stmt>1D/0</stmt> é do tipo <stmt>double</stmt> e, portanto,
            o resultado é <stmt>Double.POSITIVE_INFINITY</stmt>.<java><![CDATA[public class Op28 {
    public static void main(String[] args) {
        System.out.println(1D/0 == Float.POSITIVE_INFINITY);
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1701" objetivo="5.1">
		<introducao>A divisão de <stmt>1</stmt> por <stmt>0</stmt>
            resulta em uma exceção: <stmt>ArithmeticException</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1702" objetivo="5.1">
		<introducao>A divisão de <stmt>1f</stmt> por <stmt>0</stmt>
            resulta em uma exceção: <stmt>ArithmeticException</stmt>.</introducao>
		<resposta valor="f">Divisão por zero envolvendo ponto-flutuante
            da origem ao valor infinito, positivo ou negativo.</resposta>
	</questao>
	<questao id="1703" objetivo="5.1">
		<introducao>O código abaixo não compila.<java><![CDATA[public class Op28 {
    public static void main(String[] args) {
        System.out.println(1D/-0 == Float.POSITIVE_INFINITY);
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1704" objetivo="5.1">
		<introducao>O código abaixo não compila.<java><![CDATA[public class Op28 {
    public static void main(String[] args) {
        System.out.println(1D/-.0e0 == Float.POSITIVE_INFINITY);
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1705" objetivo="5.1">
		<introducao>Dividir um valor inteiro por zero gera a exceção <stmt>ArithmeticException</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1706" objetivo="5.1">
		<introducao>O resto da divisão inteira de um inteiro por zero
            causa a exceção <stmt>ArithmeticException</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1707" objetivo="5.1">
		<introducao>A divisão de um valor do tipo <stmt>char</stmt> por
            zero gera um erro de compilação.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1708" objetivo="5.1">
		<introducao>A operação <stmt>1%0</stmt> provoca um erro de compilação.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1709" objetivo="5.1">
		<introducao>A operação <stmt>1%0</stmt> provoca a exceção <stmt>ArithmeticException</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1710" objetivo="5.1">
		<introducao>A operação <stmt>1.0%0</stmt> provoca a exceção <stmt>ArithmeticException</stmt>.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1711" objetivo="5.1">
		<introducao>A operação <stmt>1%0.0</stmt> resulta em <stmt>NaN</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1712" objetivo="5.1">
		<introducao>A saída produzida pelo código abaixo é <stmt>true</stmt>.<java><![CDATA[public class Op28 {
    public static void main(String[] args) {
        System.out.println(1.0%0 == Double.POSITIVE_INFINITY);
    }
}]]></java>
		</introducao>
		<resposta valor="f">A saída é <stmt>NaN</stmt>.</resposta>
	</questao>
	<questao id="1713" objetivo="5.1">
		<introducao>A saída produzida pelo código abaixo é <stmt>true</stmt>.<java><![CDATA[public class Op28 {
    public static void main(String[] args) {
        System.out.println(1.0%0 == Double.NaN);
    }
}]]></java>
		</introducao>
		<resposta valor="f">O resultado de <stmt>1.0%0</stmt> é
            <stmt>NaN</stmt>, contudo, a comparação é <stmt>false</stmt>.</resposta>
	</questao>
	<questao id="1714" objetivo="5.1">
		<introducao>A execução de <stmt>x%0</stmt> gera
            <stmt>ArithmeticException</stmt> caso <stmt>x</stmt> seja de
            um tipo primitivo inteiro.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1715" objetivo="5.1">
		<introducao>A execução de <stmt>x%0</stmt> não gera
            <stmt>ArithmeticException</stmt> caso <stmt>x</stmt> seja de
            um tipo ponto-flutuante.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1716" objetivo="5.1">
		<introducao>A execução de <stmt>x/0</stmt> gera
            <stmt>ArithmeticException</stmt> caso <stmt>x</stmt> seja de
            um tipo primitivo inteiro.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1717" objetivo="5.1">
		<introducao>A execução de <stmt>x/0</stmt> não gera
            <stmt>ArithmeticException</stmt> caso <stmt>x</stmt> seja de
            um tipo ponto-flutuante.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1718" objetivo="5.1">
		<introducao>O resultado de <stmt>a + (b + c)</stmt> pode ser
            diferente de <stmt>a + b + c</stmt> em Java.</introducao>
		<resposta valor="v">Se <stmt>b</stmt> e <stmt>c</stmt> forem
            valores inteiros, por exemplo, e <stmt>a</stmt> uma
            <stmt>String</stmt>, então teremos resultados diferentes.</resposta>
	</questao>
	<questao id="1719" objetivo="5.1">
		<introducao>O código abaixo produz como saída <stmt>SOMA: 3</stmt>.<java><![CDATA[public class Teste {
    public static void main(String[] args) {
        byte b = 1;
        byte c = 2;
        String a = "Soma: ";
        System.out.println(a + b + c);
    }
}]]></java>
		</introducao>
		<resposta valor="f">A saída é <stmt>SOMA: 12</stmt>
		</resposta>
	</questao>
	<questao id="1720" objetivo="5.1">
		<introducao>O código abaixo produz como saída <stmt>SOMA: 12</stmt>.<java><![CDATA[public class Teste {
    public static void main(String[] args) {
        byte b = 1;
        byte c = 2;
        String a = "Soma: ";
        System.out.println(a + b + c);
    }
}]]></java>
		</introducao>
		<resposta valor="f">A saída é <stmt>SOMA: 12</stmt>
		</resposta>
	</questao>
	<questao id="1721" objetivo="5.1">
		<introducao>A saída produzida pelo código abaixo é <stmt>123</stmt>.<java><![CDATA[public class Teste {
    public static void main(String[] args) {
        byte a = 1;
        byte b = 2;
        String c = "3";
        System.out.println(a + b + c);
    }
}]]></java>
		</introducao>
		<resposta valor="f">A saída é <stmt>33</stmt>.</resposta>
	</questao>
	<questao id="1722" objetivo="5.1">
		<introducao>A saída produzida pelo código abaixo é <stmt>6</stmt>.<java><![CDATA[public class Teste {
    public static void main(String[] args) {
        byte a = 1;
        byte b = 2;
        String c = "3";
        System.out.println(a + b + c);
    }
}]]></java>
		</introducao>
		<resposta valor="f">A saída é <stmt>33</stmt>.</resposta>
	</questao>
	<questao id="1723" objetivo="5.1">
		<introducao>A saída produzida pelo código abaixo é <stmt>33</stmt>.<java><![CDATA[public class Teste {
    public static void main(String[] args) {
        byte a = 1;
        byte b = 2;
        String c = "3";
        System.out.println(a + b + c);
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1724" objetivo="5.1">
		<introducao>A saída produzida pelo código abaixo é <stmt>231</stmt>.<java><![CDATA[public class Teste {
    public static void main(String[] args) {
        byte a = 1;
        byte b = 2;
        String c = "3";
        System.out.println(b + c + a);
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1725" objetivo="5.1">
		<introducao>A saída produzida pelo código abaixo é <stmt>11</stmt>.<java><![CDATA[public class Teste {
    public static void main(String[] args) {
        byte a = 1;
        byte b = 2;
        String c = "";
        System.out.println(c + a + b / 2);
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1726" objetivo="5.1">
		<introducao>A saída produzida pelo código abaixo é <stmt>1</stmt>.<java><![CDATA[public class Teste {
    public static void main(String[] args) {
        byte a = 1;
        byte b = 2;
        String c = "";
        System.out.println(c + a + b / 2);
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1727" objetivo="5.1">
		<introducao>A saída produzida pelo código abaixo é <stmt>3</stmt>.<java><![CDATA[public class Teste {
    public static void main(String[] args) {
        byte a = 1;
        byte b = 2;
        String c = "";
        System.out.println("" + a + b);
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1728" objetivo="5.1">
		<introducao>A saída produzida pelo código abaixo é <stmt>12</stmt>.<java><![CDATA[public class Teste {
    public static void main(String[] args) {
        byte a = 1;
        byte b = 2;
        String c = "";
        System.out.println("" + a + b);
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1729" objetivo="5.1">
		<introducao>O código abaixo não compila.<java><![CDATA[public class Op28 {
    public static void main(String[] args) {
        byte a = 1;
        byte b = 2;
        String c = "";
        System.out.println(c + a++ + ++b);
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1730" objetivo="5.1">
		<introducao>O código abaixo produz como saída <stmt>4</stmt>.<java><![CDATA[public class Op28 {
    public static void main(String[] args) {
        byte a = 1;
        byte b = 2;
        String c = "";
        System.out.println(c + a++ + ++b);
    }
}]]></java>
		</introducao>
		<resposta valor="f">A saída é <stmt>13</stmt>.</resposta>
	</questao>
	<questao id="1731" objetivo="5.1">
		<introducao>O código abaixo produz como saída <stmt>13</stmt>.<java><![CDATA[public class Op28 {
    public static void main(String[] args) {
        byte a = 1;
        byte b = 2;
        String c = "";
        System.out.println(c + a++ + ++b);
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1732" objetivo="5.1">
		<introducao>A saída produzida pelo código abaixo é <stmt>null12</stmt>.<java><![CDATA[public class Teste {
    public static void main(String[] args) {
        String c = null;
        byte a = 1;
        byte b = 2;
        c += a + b;
        System.out.println(c);
    }
}]]></java>
		</introducao>
		<resposta valor="f">A saída é <stmt>null3</stmt>
		</resposta>
	</questao>
	<questao id="1733" objetivo="5.1">
		<introducao>A saída produzida pelo código abaixo é <stmt>12</stmt>.<java><![CDATA[public class Teste {
    public static void main(String[] args) {
        String c = null;
        byte a = 1;
        byte b = 2;
        c += a + b;
        System.out.println(c);
    }
}]]></java>
		</introducao>
		<resposta valor="f">A saída é <stmt>null3</stmt>
		</resposta>
	</questao>
	<questao id="1734" objetivo="5.1">
		<introducao>A saída produzida pelo código abaixo é <stmt>3</stmt>.<java><![CDATA[public class Teste {
    public static void main(String[] args) {
        String c = null;
        byte a = 1;
        byte b = 2;
        c += a + b;
        System.out.println(c);
    }
}]]></java>
		</introducao>
		<resposta valor="f">A saída é <stmt>null3</stmt>
		</resposta>
	</questao>
	<questao id="1735" objetivo="5.1">
		<introducao>A saída produzida pelo código abaixo é <stmt>3</stmt>.<java><![CDATA[public class Teste {
    public static void main(String[] args) {
        String c = "";
        byte a = 1;
        byte b = 2;
        c += a + b;
        System.out.println(c);
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1736" objetivo="5.1">
		<introducao>A saída produzida pelo código abaixo é <stmt>12</stmt>.<java><![CDATA[public class Teste {
    public static void main(String[] args) {
        String c = "";
        byte a = 1;
        byte b = 2;
        c += a + b;
        System.out.println(c);
    }
}]]></java>
		</introducao>
		<resposta valor="f">A saída é <stmt>3</stmt>.</resposta>
	</questao>
	<questao id="1737" objetivo="5.1">
		<introducao>As duas linhas impressas pelo código abaixo
            apresentam o mesmo conteúdo.<java><![CDATA[public class Teste {
    public static void main(String[] args) {
        byte a = 1;
        System.out.println(a + + + + + a);
        System.out.println(a++ + ++a);
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1738" objetivo="5.1">
		<introducao>A saída produzida pelo código abaixo é <stmt>5</stmt>.<java><![CDATA[public class Teste {
    public static void main(String[] args) {
        byte a = 1;
        System.out.println(a++ + ++a);
    }
}]]></java>
		</introducao>
		<resposta valor="f">A saída é <stmt>4</stmt>.</resposta>
	</questao>
	<questao id="1739" objetivo="5.1">
		<introducao>O código abaixo produz um erro de compilação.<java><![CDATA[public class Teste {
    public static void main(String[] args) {
        byte a = 1;
        System.out.println(a++ + ++a);
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1740" objetivo="5.1">
		<introducao>A saída produzida pelo código abaixo é <stmt>3</stmt>.<java><![CDATA[public class Teste {
    public static void main(String[] args) {
        byte a = 1;
        System.out.println(a++ + ++a);
    }
}]]></java>
		</introducao>
		<resposta valor="f">A saída é <stmt>4</stmt>.</resposta>
	</questao>
	<questao id="1741" objetivo="5.1">
		<introducao>A saída produzida pelo código abaixo é <stmt>4</stmt>.<java><![CDATA[public class Teste {
    public static void main(String[] args) {
        byte a = 1;
        System.out.println(a++ + ++a);
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1742" objetivo="5.1">
		<introducao>A saída produzida pelo código abaixo é <stmt>12</stmt>.<java><![CDATA[public class Teste {
    public static void main(String[] args) {
        byte a = 0;
        System.out.println((++a + a++) + (a++ + ++a) + a);
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1743" objetivo="5.1">
		<introducao>A saída produzida pelo código abaixo é <stmt>8</stmt>.<java><![CDATA[public class Teste {
    public static void main(String[] args) {
        byte a = 0;
        System.out.println((++a + a++) + (a++ + ++a) + a);
    }
}]]></java>
		</introducao>
		<resposta valor="f">A saída é <stmt>12</stmt>.</resposta>
	</questao>
	<questao id="1744" objetivo="5.1">
		<introducao>A saída produzida pelo código abaixo é <stmt>0</stmt>.<java><![CDATA[public class Teste {
    public static void main(String[] args) {
        byte a = 0;
        System.out.println((++a + a++) + (a++ + ++a) + a);
    }
}]]></java>
		</introducao>
		<resposta valor="f">A saída é <stmt>12</stmt>.</resposta>
	</questao>
	<questao id="1745" objetivo="5.1">
		<introducao>A saída produzida pelo código abaixo é <stmt>10</stmt>.<java><![CDATA[public class Teste {
    public static void main(String[] args) {
        byte a = 0;
        System.out.println((++a + a++) + (a++ + ++a) + a);
    }
}]]></java>
		</introducao>
		<resposta valor="f">A saída é <stmt>12</stmt>.</resposta>
	</questao>
	<questao id="1746" objetivo="5.1">
		<introducao>O código abaixo imprime o valor <stmt>0</stmt>.<java><![CDATA[public class Teste {
    public static void main(String[] args) {
        final byte a = 0;
        System.out.println(a++);
    }
}]]></java>
		</introducao>
		<resposta valor="f">O código não compila.</resposta>
	</questao>
	<questao id="1747" objetivo="5.1">
		<introducao>O código abaixo não compila.<java><![CDATA[public class Teste {
    public static void main(String[] args) {
        final byte a = 0;
        System.out.println(a++);
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1748" objetivo="5.1">
		<introducao>Operadores de deslocamento (<it>shift</it>) são
            aplicados exclusivamente sobre números inteiros.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1749" objetivo="5.1">
		<introducao>O resultado de <stmt><![CDATA[2 >> 1]]></stmt> é <stmt>1</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1750" objetivo="5.1">
		<introducao>O resultado de <stmt><![CDATA[8 >> 3]]></stmt> é <stmt>1</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1751" objetivo="5.1">
		<introducao>O resultado de
            <stmt><![CDATA[0x80000000 >> 31]]></stmt> é <stmt>1</stmt>.</introducao>
		<resposta valor="f">Seqüência de 32 bits todos com o valor 1.</resposta>
	</questao>
	<questao id="1752" objetivo="5.1">
		<introducao>O resultado de
            <stmt><![CDATA[0x80000000 >> 31]]></stmt> é uma seqüência de
            32 bits todos com o valor <stmt>1</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1753" objetivo="5.1">
		<introducao>Um deslocamento (<it>shift</it>) de bits para a
            esquerda remove o bit de sinal.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1754" objetivo="5.1">
		<introducao>Um deslocamento (<it>shift</it>) de bits para a
            esquerda remove o bit de sinal e insere zeros no lado direito.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1755" objetivo="5.1">
		<introducao>Um deslocamento (<it>shift</it>) de bits para a
            esquerda (<stmt><![CDATA[<<]]></stmt>remove o bit de sinal e
            insere tantos zeros a direita quanto o operando à direita
            deste operador.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1756" objetivo="5.1">
		<introducao>O deslocamento de bits para a esquerda é realizado
            pelo operador <stmt><![CDATA[<<]]></stmt>, enquanto o
            deslocamento para a direita com o operador <stmt><![CDATA[>>]]></stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1757" objetivo="5.1">
		<introducao>O deslocamento de bits para a direita
            <stmt><![CDATA[>>]]></stmt> elimina os bits da direita e
            insere uma mesma quantidade de bits com o mesmo valor do
            sinal à esquerda.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1758" objetivo="5.1">
		<introducao>O deslocamento de bits para a direita
            <stmt><![CDATA[>>]]></stmt> faz com que um número negativo
            permaneça negativo e um número positivo permaneça positivo.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1759" objetivo="5.1">
		<introducao>O deslocamento de bits para a equerda pode alterar o
            sinal do número cujos bits estão sendo deslocados.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1760" objetivo="5.1">
		<introducao>Há um operador especial,
            <stmt><![CDATA[>>>]]></stmt>, que desloca bits para a
            direita sem que o sinal seja mantido. Ou seja, zero são
            inceridos à esquerda da mesma forma que zero são inseridos à
            direita quando se usa o operador <stmt><![CDATA[<<]]></stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1761" objetivo="5.1">
		<introducao>O resultado de
            <stmt><![CDATA[0x80000000 >>> 31]]></stmt> é <stmt>1</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1762" objetivo="5.1">
		<introducao>O resultado de
            <stmt><![CDATA[(0x80000000 >>> 31) << 31]]></stmt> é <stmt>0x80000000</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1763" objetivo="5.1">
		<introducao>O resultado de
            <stmt><![CDATA[(0x80000000 >> 31) << 31]]></stmt> é <stmt>0x80000000</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1764" objetivo="5.1">
		<introducao>O resultado de
            <stmt><![CDATA[(0x00000001 << 31) >> 31]]></stmt> é <stmt>0x00000001</stmt>.</introducao>
		<resposta valor="f">Observe que o operador
            <stmt><![CDATA[>>]]></stmt> mantém o sinal do número,
            inserindo 1s caso o número seja negativo e zero em caso positivo.</resposta>
	</questao>
	<questao id="1765" objetivo="5.1">
		<introducao>O operador de deslocamento sem sinal, ou seja,
            <stmt><![CDATA[>>>]]></stmt>, sempre dá origem a um número
            positivo, independente do sinal do número original.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1766" objetivo="5.1">
		<introducao>O segundo argumento de um operador de deslocamento
            sempre é dado pelo módulo do número de bits do número que
            está sendo deslocado.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1767" objetivo="5.1">
		<introducao>A operação <stmt><![CDATA[10 >> 36]]></stmt> é
            equivalente à <stmt><![CDATA[10 >> 4]]></stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1768" objetivo="5.1">
		<introducao>Os operadores de bits (<it>bitwise</it>) incluem:
            <stmt><![CDATA[&]]></stmt>, <stmt><![CDATA[|]]></stmt> e <stmt><![CDATA[^]]></stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1769" objetivo="5.1">
		<introducao>O operador <stmt><![CDATA[&]]></stmt> compara os
            bits correspondentes dos operandos e, caso ambos sejam 1,
            então o valor final correspondente a este bit será 1. Nos
            demais casos o bit resultante é 0.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1770" objetivo="5.1">
		<introducao>O código abaixo, quando executado imprime, na
            seqüência, linha por linha: <stmt>false</stmt>,
            <stmt>true</stmt>, <stmt>false</stmt>, <stmt>true</stmt>.<java><![CDATA[public class Bitwise {
    public static void main(String[] args) {
        System.out.println((10 & 10) == 20);
        System.out.println((10 & 10) == 10);
        System.out.println((10 & 11) == 11);
        System.out.println((010 & 8) == 010);
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1771" objetivo="5.1">
		<introducao>O operador <stmt><![CDATA[|]]></stmt> resulta em um
            bit de valor 1 se pelo menos um dos bits correspondentes é
            1. Se ambos são 0, então o bit resultante é 0.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1772" objetivo="5.1">
		<introducao>O código abaixo, quando executado imprime, na
            seqüência, linha por linha: <stmt>false</stmt>,
            <stmt>true</stmt>, <stmt>true</stmt>, <stmt>true</stmt>.<java><![CDATA[public class Bitwise {
    public static void main(String[] args) {
        System.out.println((10 | 10) == 20);
        System.out.println((10 | 10) == 10);
        System.out.println((10 | 11) == 11);
        System.out.println((010 | 8) == 010);
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1773" objetivo="5.1">
		<introducao>O operador <stmt><![CDATA[^]]></stmt> compara bits
            correspondente para identificar se são diferentes. Caso
            sejam diferentes, então o bit resultante é 1. Este operador
            é conhecido por OU exclusivo. </introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1774" objetivo="5.1">
		<introducao>O código abaixo, quando executado imprime, na
            seqüência, linha por linha: <stmt>false</stmt>,
            <stmt>false</stmt>, <stmt>true</stmt>, <stmt>false</stmt>.<java><![CDATA[public class Bitwise {
    public static void main(String[] args) {
        System.out.println((10 ^ 10) == 20);
        System.out.println((10 ^ 10) == 10);
        System.out.println((10 ^ 11) == 01);
        System.out.println((010 ^ 8) == 010);
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1775" objetivo="5.1">
		<introducao>O operador <stmt><![CDATA[^]]></stmt> pode ser o
            único operador de uma expressão do tipo <stmt>boolean</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1776" objetivo="5.1">
		<introducao>O operador <stmt><![CDATA[&]]></stmt> pode ser o
            único operador de uma expressão do tipo <stmt>boolean</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1777" objetivo="5.1">
		<introducao>O operador <stmt><![CDATA[|]]></stmt> pode ser o
            único operador de uma expressão do tipo <stmt>boolean</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1778" objetivo="5.1">
		<introducao>O operador <stmt><![CDATA[~]]></stmt> pode ser o
            único operador de uma expressão do tipo <stmt>boolean</stmt>.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1779" objetivo="5.1">
		<introducao>Se o operando do operador <stmt><![CDATA[~]]></stmt>
            é do tipo primitivo inteiro (<it>integral</it>), digamos
            <stmt>x</stmt>, então <stmt><![CDATA[~x = (-x)-1]]></stmt>.</introducao>
		<resposta valor="v">Observe que
            <stmt><![CDATA[-x = ~x + 1]]></stmt>, conforme a notação de
            complemento dois empregada por Java. Em conseqüência, <stmt><![CDATA[(-x)-1= ~x + 1 - 1 = ~x]]></stmt>.</resposta>
	</questao>
	<questao id="1780" objetivo="5.1">
		<introducao>O código abaixo não compila. <java><![CDATA[public class BitwiseComplement {
    public static void main(String[] args) {
        boolean b = true;
        for (byte i = -128; i != 127; i++) {
            b &= (~i == ((-i) - 1));
        }
        System.out.println(b);
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1781" objetivo="5.1">
		<introducao>O código abaixo imprime o valor <stmt>true</stmt>
            quando executado.<java><![CDATA[public class BitwiseComplement {
    public static void main(String[] args) {
        boolean b = true;
        for (byte i = -128; i != 127; i++) {
            b &= (~i == ((-i) - 1));
        }
        System.out.println(b);
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1782" objetivo="5.1">
		<introducao>O código abaixo imprime o valor <stmt>false</stmt>
            quando executado.<java><![CDATA[public class BitwiseComplement {
    public static void main(String[] args) {
        boolean b = true;
        for (byte i = -128; i != 127; i++) {
            b &= (~i == ((-i) - 1));
        }
        System.out.println(b);
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1783" objetivo="5.1">
		<introducao>A expressão <stmt>~2 == -3</stmt> resulta em valor <stmt>true</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1784" objetivo="5.1">
		<introducao>O operador condicional é um operador ternário. Um
            dos operandos é uma expressão do tipo <stmt>boolean</stmt>,
            cuja resultado decide qual das outras duas expressões será avaliada.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1785" objetivo="5.1">
		<introducao>O operador condicional faz uso de <stmt>?</stmt> e
            <stmt>:</stmt> para delimitar os três operandos.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1786" objetivo="5.1">
		<introducao>O primeiro operando do operador condicional é
            necessariamente do tipo <stmt>boolean</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1787" objetivo="5.1">
		<introducao>O segundo e terceiro operandos do operador
            condicional são, ambos, do tipo <stmt>boolean</stmt>, ou de
            um tipo numérico, ou do tipo referência ou, por último, um é
            do tipo referência e o outro do tipo <stmt>null</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1788" objetivo="5.1">
		<introducao>O código abaixo não compila.<java><![CDATA[public class Implicit {
    public static void main(String[] args) {
        int a = 2;
        long l = a;
        System.out.println(l);
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1789" objetivo="5.1">
		<introducao>O código abaixo contém uma conversão de tipo
            (<it>casting</it>) implícita.<java><![CDATA[public class Implicit {
    public static void main(String[] args) {
        int a = 2;
        long l = a;
        System.out.println(l);
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1790" objetivo="5.1">
		<introducao>O código abaixo não compila.<java><![CDATA[public class Casting {
    public static void main(String[] args) {
        int x = 1.2;
        System.out.println(x);
    }
}]]></java>
		</introducao>
		<resposta valor="v">Observe que <stmt>1.2</stmt> é uma literal
            do tipo <stmt>double</stmt>. Um <stmt>double</stmt> não pode
            ser depositado em um <stmt>int</stmt> sem uma conversão explícita.</resposta>
	</questao>
	<questao id="1791" objetivo="5.4">
		<introducao>Argumentos (parâmetros) fornecidos para métodos
            podem ser de qualquer tipo primitivo ou de um tipo referência.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1792" objetivo="5.4">
		<introducao>Quando se passa um objeto para um método, o que de
            fato é fornecido é uma referência para o objeto em questão e
            não o próprio.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1793" objetivo="2.1">
		<introducao>O classe abaixo, quando executada, imprime a
            <it>string</it> formada pela letra <stmt>A</stmt>.<java><![CDATA[public class If {
    private static boolean funcao(int i) {
        return (i % 2 == 0) ? true : false;
    }

    public static void main(String[] args) {
        int i = 3;
        if (funcao(i))
            if (i < 5)
                System.out.println("A");
        else
            System.out.println("B");
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1794" objetivo="2.1">
		<introducao>O classe abaixo, quando executada, imprime a
            <it>string</it> formada pela letra <stmt>B</stmt>.<java><![CDATA[public class If {
    private static boolean funcao(int i) {
        return (i % 2 == 0) ? true : false;
    }

    public static void main(String[] args) {
        int i = 3;
        if (funcao(i))
            if (i < 5)
                System.out.println("A");
        else
            System.out.println("B");
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1795" objetivo="2.1">
		<introducao>O classe abaixo, quando executada, não imprime
            nenhuma informação..<java><![CDATA[public class If {
    private static boolean funcao(int i) {
        return (i % 2 == 0) ? true : false;
    }

    public static void main(String[] args) {
        int i = 3;
        if (funcao(i))
            if (i < 5)
                System.out.println("A");
        else
            System.out.println("B");
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1796" objetivo="2.1">
		<introducao>A execução da classe abaixo exibe a mensagem <stmt>OK</stmt>.<java><![CDATA[public class If2 {
    public static void main(String[] args) {
        int x = 2;
        if (x > 3 && x != 4 | x == 2) {
            System.out.println("OK");
        }
    }
}]]></java>
		</introducao>
		<resposta valor="f">As expressões que formam a condição são
            avaliadas da esquerda para a direita, como <stmt>x >
            3</stmt> é uma condição falsa e esta deveria ser verdadeira
            para que toda a expressão fosse verdadeira, a condição é
            falsa e, portanto, nada é impresso quando esta classe é executada.</resposta>
	</questao>
	<questao id="1797" objetivo="2.1">
		<introducao>A classe abaixo não compila.<java><![CDATA[public class If2 {
    public static void main(String[] args) {
        int x = 2;
        if (x > 3 && x != 4 | x == 2) {
            System.out.println("OK");
        }
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1798" objetivo="2.1">
		<introducao>Se <stmt>b</stmt> é uma variável do tipo
            <stmt>boolean</stmt> declarada como <stmt>boolean b =
            false</stmt>, então a sentença <stmt>if (b = true) {}</stmt>
            não compila.</introducao>
		<resposta valor="f">O resultado de uma atribuição é do tipo da
            expressão do lado direito da atribuição.</resposta>
	</questao>
	<questao id="1799" objetivo="2.1">
		<introducao>Se <stmt>b</stmt> é uma variável do tipo
            <stmt>int</stmt> declarada como <stmt>int b = 1</stmt>,
            então a sentença <stmt>if (b = 1) {}</stmt> não compila.</introducao>
		<resposta valor="v">Uma condição deve, necessariamente, ser do
            tipo <stmt>boolean</stmt>. Observe que o tipo da atribuição
            é <stmt>int</stmt>.</resposta>
	</questao>
	<questao id="1800" objetivo="2.1">
		<introducao>Em uma sentença <stmt>switch</stmt>, o tipo da
            expressão deve ser do tipo <stmt>char</stmt>,
            <stmt>byte</stmt>, <stmt>short</stmt> ou <stmt>int</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1801" objetivo="2.1">
		<introducao>O código abaixo não compila.<java><![CDATA[public class Switch4 {
    public static void main(String[] args) {
        double x = 3;
        switch ((int) x) {
        case (int) 3.2:
            System.out.println("3");
            break;
        case (byte) .2:
            System.out.println(".2");
            break;
        }
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1802" objetivo="2.1">
		<introducao>A sentença <stmt>switch (x ==2) { case true: case
                false: break; }</stmt> não compila.</introducao>
		<resposta valor="v">O tipo da expressão de um
            <stmt>switch</stmt> é necessariamente um tipo inteiro.
            <stmt>boolean</stmt> é um tipo inválido neste caso.</resposta>
	</questao>
	<questao id="1803" objetivo="2.1">
		<introducao>O argumento para o <stmt>case</stmt> de uma sentença
            <stmt>switch</stmt> deve ser necessariamente uma constante.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1804" objetivo="2.1">
		<introducao>A expressão constante de um <stmt>case</stmt> de uma
            sentença <stmt>switch</stmt> deve ser necessariamente
            possível de ser atribuída ao tipo da sentença
            <stmt>switch</stmt>. Caso contrário, um erro de compilação ocorre.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1805" objetivo="2.1">
		<introducao>Duas ou mais sentenças <stmt>case</stmt> não podem
            estar associadas ao mesmo valor constante. Ou seja, se um
            <stmt>case</stmt> possui como argumento o valor
            <stmt>3.2</stmt>, então não pode existir outro
            <stmt>case</stmt> com argumento <stmt>(.2 + 3)</stmt> no
            <stmt>switch</stmt> em questão.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1806" objetivo="2.1">
		<introducao>Uma sentença <stmt>switch</stmt> só pode possui um
            único <stmt>default</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1807" objetivo="2.1">
		<introducao>O código abaixo, quando executado, produz na saída a
            mensagem <stmt>NEM 2 NEM 3</stmt>.<java><![CDATA[public class Switch4 {
    public static void main(String[] args) {
        double x = 3;
        switch ((int) x) {
        default:
            System.out.println("NEM 2 NEM 3");
        case 1:
            System.out.println("3");
            break;
        case 2:
            System.out.println(".2");
            break;
        }
    }
}]]></java>
		</introducao>
		<resposta valor="f">A mensagem sugerida é seguida de
            <stmt>3</stmt>. Observe que <stmt>default</stmt> não é
            seguido de sentença <stmt>break</stmt> para impedir que
            outras sentenças sejam executadas. A execução do
            <stmt>switch</stmt> termina com o <stmt>break</stmt>
            correspondente ao valor constante <stmt>1</stmt>.</resposta>
	</questao>
	<questao id="1808" objetivo="2.1">
		<introducao>O código abaixo, quando executado, produz na saída a
            mensagem <stmt>4.2</stmt>.<java><![CDATA[public class Switch5 {
    public static void main(String[] args) {
        double i = 4.2;
        switch ((int)i) {
        case (byte) 1:
            System.out.println("1");
            break;
        case (short) 2:
            System.out.println("2");
        case (int) 4:
            System.out.println("4");
        case (char) (.2 + 4):
            System.out.println("4.2");
        }
    }
}]]></java>
		</introducao>
		<resposta valor="f">O código não compila. Observe que há
            duplicação do rótulo de <stmt>case</stmt>. Afinal,
            <stmt>(char)(.2+4)</stmt> e <stmt>(int)4</stmt> referem-se
            ao mesmo valor constante <stmt>4</stmt> do tipo <stmt>int</stmt>.</resposta>
	</questao>
	<questao id="1809" objetivo="2.1">
		<introducao>O argumento de um <stmt>cae</stmt> pode ser uma
            variável, desde que seja declarada <stmt>final</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1810" objetivo="2.1">
		<introducao>O código abaixo não compila.<java><![CDATA[public class Switch6 {
    private static int i = 0;

    private void Switch() {
        switch (i) {
        case 0:
            i = i + 1;
        case 1:
            i = i + 2;
        case 2:
            i = i + 3;
        }
    }

    public static void main(String[] args) {
        new Switch6().Switch();
        new Switch6().Switch();
        System.out.println(i);
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1811" objetivo="2.1">
		<introducao>O código abaixo, quando executado, exibe o valor <stmt>3</stmt>.<java><![CDATA[public class Switch6 {
    private static int i = 0;

    private void Switch() {
        switch (i) {
        case 0:
            i = i + 1;
        case 1:
            i = i + 2;
        case 2:
            i = i + 3;
        }
    }

    public static void main(String[] args) {
        new Switch6().Switch();
        new Switch6().Switch();
        System.out.println(i);
    }
}]]></java>
		</introducao>
		<resposta valor="f">Observe que a variável <stmt>i</stmt> é
            <stmt>static</stmt> (variável de classe) e que, de forma
            &quot;enganosa&quot;, nenhum <stmt>case</stmt> da sentença
            <stmt>switch</stmt> possui um <stmt>break</stmt>. Em
            conseqüência, quando há o casamento de um valor, todas as
            sentenças <stmt>case</stmt> que seguem são executadas.</resposta>
	</questao>
	<questao id="1812" objetivo="2.1">
		<introducao>O código abaixo, quando executado, exibe o valor <stmt>6</stmt>.<java><![CDATA[public class Switch6 {
    private static int i = 0;

    private void Switch() {
        switch (i) {
        case 0:
            i = i + 1;
        case 1:
            i = i + 2;
        case 2:
            i = i + 3;
        }
    }

    public static void main(String[] args) {
        new Switch6().Switch();
        new Switch6().Switch();
        System.out.println(i);
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1813" objetivo="2.1">
		<introducao>Pode-se afirmar que o trecho de código
            abaixo<java><![CDATA[if (x == 2) {
            x++;
        } else {
            x--;
        }]]></java>é
            equivalente funcional daquele abaixo. Assuma que
            <stmt>x</stmt> é variável do tipo <stmt>int</stmt>.<java><![CDATA[switch ((x == 2) ? 1 : 0) {
        case 1:
            x++;
            break;
        default:
            x--;
        }]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1814" objetivo="2.1">
		<introducao>A sentença <stmt>switch (1) {}</stmt> compila.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1815" objetivo="2.1">
		<introducao>O <stmt>case</stmt> em uma sentença
            <stmt>switch</stmt> indica que o código correspondente deve
            ser executado, quando ocorre um casamento e, após tal
            execução, o bloco <stmt>switch</stmt> é terminado.</introducao>
		<resposta valor="f">O <stmt>case</stmt> é apenas um ponto de
            entrada. A saída é o fim do <stmt>switch</stmt>, que pode
            incluir outros <stmt>case</stmt>, ou até que a sentença
            <stmt>break</stmt> seja executada.</resposta>
	</questao>
	<questao id="1816" objetivo="2.1">
		<introducao>O <stmt>default</stmt> de um bloco
            <stmt>switch</stmt> só é executado caso não ocorra casamento
            da sentença <stmt>case</stmt> com o valor fornecido ao
            bloco. Assuma que todo código associado a todo
            <stmt>case</stmt> é terminado pela execução de um <stmt>break</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1817" objetivo="2.1">
		<introducao>O código abaixo não compila.<java><![CDATA[switch (1) {
        case 2:
            System.out.println("2");
        default:
            System.out.println("default");
        case 25:
            System.out.println("2");
        }]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1818" objetivo="2.1">
		<introducao>A execução do código abaixo produz como resultado <stmt>default25</stmt>.<java><![CDATA[switch (30) {
        case 2:
            System.out.print("2");
        default:
            System.out.print("default");
        case 25:
            System.out.print("2");
        }]]></java>
		</introducao>
		<resposta valor="f">A saída é <stmt>default2</stmt>.</resposta>
	</questao>
	<questao id="1819" objetivo="2.1">
		<introducao>A execução do código abaixo produz como resultado <stmt>default</stmt>.<java><![CDATA[switch (30) {
        case 2:
            System.out.print("2");
        default:
            System.out.print("default");
        case 25:
            System.out.print("2");
        }]]></java>
		</introducao>
		<resposta valor="f">A saída é <stmt>default2</stmt>.</resposta>
	</questao>
	<questao id="1820" objetivo="2.1">
		<introducao>O código abaixo compila.<java><![CDATA[char c = 230;
        switch (c) {
        case 'b':
            System.out.print("2");
        default:
            System.out.print("default");
        case (int) 250:
            System.out.print("2");
        }]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1821" objetivo="2.2">
		<introducao>Java possui três estruturas de iteração:
            <stmt>while</stmt>, <stmt>do-while</stmt> e <stmt>for</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1822" objetivo="2.2">
		<introducao>O código abaixo compila.<java><![CDATA[    public static int f() {
        for (int i = 0; i < 10; i++) ;
        return 1;
    }
]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1823" objetivo="2.2">
		<introducao>O código abaixo compila.<java><![CDATA[    public static int f() {
        for (int i = 0; i < 10; i++) 
        return 1;
    }
]]></java>
		</introducao>
		<resposta valor="f">Observe que falta uma sentença de retorno
            (<stmt>return</stmt>) para o método apresentado. </resposta>
	</questao>
	<questao id="1824" objetivo="2.2">
		<introducao>O código abaixo compila.<java><![CDATA[    public static int f() {
        for (int i = 0; i < 10; i++) {}
        return 1;
    }
]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1825" objetivo="2.2">
		<introducao>O programa abaixo não compila.<java><![CDATA[public class For2 {
    public static void main(String[] args) {
        int i;
        for (i = 0; i < 10; i++) {
            i = (i > 10) ? i  : i % 10;
        }
        System.out.println(i);
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1826" objetivo="2.2">
		<introducao>Quando executado, o programa abaixo exibe na saída o
            valor <stmt>10</stmt>.<java><![CDATA[public class For2 {
    public static void main(String[] args) {
        int i;
        for (i = 0; i < 10; i++) {
            i = (i > 10) ? i  : i % 10;
        }
        System.out.println(i);
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1827" objetivo="2.2">
		<introducao>O programa abaixo não compila.<java><![CDATA[public class For2 {
    public static void main(String[] args) {
        for (int i = 0; i < 10; i++) {
            i = (i > 10) ? i  : i % 10;
        }
        System.out.println(i);
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1828" objetivo="2.2">
		<introducao>Quando executado, o programa abaixo exibe na saída o
            valor <stmt>10</stmt>.<java><![CDATA[public class For2 {
    public static void main(String[] args) {
        for (int i = 0; i < 10; i++) {
            i = (i > 10) ? i  : i % 10;
        }
        System.out.println(i);
    }
}]]></java>
		</introducao>
		<resposta valor="f">O código não compila. Observe que a variável
            <stmt>i</stmt> é declarada apenas no escopo do bloco do <stmt>for</stmt>.</resposta>
	</questao>
	<questao id="1829" objetivo="2.2">
		<introducao>Quando executado, o programa abaixo exibe o valor <stmt>0</stmt>.<java><![CDATA[public class For2 {
    public static void main(String[] args) {
        int i = 0;
        for (int i = 0; i < 10; i++) {
            i = (i > 10) ? i  : i % 10;
        }
        System.out.println(i);
    }
}]]></java>
		</introducao>
		<resposta valor="f">O código não compila. Há tentativa de
            redeclarar a variável <stmt>i</stmt>.</resposta>
	</questao>
	<questao id="1830" objetivo="2.2">
		<introducao>A expressão de teste da sentença <stmt>for</stmt>
            deve ser única, caso exista.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1831" objetivo="2.2">
		<introducao>Nenhuma das três seções de uma sentença
            <stmt>for</stmt> é obrigatória.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1832" objetivo="2.2">
		<introducao>A sentença <stmt>break</stmt> no interior de um
            <stmt>for</stmt>, quando executada, causa a transferência da
            execução para a sentença imediatamente após o <stmt>for</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1833" objetivo="2.2">
		<introducao>Quando um <stmt>return</stmt> é executado no corpo
            de um <stmt>for</stmt>, o controle é transferido para o
            código que chamou o método que contém este <stmt>for</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1834" objetivo="2.2">
		<introducao>Quando a sentença <stmt>System.exit()</stmt> é
            executada no corpo de um <stmt>for</stmt>, a execução do
            programa em questão é interrompida.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1835" objetivo="2.2">
		<introducao>Quando a condição, seção de teste, de um
            <stmt>for</stmt> é avaliada como verdadeira, a seção de
            iteração, a seção mais a direita de um <stmt>for</stmt> só
            não é executada caso o <stmt>for</stmt> seja finalizado de
            forma abrupta, por exemplo, por uma exceção, ou por um
            <stmt>break</stmt>, ou um <stmt>return</stmt> ou execução de <stmt>System.exit()</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1836" objetivo="2.2">
		<introducao>O programa abaixo compila.<java><![CDATA[public class For3 {
    public static void main(String[] args) {
        for (
        int i = 0;
        i < 1;
        System.out.println(new int[]{1, 2}[++i])
        )
        return;
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1837" objetivo="2.2">
		<introducao>O programa abaixo, quando executado, exibe o valor <stmt>1</stmt>.<java><![CDATA[public class For3 {
    public static void main(String[] args) {
        for (
        int i = 0;
        i < 1;
        System.out.println(new int[]{1, 2}[++i])
        )
        return;
    }
}]]></java>
		</introducao>
		<resposta valor="f">Nenhum valor é exibido. Observe que, quando
            o corpo do <stmt>for</stmt> é executado, a única sentença
            executada é o <stmt>return</stmt>, que interrompe o
            <stmt>for</stmt> e impede que a seção de iteração de ser executada.</resposta>
	</questao>
	<questao id="1838" objetivo="2.2">
		<introducao>O programa abaixo, quando executado, exibe o valor <stmt>2</stmt>.<java><![CDATA[public class For3 {
    public static void main(String[] args) {
        for (
        int i = 0;
        i < 1;
        System.out.println(new int[]{1, 2}[++i])
        )
        return;
    }
}]]></java>
		</introducao>
		<resposta valor="f">Nenhum valor é exibido. Observe que, quando
            o corpo do <stmt>for</stmt> é executado, a única sentença
            executada é o <stmt>return</stmt>, que interrompe o
            <stmt>for</stmt> e impede que a seção de iteração de ser executada.</resposta>
	</questao>
	<questao id="1839" objetivo="2.2">
		<introducao>O programa abaixo, quando executado, gera uma
            exceção: <stmt>ArrayIndexOutOfBoundsException</stmt>.<java><![CDATA[public class For3 {
    public static void main(String[] args) {
        for (
        int i = 0;
        i < 1;
        System.out.println(new int[]{1, 2}[++i])
        )
        return;
    }
}]]></java>
		</introducao>
		<resposta valor="f">Observe que, quando o corpo do
            <stmt>for</stmt> é executado, a única sentença executada é o
            <stmt>return</stmt>, que interrompe o <stmt>for</stmt> e
            impede que a seção de iteração de ser executada.</resposta>
	</questao>
	<questao id="1840" objetivo="2.2">
		<introducao>Um <stmt>break</stmt>   no interior do corpo de um
            <stmt>for</stmt> interrompe toda a iteração, enquanto um
            <stmt>continue</stmt> apenas a iteração corrente.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1841" objetivo="2.2">
		<introducao>A sentença <stmt>break</stmt> pode ser fornecida em
            uma iteração (corpo) ou em uma sentença <stmt>switch</stmt>,
            ao passo que um <stmt>continue</stmt> está restrita a uma iteração.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1842" objetivo="2.2">
		<introducao>O valor impresso pela execução do programa abaixo é <stmt>11</stmt>.<java><![CDATA[public class For4 {
    public static void main(String[] args) {
        int i;
        for (i = 1; i <= 10; i++) {
            if (i > 3) {
                i = 11;
                continue;
            }
        }
        System.out.println(i);
    }
}]]></java>
		</introducao>
		<resposta valor="f">A sentença <stmt>continue</stmt> interrompe
            a iteração corrente, mas não exclui a expressão de iteração
            (terceira seção do <stmt>for</stmt>) de ser executada. Em
            conseqüência, após depositar o valor <stmt>11</stmt> na
            variável correspondente, esta mesma variável é incrementada
            de uma unidade, resultado no valor <stmt>12</stmt>.</resposta>
	</questao>
	<questao id="1843" objetivo="2.2">
		<introducao>O valor impresso pela execução do programa abaixo é <stmt>12</stmt>.<java><![CDATA[public class For4 {
    public static void main(String[] args) {
        int i;
        for (i = 1; i <= 10; i++) {
            if (i > 3) {
                i = 11;
                continue;
            }
        }
        System.out.println(i);
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1844" objetivo="2.2">
		<introducao>A execução do programa abaixo produz como resultado <stmt>5</stmt>.<java><![CDATA[public class For5 {
    public static void main(String[] args) {
        int x = 1;
        int i = 1;
        int j = 1;
        externo:
        for (; i < 2; i++) {
            for (; j < 3; j++) {
                x++;
                continue externo;
            }
        }

        System.out.println(x + i + j);
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1845" objetivo="2.2">
		<introducao>A execução do programa abaixo produz como resultado <stmt>6</stmt>.<java><![CDATA[public class For5 {
    public static void main(String[] args) {
        int x = 1;
        int i = 1;
        int j = 1;
        externo:
        for (; i < 2; i++) {
            for (; j < 3; j++) {
                x++;
                continue externo;
            }
        }

        System.out.println(x + i + j);
    }
}]]></java>
		</introducao>
		<resposta valor="f">O valor produzido é <stmt>5</stmt>. A
            sentença <stmt>continue</stmt>, quando executada com um
            rótulo, provoca a execução exclusiva da seção de iteração do
            laço rotulado, em detrimento dos demais que possam existir.
            Dessa forma, o valor final na variável <stmt>j</stmt> é
            <stmt>1</stmt>, ao contrário de <stmt>2</stmt>, como muitos
            podem interpretar.</resposta>
	</questao>
	<questao id="1846" objetivo="2.2">
		<introducao>O valor exibido como resultado da execução do
            programa abaixo é <stmt>13</stmt>.<java><![CDATA[public class For6 {
    public static void main(String[] args) {
        int valor = 1;
        int i = 1;
        int j = 1;
        int k = 1;
        saida:
        for (; i < 2; i++) {
            for (; j < 3; j++) {
                for (; k < 4; k++) {
                    valor++;
                    continue saida;
                }
            }
        }
        System.out.println(valor + i + j + k);
    }
}]]></java>
		</introducao>
		<resposta valor="f">A sentença <stmt>continue</stmt>, quando
            executada, faz com que a seção de iteração do primeiro laço
            seja executada. Em conseqüência, o valor de <stmt>i</stmt> é
            incrementado de uma unidade, resultando no valor
            <stmt>2</stmt>. A variável <stmt>valor</stmt> também recebe
            o valor <stmt>2</stmt> com o incremento imediatamente antes
            do <stmt>continue</stmt>. Nenhuma seção de iteração é
            executada dos laços mais  internos, o que deixa em
            <stmt>j</stmt> e <stmt>k</stmt> o valor inicial destas
            variáveis. Observe que o <stmt>continue</stmt> não provoca a
            execução das seções de iteração de laços mais internos,
            apenas aquela seção do laço rotulado é executada.</resposta>
	</questao>
	<questao id="1847" objetivo="2.2">
		<introducao>O valor exibido como resultado da execução do
            programa abaixo é <stmt>6</stmt>.<java><![CDATA[public class For6 {
    public static void main(String[] args) {
        int valor = 1;
        int i = 1;
        int j = 1;
        int k = 1;
        saida:
        for (; i < 2; i++) {
            for (; j < 3; j++) {
                for (; k < 4; k++) {
                    valor++;
                    continue saida;
                }
            }
        }
        System.out.println(valor + i + j + k);
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1848" objetivo="2.4">
		<introducao>Quando uma situação excepcional em Java ocorre, uma
            exceção é dita gerada (<it>thrown</it>). O código
            responsável por reagir a tal ocorrência é chamado de
            tratador de exceção (<it>exception handler</it>). Este
            código captura (<it>catch</it>) a exceção gerada.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1849" objetivo="2.4">
		<introducao>Se há um ou mais blocos <stmt>catch</stmt>, então
            este ou estes deve(m) imediatamente seguir o bloco
            <stmt>try</stmt>, sem que haja nenhuma sentença entre eles.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1850" objetivo="2.4">
		<introducao>Um bloco <stmt>try</stmt> seguido de 2 blocos
            <stmt>catch</stmt> pode ter estes blocos <stmt>catch</stmt>,
            necessariamente, dispostos em duas formas distintas.</introducao>
		<resposta valor="f">A ordem dos blocos <stmt>catch</stmt> pode
            ter relevância. Em particular, isto ocorre quando uma das
            exceções a serem capturadas é subclasse da outra.</resposta>
	</questao>
	<questao id="1851" objetivo="2.4">
		<introducao>Um bloco <stmt>finally</stmt> é executado sempre,
            independente de uma exceção ter sido gerada ou não.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1852" objetivo="2.4">
		<introducao>O código abaixo não compila.<java><![CDATA[public class Exception3 {
    public static void main(String[] args) {
        try {
            System.out.println("Ok");
        }
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1853" objetivo="2.4">
		<introducao>O código abaixo compila.<java><![CDATA[public class Exception4 {

    public static void f() {
        String s = null;
        System.out.println(s.toString());
    }

    public static void main(String[] args) {
        try {
            f();
        } finally {
            System.out.println("Exception was thrown in f()");
        }
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1854" objetivo="2.4">
		<introducao>O código abaixo, quando executado, não gera uma exceção.<java><![CDATA[public class Exception4 {

    public static void f() {
        String s = null;
        System.out.println(s.toString());
    }

    public static void main(String[] args) {
        try {
            f();
        } finally {
            System.out.println("Exception was thrown in f()");
        }
    }
}]]></java>
		</introducao>
		<resposta valor="f">A mensagem <stmt>toString()</stmt> enviada
            ao objeto <stmt>s</stmt> gera a exceção
            <stmt>NullPointerException</stmt>. Não há bloco
            <stmt>catch</stmt> que capture a exceção, mas o bloco
            <stmt>finally</stmt> é executado.</resposta>
	</questao>
	<questao id="1855" objetivo="2.4">
		<introducao>O código abaixo, quando executado, gera a exceção
            <stmt>NullPointerException</stmt> e, dado o fato de não
            existir bloco <stmt>catch</stmt> correspondente, a exceção
            gerada é transferida para a MVJ, sem que o programa exiba
            qualquer mensagem.<java><![CDATA[public class Exception4 {

    public static void f() {
        String s = null;
        System.out.println(s.toString());
    }

    public static void main(String[] args) {
        try {
            f();
        } finally {
            System.out.println("Exception was thrown in f()");
        }
    }
}]]></java>
		</introducao>
		<resposta valor="f">A mensagem <stmt>toString()</stmt> enviada
            ao objeto <stmt>s</stmt> gera a exceção
            <stmt>NullPointerException</stmt>. Não há bloco
            <stmt>catch</stmt> que capture a exceção, mas o bloco
            <stmt>finally</stmt> é executado.</resposta>
	</questao>
	<questao id="1856" objetivo="2.4">
		<introducao>O código abaixo não compila.<java><![CDATA[public class Exception5 {
    public static void main(String[] args) {
        try {
            System.out.println("OK");
        } finally {
            System.out.println("Saindo do bloco finally");
        } catch (RuntimeException re) {
        }
    }
}]]></java>
		</introducao>
		<resposta valor="v">O bloco <stmt>catch</stmt>, caso exista,
            deve seguir imediatamente o bloco <stmt>try</stmt>. Nem
            mesmo a sentença <stmt>finally</stmt> pode aparecer antes do <stmt>catch</stmt>.</resposta>
	</questao>
	<questao id="1857" objetivo="2.4">
		<introducao>O código abaixo não compila.<java><![CDATA[public class Exception6 {
    public static void main(String[] args) {
        try {
            return;
            System.out.println("Depois do return ...");
        } finally {
            System.out.println("Saindo do bloco finally");
        }
    }
}]]></java>
		</introducao>
		<resposta valor="v">
			<stmt>Unreachable statement</stmt>.</resposta>
	</questao>
	<questao id="1858" objetivo="2.4">
		<introducao>O código abaixo não compila.<java><![CDATA[public class Exception8 {

    public static void main(String[] args) {
        String s = null;
        try {
            System.out.print(s);
        } catch (RuntimeException rte) {
            System.out.print("1");
        } finally {
            System.out.print("0");
        }
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1859" objetivo="2.4">
		<introducao>O código abaixo, quando executado, gera uma exceção
            capturada pelo bloco <stmt>catch</stmt>.<java><![CDATA[public class Exception8 {

    public static void main(String[] args) {
        String s = null;
        try {
            System.out.print(s);
        } catch (NullPointerException npe) {
            System.out.print("1");
        } finally {
            System.out.print("0");
        }
    }
}]]></java>
		</introducao>
		<resposta valor="f">Observe que nenhuma exceção é gerada. O
            bloco <stmt>try</stmt> irá produzir a mensagem
            <stmt>null</stmt> quando executado.</resposta>
	</questao>
	<questao id="1860" objetivo="2.4">
		<introducao>O código abaixo, quando executado, produz como
            resultado <stmt>null</stmt>.<java><![CDATA[public class Exception8 {

    public static void main(String[] args) {
        String s = null;
        try {
            System.out.print(s);
        } catch (NullPointerException npe) {
            System.out.print("1");
        } finally {
            System.out.print("0");
        }
    }
}]]></java>
		</introducao>
		<resposta valor="f">Sempre o bloco <stmt>finally</stmt> é
            executado, ou seja, a saída produzida é <stmt>null0</stmt>.</resposta>
	</questao>
	<questao id="1861" objetivo="2.4">
		<introducao>A sentença <stmt>try {} catch (Exception e) {}
                finally {}</stmt> compila.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1862" objetivo="2.4">
		<introducao>O código abaixo compila.<java><![CDATA[public class Exception16 {
    static int x = 1;

    public static int f() {
        try {
            x = 1 / ((x = 2) - 2);
        } catch (Exception e) {
            return x;
        } finally {
            x++;
        }
        return x;
    }

    public static void main(String[] args) {
        System.out.println(x + " " + f() + " " + x);
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1863" objetivo="2.4">
		<introducao>O código abaixo, quando executado, não gera uma exceção.<java><![CDATA[public class Exception16 {
    static int x = 1;

    public static int f() {
        try {
            x = 1 / ((x = 2) - 2);
        } catch (Exception e) {
            return x;
        } finally {
            x++;
        }
        return x;
    }

    public static void main(String[] args) {
        System.out.println(x + " " + f() + " " + x);
    }
}]]></java>
		</introducao>
		<resposta valor="f">A sentença <stmt>x = 1 / ((x = 2) -
            2);</stmt> atribui o valor <stmt>2</stmt> à variável
            <stmt>x</stmt> e tenta realizar uma divisão por zero, o que
            gera a exceção <stmt>ArithmeticException</stmt>.</resposta>
	</questao>
	<questao id="1864" objetivo="2.4">
		<introducao>O código abaixo, quando executado, imprime, na saída
            padrão <stmt>1 3 1</stmt>.<java><![CDATA[public class Exception16 {
    static int x = 1;

    public static int f() {
        try {
            x = 1 / ((x = 2) - 2);
        } catch (Exception e) {
            return x;
        } finally {
            x++;
        }
        return x;
    }

    public static void main(String[] args) {
        System.out.println(x + " " + f() + " " + x);
    }
}]]></java>
		</introducao>
		<resposta valor="f">Observe que a única sentença da função
            <stmt>main</stmt> é uma chamada a um método que recebe como
            argumento uma expressão envolvendo a concatenação dos
            valores da variável <stmt>x</stmt> e do método
            <stmt>f()</stmt>. A avaliação desta expressão ocorre da
            esquerda para a direita e, como a chamada à função
            <stmt>f()</stmt> altera o valor de <stmt>x</stmt>, pois o
            bloco <stmt>finally</stmt> sempre é executado, o valor
            impresso na primeira avaliação de <stmt>x</stmt> não
            coincide com o da segunda avaliação.</resposta>
	</questao>
	<questao id="1865" objetivo="2.4">
		<introducao>O código abaixo, quando executado, imprime, na saída
            padrão <stmt>3 3 3</stmt>.<java><![CDATA[public class Exception16 {
    static int x = 1;

    public static int f() {
        try {
            x = 1 / ((x = 2) - 2);
        } catch (Exception e) {
            return x;
        } finally {
            x++;
        }
        return x;
    }

    public static void main(String[] args) {
        System.out.println(x + " " + f() + " " + x);
    }
}]]></java>
		</introducao>
		<resposta valor="f">Observe que a única sentença da função
            <stmt>main</stmt> é uma chamada a um método que recebe como
            argumento uma expressão envolvendo a concatenação dos
            valores da variável <stmt>x</stmt> e do método
            <stmt>f()</stmt>. A avaliação desta expressão ocorre da
            esquerda para a direita e, como a chamada à função
            <stmt>f()</stmt> altera o valor de <stmt>x</stmt>, pois o
            bloco <stmt>finally</stmt> sempre é executado, o valor
            impresso na primeira avaliação de <stmt>x</stmt> não
            coincide com o da segunda avaliação.</resposta>
	</questao>
	<questao id="1866" objetivo="2.4">
		<introducao>O código abaixo, quando executado, imprime, na saída
            padrão <stmt>1 3 3</stmt>.<java><![CDATA[public class Exception16 {
    static int x = 1;

    public static int f() {
        try {
            x = 1 / ((x = 2) - 2);
        } catch (Exception e) {
            return x;
        } finally {
            x++;
        }
        return x;
    }

    public static void main(String[] args) {
        System.out.println(x + " " + f() + " " + x);
    }
}]]></java>
		</introducao>
		<resposta valor="f">Observe que a única sentença da função
            <stmt>main</stmt> é uma chamada a um método que recebe como
            argumento uma expressão envolvendo a concatenação dos
            valores da variável <stmt>x</stmt> e do método
            <stmt>f()</stmt>. A avaliação desta expressão ocorre da
            esquerda para a direita. O valor de <stmt>x</stmt> (mais a
            esquerda) é <stmt>1</stmt>, posteriormente a função
            <stmt>f()</stmt> é executada e, só após esta o valor de
            <stmt>x</stmt> é novamente consultado. Esta segunda consulta
            ao valor de <stmt>x</stmt> irá retornar o valor depositado
            nesta variável após a execução da função <stmt>f()</stmt>.
            Esta função atribui o valor <stmt>2</stmt> a <stmt>x</stmt>
            e, em conseqüência, uma exceção é gerada. Sabe-se que,
            independente de ser gerada, o bloco <stmt>finally</stmt> é
            executado, o que deposita em <stmt>x</stmt> o valor
            <stmt>3</stmt>. Contudo, o valor empregado pela sentença
                <stmt>return x;</stmt> é <stmt>2</stmt>, pois naquele
            momento da execução desta sentença, este era o valor de
            <stmt>x</stmt>, que posteriormente foi incrementado de uma
            unidade. Ou seja, a saída produzida é <stmt>1 2 3</stmt>.</resposta>
	</questao>
	<questao id="1867" objetivo="2.4">
		<introducao>O código abaixo não compila.<java><![CDATA[public class Exception17 {
    public static void main(String[] args) {
        String s = null;
        if (s.equals("null")) {
            System.out.println(s);
        }
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1868" objetivo="2.4">
		<introducao>O código abaixo, quando executado, gera uma exceção.<java><![CDATA[public class Exception17 {
    public static void main(String[] args) {
        String s = null;
        if (s.equals("null")) {
            System.out.println(s);
        }
    }
}]]></java>
		</introducao>
		<resposta valor="v">Observe que o valor de <stmt>s</stmt> é
            <stmt>null</stmt> no momento em que é tentado o envio da
            mensagem <stmt>equals(&quot;null&quot;)</stmt> para o
            suposto objeto referenciado por <stmt>s</stmt>. Em
            conseqüência, a exceção <stmt>NullPointerException</stmt> é gerada.</resposta>
	</questao>
	<questao id="1869" objetivo="2.4">
		<introducao>O código abaixo, quando executado, gera como
            resultado a saída <stmt>null</stmt>.<java><![CDATA[public class Exception17 {
    public static void main(String[] args) {
        String s = null;
        if (s.equals("null")) {
            System.out.println(s);
        }
    }
}]]></java>
		</introducao>
		<resposta valor="f">Observe que o valor de <stmt>s</stmt> é
            <stmt>null</stmt> no momento em que é tentado o envio da
            mensagem <stmt>equals(&quot;null&quot;)</stmt> para o
            suposto objeto referenciado por <stmt>s</stmt>. Em
            conseqüência, a exceção <stmt>NullPointerException</stmt> é gerada.</resposta>
	</questao>
	<questao id="1870" objetivo="2.4">
		<introducao>O código abaixo, quando executado, gera como saída
            duas sentenças <stmt>null</stmt>, uma em cada linha.<java><![CDATA[public class Exception17 {
    public static void main(String[] args) {
        String s = null;
        System.out.println(s);
        if (s.equals("null")) {
            System.out.println(s);
        }
    }
}]]></java>
		</introducao>
		<resposta valor="f">Observe que o valor de <stmt>s</stmt> é
            <stmt>null</stmt> no momento em que é tentado o envio da
            mensagem <stmt>equals(&quot;null&quot;)</stmt> para o
            suposto objeto referenciado por <stmt>s</stmt>. Em
            conseqüência, a exceção <stmt>NullPointerException</stmt> é
            gerada. Ou seja, apenas uma sentença <stmt>null</stmt> é
            impressa antes da exceção ser gerada.</resposta>
	</questao>
	<questao id="1871" objetivo="2.4">
		<introducao>Quando um bloco <stmt>try</stmt> é executado e este
            possui um bloco <stmt>finally</stmt>, o bloco
            <stmt>finally</stmt> sempre é executado, mesmo que nenhuma
            exceção seja gerada. Caso uma exceção seja gerada e tratada,
            o bloco <stmt>finally</stmt> também é executado após o
            código do bloco <stmt>try</stmt> e, eventualmente, o código
            do bloco <stmt>catch</stmt> correspondente, mesmo que haja
            uma sentença <stmt>return</stmt> em algum destes blocos. Em
            outras palavras, o bloco <stmt>finally</stmt> é executado
            mesmo após a execução de um <stmt>return</stmt> que é parte
            de um bloco <stmt>catch</stmt> correspondente.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1872" objetivo="2.4">
		<introducao>A sentença <stmt>try</stmt> abaixo, quando
            executada, fornece como retorno o valor <stmt>1</stmt>.<java><![CDATA[try {
            x = 1;
            return x;
        } catch (Exception e) {
            return x;
        } finally {
            x++;
        }]]></java>
		</introducao>
		<resposta valor="v">Observe que após o <stmt>return</stmt> o
            bloco <stmt>finally</stmt> é executado. Ou seja, embora o
            retorno seja <stmt>1</stmt>, o valor depositado na variável
            <stmt>x</stmt> é <stmt>2</stmt>.</resposta>
	</questao>
	<questao id="1873" objetivo="2.4">
		<introducao>A sentença <stmt>try</stmt> abaixo, quando
            executada, fornece como retorno o valor <stmt>2</stmt>.<java><![CDATA[try {
            x = 1;
            return x;
        } catch (Exception e) {
            return x;
        } finally {
            x++;
        }]]></java>
		</introducao>
		<resposta valor="f">Observe que após o <stmt>return</stmt> o
            bloco <stmt>finally</stmt> é executado. Ou seja, embora o
            retorno seja <stmt>1</stmt>, o valor depositado na variável
            <stmt>x</stmt> é <stmt>2</stmt>.</resposta>
	</questao>
	<questao id="1874" objetivo="2.4">
		<introducao>O bloco <stmt>finally</stmt> é obrigatório quando na
            presença de um bloco <stmt>catch</stmt>.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1875" objetivo="2.4">
		<introducao>Um bloco <stmt>try</stmt> pode ser imediatamente
            seguido de um bloco <stmt>finally</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1876" objetivo="2.4">
		<introducao>Uma exceção gerada por um método <stmt>M()</stmt> e
            não tratada por este é propagada para o método que chamou o
            método <stmt>M()</stmt> e assim por diante até que um método
            trate a exceção. Se nenhum método trata uma determinada
            exceção, nem mesmo o método <stmt>main</stmt>, então esta
            será propagada para a MVJ, o que causará o fim da execução
            do programa e da MVJ, após uma indicação de qual a exceção gerada.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1877" objetivo="2.4">
		<introducao>Em Java, toda exceção é uma instância de uma classe
            derivada da classe <stmt>java.lang.Exception</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1878" objetivo="2.4">
		<introducao>Quando uma exceção é gerada, uma instância de uma
            classe derivada de <stmt>java.lang.Exception</stmt> é
            criada. Este objeto é então passado para a cláusula
            <stmt>catch</stmt> como argumento.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1879" objetivo="2.4">
		<introducao>Um objeto que representa uma exceção, assim como
            qualquer outro objeto, pode receber mensagens.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1880" objetivo="2.4">
		<introducao>A classe ancestral de <stmt>Exception</stmt> é a
            classe <stmt>Throwable</stmt>, que herda da classe
            <stmt>Object</stmt>. <stmt>Throwable</stmt> possui duas
            subclasses definidas na biblioteca Java:
            <stmt>Exception</stmt> e <stmt>Error</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1881" objetivo="2.4">
		<introducao>Uma instância de <stmt>java.lang.Error</stmt>
            representa uma situação da qual, em geral, não há como ser
            recuperada para um estado a partir do qual o programa pode
            continuar a sua execução. Em conseqüência, não é exigida o
            tratamento deste tipo de exceção.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1882" objetivo="2.4">
		<introducao>Uma instância de <stmt>Error</stmt> não é
            tecnicamente uma exceção por não derivar da classe <stmt>Exception</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1883" objetivo="2.4">
		<introducao>Ao contrário de instâncias de <stmt>Error</stmt>,
            instâncias de <stmt>RuntimeException</stmt>representam erros
            contidos no programa.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1884" objetivo="2.4">
		<introducao>
			<stmt>RuntimeException</stmt> é derivada de
            <stmt>Exception</stmt>, que é derivada de
            <stmt>Throwable</stmt>, que é derivada de
            <stmt>Object</stmt>, todas estas pertencem ao pacote <stmt>java.lang</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1885" objetivo="2.4">
		<introducao>Mais de um tipo de exceção pode ser capturado por
            uma única cláusula <stmt>catch</stmt>, o que é possível
            através de uma classe fornecida como argumento que possui
            subclasses. Neste caso, esta cláusula irá capturar todas as
            exceções representadas por instâncias da classe fornecida e
            de todas as subclasses desta.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1886" objetivo="2.4">
		<introducao>Se o argumento de uma cláusula <stmt>catch</stmt> é
            uma classe que não possui subclasses, então esta cláusula só
            será capaz de capturar exceções do tipo classe fornecido.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1887" objetivo="2.4">
		<introducao>Todo método que gera uma exceção
            (<stmt>throw</stmt>), deve declarar a exceção gerada, exceto
            quando a exceção gerada é uma subclasse de <stmt>RuntimeException</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1888" objetivo="2.4">
		<introducao>Quando um método declara que gera
            (<stmt>throws</stmt>) uma exceção, isto não significa que,
            necessariamente, sempre o método irá gerar esta exceção.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1889" objetivo="2.4">
		<introducao>A declaração do método <stmt>void f() throws
                ExcecaoTemporal {}</stmt> estabelece que
            <stmt>f()</stmt> não recebe nenhum argumento, retorna
            <stmt>void</stmt>. Embora o corpo deste método não gere
            nenhuma exceção, a declaração estabelece que o código que
            faz uso deste método deve colocá-lo, necessariamente em um
            bloco <stmt>try</stmt> caso <stmt>ExcecaoTemporal</stmt> não
            seja uma classe derivada de <stmt>RuntimeException</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1890" objetivo="2.4">
		<introducao>Todo método que pode gerar uma exceção
            (<stmt>throw</stmt>) deve declarar a exceção
            (<stmt>throws</stmt>), exceto quando a exceção gerada é
            derivada de <stmt>RuntimeException</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1891" objetivo="2.4">
		<introducao>Toda exceção que não é derivada de
            <stmt>RuntimeException</stmt> é considerada uma exceção
            verificada ou, em inglês, <it>checked exception</it>. Isto
            porque o compilador irá verificar se o código que faz uso de
            código que gera tais exceções está ciente da possibilidade
            da ocorrência delas. Nestes casos, para que não ocorra um
            erro em tempo de compilação, há duas opções. Um fazer uso
            deste código no interior de um bloco <stmt>try</stmt> e
            capturar tais exceções ou simplesmente &quot;passá-las&quot;
            adiante através da declaração <stmt>throws</stmt> do método
            em questão.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1892" objetivo="2.4">
		<introducao>Todo método deve, obrigatoriamente, tratar todas as
            exceções verificadas (<it>checked exceptions</it>) que podem
            ocorrer em decorrência do código escrito, ou listar tais
            exceções através da cláusula <stmt>throws</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1893" objetivo="2.4">
		<introducao>Se código de um método pode gerar uma exceção
            verificada (<it>checked exception</it>) e não declara tal
            exceção via <stmt>throws</stmt>, então pode-se afirmar que,
            caso este método possa ser compilado satisfatoriamente, há
            uma cláusula <stmt>catch</stmt> para cada uma das exceções
            que podem ser geradas.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1894" objetivo="2.4">
		<introducao>
			<stmt>RuntimeException</stmt>, <stmt>Error</stmt> e todas as
            subclasses destas classes não precisam ser declaradas nos
            métodos nas quais podem ser geradas ou tratadas no código
            destes métodos. Isto é conseqüência de serem exceções não
            verificadas ou, em inglês, <it>unchecked exceptions</it>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1895" objetivo="2.4">
		<introducao>Todas as exceções que não são verificadas,
                <it>unchecked exceptions</it>, são as instâncias das
            classes <stmt>RuntimeException</stmt> ou <stmt>Error</stmt>,
            juntamente com todas as subclasses destas duas classes.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1896" objetivo="2.4">
		<introducao>Exceções do tipo <stmt>Error</stmt> não são
            verificadas porque, quando geradas, a recuperação  é muito
            difícil ou simplesmente impossível.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1897" objetivo="2.4">
		<introducao>Embora representem situações excepcionais, objetos
            do tipo <stmt>Error</stmt> não são objetos do tipo <stmt>Exception</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1898" objetivo="2.4">
		<introducao>O código abaixo compila.<java><![CDATA[public class Exception19 {
    class ErroTemporal extends Exception {}
    public static void f() throws ErroTemporal {}
}

class Teste {
    public static void main(String[] args) {
        new Exception19().f();
    }
}]]></java>
		</introducao>
		<resposta valor="f">O método <stmt>f()</stmt> gera uma exceção
            verificada (<it>checked exception</it>) identificada por
            <stmt>Exception19.ErroTemporal</stmt>. Esta exceção não é
            declarada no método <stmt>main</stmt> nem capturada via
            <stmt>catch</stmt> por este método.</resposta>
	</questao>
	<questao id="1899" objetivo="2.4">
		<introducao>O código abaixo compila.<java><![CDATA[public class Exception19 {
    class ErroTemporal extends Exception {}
    public static void f() throws ErroTemporal {}
}

class Teste {
    public static void main(String[] args) throws Exception {
        new Exception19().f();
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1900" objetivo="2.4">
		<introducao>O código abaixo compila.<java><![CDATA[public class Exception19 {
    class ErroTemporal extends Exception {}
    public static void f() throws Error {}
}

class Teste {
    public static void main(String[] args) {
        new Exception19().f();
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1901" objetivo="2.5">
		<introducao>A sentença <stmt>assert</stmt> foi introduzida na
            linguagem Java a partir da versão 1.4</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1902" objetivo="2.5">
		<introducao>O emprego de <stmt>assert</stmt> envolve a definição
            de uma condição que sempre se assume ser verdadeira.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1903" objetivo="2.5">
		<introducao>O código abaixo não compila.<java><![CDATA[public class Assertion1 {
    public static void main(String[] args) {
        assert(1 == 1);
        assert false;
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1904" objetivo="2.5">
		<introducao>A sentença <stmt>assert false;</stmt> e <stmt>assert
            (false);</stmt> são legais e equivalentes.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1905" objetivo="2.5">
		<introducao>A sentença <stmt>assert (false);</stmt> gera
            (<it>throw</it>) uma instância de <stmt>AssertionError</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1906" objetivo="2.5">
		<introducao>
			<stmt>AssertionError</stmt> é classe derivada de
            <stmt>Error</stmt> e, portanto, representa uma exceção não
            verificada (<it>unchecked exception</it>).</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1907" objetivo="2.5">
		<introducao>O código abaixo não compila.<java><![CDATA[public class Assertion1 {
    public static void main(String[] args) {
        assert 1 == 1;
        assert false : "Sempre falsa!";
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1908" objetivo="2.5">
		<introducao>A sentença <stmt>int assert = 1;</stmt> compila caso
            seja empregada uma versão anterior a versão 1.4</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1909" objetivo="2.5">
		<introducao>A palavra <stmt>assert</stmt> pode ser empregada, em
            uma mesma classe, como identificador e palavra reservada.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1910" objetivo="2.5">
		<introducao>A palavra <stmt>assert</stmt> pode ser empregada
            como palavra reservada ou como identificador.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1911" objetivo="2.5">
		<introducao>Para que <stmt>assert</stmt> seja tratada como
            palavra reservada é necessário que explicitamente o
            compilador seja informado.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1912" objetivo="2.5">
		<introducao>Ao compilar código que usa a palavra
            <stmt>assert</stmt>, esta será tratada como identificador,
            caso o compilador não seja explicitamente informado através
            do flag <stmt>-source 1.4</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1913" objetivo="2.5">
		<introducao>Ao compilar código com o flag <stmt>-source
            1.4</stmt> o compilador irá tratar <stmt>assert</stmt> como
            uma palavra reservada.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1914" objetivo="2.5">
		<introducao>Quando se compila código que não emprega o flag
                <stmt>-source 1.4</stmt> a palavra <stmt>assert</stmt> é
            tratada como um identificador legítimo.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1915" objetivo="2.5">
		<introducao>Código compilado com o flag <stmt>-source 1.4</stmt>
            necessariamente irá executar as sentenças
            <stmt>assert</stmt> que existirem neste código, quando executado.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1916" objetivo="2.5">
		<introducao>Para que o efeito de uma sentença
            <stmt>assert</stmt> seja observado em tempo de execução é
            suficiente que o código seja compilado com o flag
                <stmt>-source 1.4</stmt>.</introducao>
		<resposta valor="f">É preciso habilitar o emprego de
            <stmt>assert</stmt> com o flag <stmt>-ea</stmt> ou
            <stmt>-enableassertions</stmt> quando a MVJ é executada.</resposta>
	</questao>
	<questao id="1917" objetivo="2.5">
		<introducao>O flag <stmt>-ea</stmt> deve ser fornecido ao
            compilador Java para que as sentenças <stmt>assert</stmt>
            sejam consideradas durante a execução do código a ser compilado.</introducao>
		<resposta valor="f">Este flag é empregado quando se executa a MVJ.</resposta>
	</questao>
	<questao id="1918" objetivo="2.5">
		<introducao>O comportamento padrão da MVJ, quando executada, é
            desconsiderar toda sentença <stmt>assert</stmt> que o código
            a ser executado possua.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1919" objetivo="2.5">
		<introducao>Para que a MVJ considere as sentenças
            <stmt>assert</stmt> presentes em um arquivo contendo
            <it>bytecodes</it> é necessário que seja fornecido o flag
            <stmt>-ea</stmt> ou <stmt>-enableassertions</stmt> para a MVJ.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1920" objetivo="2.5">
		<introducao>É desnecessário o emprego do flag <stmt>-da</stmt>
            quando se executa a MVJ, pois este flag desabilita recurso
            que, por comportamento padrão está desabilitado.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1921" objetivo="2.5">
		<introducao>Para compilar código que faz uso de
            <stmt>assert</stmt> como palavra reservada deve-se empregar
            o flag <stmt>-source 1.4</stmt> ao fazer uso do compilador
            Java. Para executar código que emprega <stmt>assert</stmt>
            como palavra reservada e que deve considerar a execução das
            sentenças correspondentes, a MVJ deve ser executada com o
            flag <stmt>-ea</stmt> ou <stmt>-enableassertions</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1922" objetivo="2.5">
		<introducao>Para desabilitar a execução de sentenças que fazem
            uso de <stmt>assert</stmt> como palavra reservada, a MVJ
            pode ser chamada com o flag <stmt>-disableassertions</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1923" objetivo="2.5">
		<introducao>Caso o flag <stmt>-ea</stmt> ou o flag
            <stmt>-enableassertions</stmt> não tenha sido empregado ao
            executar a MVJ, então necessariamente as eventuais sentenças
            que fizerem uso de <stmt>assert</stmt> não serão consideradas.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1924" objetivo="2.5">
		<introducao>Deve-se empregar <stmt>assert</stmt> para validar
            argumentos fornecidos a um método <stmt>public</stmt>.</introducao>
		<resposta valor="f">Embora legal, não é apropriado ou correto.</resposta>
	</questao>
	<questao id="1925" objetivo="2.5">
		<introducao>Se um argumento ilegal é fornecido a um método
            <stmt>public</stmt>, então tratar este caso com a geração de
            uma exceção como <stmt>IllegalArgumentException</stmt> é
            aconselhado, em vez de fazer uso de <stmt>assert</stmt> para
            se assegurar de que os argumentos são válidos.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1926" objetivo="2.5">
		<introducao>Deve-se usar <stmt>assert</stmt> para validar
            argumentos fornecidos para métodos declarados <stmt>private</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1927" objetivo="2.5">
		<introducao>Não se deve empregar <stmt>assert</stmt> para
            validar argumentos fornecidos na linha de comandos.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1928" objetivo="2.5">
		<introducao>É aconselhado empregar <stmt>assert</stmt> para
            validar argumentos fornecidos a métodos declarados <stmt>private</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1929" objetivo="2.5">
		<introducao>Use <stmt>assert</stmt>, mesmo em métodos declarados
            <stmt>public</stmt>, para verificar situações que jamais
            deveriam ocorrer.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1930" objetivo="2.5">
		<introducao>É admissível o emprego de <stmt>assert</stmt> em um
            método declarado <stmt>public</stmt> para verificar uma
            determinada situação que jamais deveria ocorrer.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1931" objetivo="2.5">
		<introducao>Uma sentença <stmt>assert</stmt> não deve causar
            nenhum efeito colateral.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1932" objetivo="2.5">
		<introducao>A sentença <stmt>assert (f());</stmt> só é
            admissível quando o método <stmt>f()</stmt> não altera o
            estado de nenhum objeto do programa, ou seja, a sua execução
            ou não é indiferente para o programa em questão.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1933" objetivo="2.5">
		<introducao>A sentença <stmt>assert (f());</stmt> não é adequada
            quando o método fornecido como argumento altera o estado da
            aplicação em questão. Isto porque, neste caso, o programa
            pode se comportar de forma diferente, conforme o emprego ou
            não do flag <stmt>-ea</stmt> ou
            <stmt>-enableassertions</stmt>. Caso nenhum destes flags
            seja empregado, o método <stmt>f()</stmt>, que altera o
            estado da aplicação, não será executado. Se um destes flags
            for empregado, o método será executado. Portanto, este
            cenário só é admissível quando o método <stmt>f()</stmt> não
            provoca nenhum efeito colateral.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1934" objetivo="6.1">
		<introducao>Quando se cria uma classe <stmt>A</stmt>, deve-se
            ter em mente que esta classe será usada por muitas outras.
            Em conseqüência, encapsular os serviços oferecidos é
            imprescindível para que a manutenção e evolução da classe
            possa ser assegurada sem afetar o código que faz uso de <stmt>A</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1935" objetivo="6.1">
		<introducao>Variáveis de instância e inclusive variáveis de
            classe devem ser mantidas protegidas, ou seja, devem ser
            declaradas <stmt>private</stmt>, idealmente.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1936" objetivo="6.1">
		<introducao>É prática aconselhável a criação de métodos de
            acesso públicos aos serviços oferecidos por uma classe e
            apenas para estes serviços. Todo cliente de uma classe
            deveria ser forçado a usar tais métodos.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1937" objetivo="6.1">
		<introducao>Uma convenção adequada que deveria ser seguida
            quando se cria uma classe e se deseja oferecer acesso às
            propriedades da classe é empregada pela convenção de nomes
            seguida pela construção de JavaBeans. Ou seja, para uma
            propriedade <stmt>nome</stmt>, que deve ser declarada como
            <stmt>private</stmt>, dois métodos devem ser definidos:
            <stmt>setNome</stmt> e <stmt>getNome</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1938" objetivo="6.1">
		<introducao>Dados de uma classe, ou propriedade que estabelecem
            o estado dos objetos correspondentes devem ser declarados
            <stmt>private</stmt>. Todo acesso a estes dados, por classes
            que usam esta classe, deve ser feito exclusivamente através
            de métodos <stmt>get</stmt> e métodos <stmt>set</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1939" objetivo="6.1">
		<introducao>Deve-se priorizar o acesso aos serviços oferecidos
            por uma classe através de métodos, em vez do acesso direto a
            variáveis de instância.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1940" objetivo="6.1">
		<introducao>Em Java, a palavra reservada <stmt>extends</stmt> é
            empregada para denotar o relacionamento é-um ou herança.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1941" objetivo="6.2">
		<introducao>Um método pode ser sobrecarregado
            (<it>overloaded</it>) e sobreposto (<it>overridden</it>).</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1942" objetivo="6.2">
		<introducao>Não há sobreposição de construtor.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1943" objetivo="6.2">
		<introducao>Pode haver sobrecarga de construtor.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1944" objetivo="6.2">
		<introducao>Sobrecarga de método ou construtor permite que um
            mesmo nome de método ou construtor seja empregado com
            diferentes argumentos.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1945" objetivo="6.2">
		<introducao>Sobreposição permite a redefinição de método, que
            não inclui construtores, em uma subclasse, quando a
            subclasse precisa oferecer um comportamento específico.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1946" objetivo="6.2">
		<introducao>Sempre que uma classe herda um método, existe a
            oportunidade de sobrepor o método herdado, exceto quando o
            método é declarado <stmt>final</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1947" objetivo="6.2">
		<introducao>Uma classe concreta, que herda de uma classe
            abstrata, necessariamente sobrepõe os métodos abstratos da
            classe herdada.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1948" objetivo="6.2">
		<introducao>Pode-se dizer que métodos abstratos são aqueles
            cujas classes concretas, eventualmente criadas
            necessariamente, terão que implementá-los, noutras palavras,
            deverá haver sobreposição destes métodos abstratos.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1949" objetivo="6.2">
		<introducao>Métodos abstratos são sobrepostos quando implementados.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1950" objetivo="6.2">
		<introducao>Quando se emprega uma referência para um objeto de
            uma classe <stmt>C</stmt>, o compilador só irá permitir que
            métodos da classe <stmt>C</stmt> sejam invocados com tal referência.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1951" objetivo="6.2">
		<introducao>O compilador sempre se orienta pelos métodos da
            classe que é o tipo da referência, e não pelos métodos que
            podem ser enviados ao objeto que está sendo referenciado por
            esta referência.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1952" objetivo="6.2">
		<introducao>Não é permitido a sobreposição de um método por
            outro cujo modificador de acesso é mais restritivo.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1953" objetivo="6.2">
		<introducao>Seja <stmt>f</stmt> um método que é sobreposto por
            outro método, necessariamente de nome <stmt>f</stmt>. Em
            conseqüência, ambos os métodos possuem a mesma lista de argumentos.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1954" objetivo="6.2">
		<introducao>Dados dois métodos em que um delos sobrepõe o outro,
            pode-se afirmar que o tipo de retorno de ambos é o mesmo.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1955" objetivo="6.2">
		<introducao>Dados dois métodos em que um deles sobrepõe o outro,
            pode-se afirmar que o método que sobrepõe o outro tem
            modificador de acesso semelhante ou menos restritivo que
            aquele do método sobreposto.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1956" objetivo="6.2">
		<introducao>Se um método sobrepõe outro, então ele pode ter um
            modificador de acesso menos restritivo que aquele do método
            que é sobreposto.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1957" objetivo="6.2">
		<introducao>O modificador de acesso de um método que é
            sobreposto necessariamente deve ser o mesmo do método que o sobrepõe.</introducao>
		<resposta valor="f">Não pode ser mais restritivo, mas pode ser
            menos restritivo ou o mesmo.</resposta>
	</questao>
	<questao id="1958" objetivo="6.2">
		<introducao>Um método que sobrepõe outro não pode declarar uma
            nova exceção ou exceções verificadas mais abrangentes que
            aquelas do método sobreposto.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1959" objetivo="6.2">
		<introducao>Um método que sobrepõe outro não necessariamente
            precisa declarar as mesmas exceções que podem ser geradas
            pelo método sobreposto.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1960" objetivo="6.2">
		<introducao>Um método que sobrepõe outro não necessariamente
            precisa declarar exceções, mesmo que o método sobreposto as declare.</introducao>
		<resposta valor="v">Um método que aceita riscos, não
            necessariamente significa que as sobreposições deste também
            precisam aceitá-los. Tais riscos ou exceções podem ser
            simplesmentes tratadas no interior das sobreposições.</resposta>
	</questao>
	<questao id="1961" objetivo="6.2">
		<introducao>Não pode haver sobreposição de método declarado <stmt>final</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1962" objetivo="6.2">
		<introducao>Não pode haver sobreposição de método declarado
            <stmt>private</stmt>, pois tais métodos não podem ser herdados.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1963" objetivo="6.2">
		<introducao>Sobreposição só existe quando também existe herança.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1964" objetivo="6.2">
		<introducao>Sobrecarga só existe quando também existe herança.</introducao>
		<resposta valor="f">Em uma mesma classe, tanto métodos quanto
            construtores podem ser sobrecarregados.</resposta>
	</questao>
	<questao id="1965" objetivo="6.2">
		<introducao>Não é possível sobreposição sem herança.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1966" objetivo="6.2">
		<introducao>Sem herança não há sobreposição.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1967" objetivo="6.2">
		<introducao>Há sobrecarga sem herança.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1968" objetivo="6.2">
		<introducao>Sem herança não há sobrecarga.</introducao>
		<resposta valor="f">Sobrecarga refere-se ao emprego de um mesmo
            identificador para métodos e/ou construtores de uma mesma classe.</resposta>
	</questao>
	<questao id="1969" objetivo="6.2">
		<introducao>Não é possível sobreposição de método que não se
            pode herdar. </introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1970" objetivo="6.2">
		<introducao>A saída produzida pela execução do programa abaixo é
            um valor equivalente a <stmt>(float)0.0</stmt>
			<java><![CDATA[public class TestaFerrari {
    public static void main(String[] args) {
        Ferrari f = new Ferrari();
        System.out.println(f.getVelocidadeMaxima());
    }
}

class Carro {
    private float velocidadeMaxima;

    private float getVelocidadeMaxima() {
        return velocidadeMaxima;
    }
}

class Ferrari extends Carro {}]]></java>
		</introducao>
		<resposta valor="f">O código não compila. O método
            <stmt>getVelocidadeMaxima()</stmt> é <stmt>private</stmt> e,
            em conseqüência, não é herdado pela classe <stmt>Ferrari</stmt>.</resposta>
	</questao>
	<questao id="1971" objetivo="6.2">
		<introducao>O código abaixo, quando executado, gera uma exceção.<java><![CDATA[public class TestaFerrari {
    public static void main(String[] args) {
        Ferrari f = new Ferrari();
        System.out.println(f.getVelocidadeMaxima());
    }
}

class Carro {
    private float velocidadeMaxima;

    private float getVelocidadeMaxima() {
        return velocidadeMaxima;
    }
}

class Ferrari extends Carro {}]]></java>
		</introducao>
		<resposta valor="f">O código não compila. O método
            <stmt>getVelocidadeMaxima()</stmt> é <stmt>private</stmt> e,
            em conseqüência, não é herdado pela classe <stmt>Ferrari</stmt>.</resposta>
	</questao>
	<questao id="1972" objetivo="6.2">
		<introducao>Se uma classe <stmt>A</stmt>, que herada da classe
            <stmt>B</stmt>, sobrepõe o método <stmt>f()</stmt> de
            <stmt>B</stmt>, então não é possível fazer com que
            <stmt>A</stmt> usufrua da implementação de <stmt>f()</stmt>
            fornecida por <stmt>B</stmt>.</introducao>
		<resposta valor="f">A palavra reservada <stmt>super</stmt> pode
            ser empregada com esta finalidade.</resposta>
	</questao>
	<questao id="1973" objetivo="6.2">
		<introducao>Se uma classe <stmt>A</stmt>, que herada da classe
            <stmt>B</stmt>, sobrepõe o método <stmt>f()</stmt> de
            <stmt>B</stmt>, então é possível fazer com que
            <stmt>A</stmt> usufrua da implementação de <stmt>f()</stmt>
            fornecida por <stmt>B</stmt>. A sentença
            <stmt>super.f()</stmt> pode ser empregada para que a versão
            de <stmt>f()</stmt> seja aquela oferecida pela superclasse.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1974" objetivo="6.2">
		<introducao>A declaração <stmt>public void f() {}</stmt> é uma
            sobrecarga de <stmt>public int f() {}</stmt>.</introducao>
		<resposta valor="f">A lista de argumentos deve ser diferente.</resposta>
	</questao>
	<questao id="1975" objetivo="6.2">
		<introducao>A declaração <stmt>public void f() {}</stmt> é uma
            sobreposição de <stmt>public int f() {}</stmt>.</introducao>
		<resposta valor="f">O tipo de retorno deve ser o mesmo.</resposta>
	</questao>
	<questao id="1976" objetivo="6.2">
		<introducao>A declaração <stmt>public void f(int i) {}</stmt> é
            uma sobreposição de <stmt>public void f() {}</stmt>.</introducao>
		<resposta valor="f">A lista de argumentos deve ser semelhante.</resposta>
	</questao>
	<questao id="1977" objetivo="6.2">
		<introducao>A declaração <stmt>private void f(int i) {}</stmt> é
            uma sobreposição de <stmt>public void f(int i) {}</stmt>.</introducao>
		<resposta valor="f">O acesso a um método que sobrepõe outro não
            pode ser mais restritivo que aquele do método sobreposto.</resposta>
	</questao>
	<questao id="1978" objetivo="6.2">
		<introducao>A declaração <stmt>public void f(int i) throws
                IOException {}</stmt> é uma sobreposição de <stmt>public
                void f(int i) {}</stmt>.</introducao>
		<resposta valor="f">A sobreposição não pode gerar exceção que
            não é gerada pelo método sobreposto ou ainda, não pode gerar
            exceção &quot;mais abrangente&quot; que aquelas geradas pelo
            método sobreposto.</resposta>
	</questao>
	<questao id="1979" objetivo="6.2">
		<introducao>Métodos sobrecarregados (ou <it>overloaded</it>)
            fazem uso de um mesmo identificador em uma mesma classe, mas
            com argumentos diferentes. Opcionalmente o tipo de retorno
            também é diferente.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1980" objetivo="6.2">
		<introducao>Métodos sobrecarregados devem possuir listas de
            argumentos distintas.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1981" objetivo="6.2">
		<introducao>Métodos sobrecarregados podem possuir o mesmo tipo
            de retorno.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1982" objetivo="6.2">
		<introducao>Métodos sobrecarregados podem ter tipos de retorno distintos.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1983" objetivo="6.2">
		<introducao>Métodos sobrecarregados podem possuir modificadores
            de acesso distintos.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1984" objetivo="6.2">
		<introducao>Métodos sobrecarregados podem declarar novas e mais
            abrangentes exceções, ao contrário da sobreposição de métodos.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1985" objetivo="6.2">
		<introducao>Um método pode ser sobrecarregado na mesma classe ou
            em uma subclasse.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1986" objetivo="6.2">
		<introducao>O código abaixo compila.<java><![CDATA[public class Referencia {
    String titulo;
    public String getTitulo(String prefixo) {
        return prefixo + titulo;
    }
}

class Livro extends Referencia {
    public String getTitulo() {
        return titulo;
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1987" objetivo="6.2">
		<introducao>O código abaixo não compila, pois a sobreposição
                (<it>overridden method</it>) não emprega os mesmos
            argumentos que o método sobreposto.<java><![CDATA[public class Referencia {
    String titulo;
    public String imprime(String prefixo, int npaginas) {
        return prefixo + titulo + " " + npaginas;
    }
}

class Livro extends Referencia {
    public String imprime(String prefixo, byte npaginas) {
        return prefixo + titulo + " " + npaginas;
    }
}]]></java>
		</introducao>
		<resposta valor="f">Não se trata de uma sobreposição, mas
            sobrecarga válida.</resposta>
	</questao>
	<questao id="1988" objetivo="6.2">
		<introducao>Um método <stmt>void M() throws IOException</stmt>
            de uma classe <stmt>A</stmt>, que herda da classe
            <stmt>B</stmt>, que possui o método <stmt>void M(int)</stmt>
            não compila, pois a sobreposição não permite que uma exceção
            verificada (<it>checked exception</it>) seja criada na
            sobreposição ou mesmo que tenha o seu escopo ampliado.</introducao>
		<resposta valor="f">Não se trata de uma sobreposição, mas
            sobrecarga. Observe que os argumentos são distintos nestes métodos.</resposta>
	</questao>
	<questao id="1989" objetivo="6.2">
		<introducao>Se uma classe possui os métodos <stmt>M(int)</stmt>
            e <stmt>M(float)</stmt>, então quando se chama o método
            <stmt>M</stmt> com o argumento do tipo <stmt>int</stmt>, o
            primeiro destes dois métodos é chamado e, quando se chama o
            método <stmt>M</stmt> com o argumento do tipo
            <stmt>float</stmt>, então o segundo destes métodos é chamado.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1990" objetivo="6.2">
		<introducao>Se há uma sobrecarga de um método em determinada
            classe, então este método pode ser chamado passando-se como
            parâmetro qualquer tipo primitivo de Java.</introducao>
		<resposta valor="f">Apenas para aqueles tipos primitivos para os
            quais há o método sobrecarregado cujo argumento é o tipo
            primitivo em questão.</resposta>
	</questao>
	<questao id="1991" objetivo="6.2">
		<introducao>O tipo da referência empregada como argumento decide
            qual o método sobrecarregado é chamado e não o tipo do
            objeto referenciado por esta.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1992" objetivo="6.2">
		<introducao>O código abaixo não compila.<java><![CDATA[public class Poligono {
    public void fazAlgumaCoisa(Poligono p) {
        System.out.print("P");
    }
}

class Triangulo extends Poligono {
    public void fazAlgumaCoisa(Triangulo t) {
        System.out.print("T");
    }
}

class Teste {
    public static void main(String[] args) {
        Triangulo t = new Triangulo();
        t.fazAlgumaCoisa(new Poligono());
        t.fazAlgumaCoisa(t);
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1993" objetivo="6.2">
		<introducao>Quando executado, o código abaixo gera uma exceção.<java><![CDATA[public class Poligono {
    public void fazAlgumaCoisa(Poligono p) {
        System.out.print("P");
    }
}

class Triangulo extends Poligono {
    public void fazAlgumaCoisa(Triangulo t) {
        System.out.print("T");
    }
}

class Teste {
    public static void main(String[] args) {
        Triangulo t = new Triangulo();
        t.fazAlgumaCoisa(new Poligono());
        t.fazAlgumaCoisa(t);
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1994" objetivo="6.2">
		<introducao>A saída produzida pelo código abaixo, quando
            executado, é <stmt>PT</stmt>.<java><![CDATA[public class Poligono {
    public void fazAlgumaCoisa(Poligono p) {
        System.out.print("P");
    }
}

class Triangulo extends Poligono {
    public void fazAlgumaCoisa(Triangulo t) {
        System.out.print("T");
    }
}

class Teste {
    public static void main(String[] args) {
        Triangulo t = new Triangulo();
        t.fazAlgumaCoisa(new Poligono());
        t.fazAlgumaCoisa(t);
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="1995" objetivo="6.2">
		<introducao>O código abaixo compila.<java><![CDATA[public class Pessoa {}
class PessoaFisica extends Pessoa {}
class PessoaJuridica extends Pessoa {}

class Teste {
    public static void fazUso(Pessoa p) {
        System.out.println("P");
    }

    public static void fazUso(PessoaFisica pf) {
        System.out.println("F");
    }

    public static void fazUso(PessoaJuridica pj) {
        System.out.println("J");
    }

    public static void main(String[] args) {
        Pessoa p1 = new PessoaFisica();
        Pessoa p2 = new PessoaJuridica();
        fazUso(new Pessoa());
        fazUso(p1);
        fazUso(p2);
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1996" objetivo="6.2">
		<introducao>A execução do código abaixo produz <stmt>PFJ</stmt>.<java><![CDATA[public class Pessoa {}
class PessoaFisica extends Pessoa {}
class PessoaJuridica extends Pessoa {}

class Teste {
    public static void fazUso(Pessoa p) {
        System.out.print("P");
    }

    public static void fazUso(PessoaFisica pf) {
        System.out.print("F");
    }

    public static void fazUso(PessoaJuridica pj) {
        System.out.print("J");
    }

    public static void main(String[] args) {
        Pessoa p1 = new PessoaFisica();
        Pessoa p2 = new PessoaJuridica();
        fazUso(new Pessoa());
        fazUso(p1);
        fazUso(p2);
    }
}]]></java>
		</introducao>
		<resposta valor="f">Há uma sobrecarga do método
            <stmt>fazUso</stmt>. A decisão de qual método sobrecarregado
            é chamado é decidido em tempo de compilação, conforme o tipo
            da referência fornecida.</resposta>
	</questao>
	<questao id="1997" objetivo="6.2">
		<introducao>A decisão de qual método sobrecarregado é chamado é
            decidido em tempo de compilação, conforme o tipo da
            referência fornecida.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1998" objetivo="6.2">
		<introducao>O tipo do objeto referenciado é empregado para
            decidir, no caso de sobreposição, qual método a ser chamado,
            se o de uma superclasse ou subclasse.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="1999" objetivo="6.2">
		<introducao>Pode haver sobreposição e sobrecarga associada a um
            mesmo método.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2000" objetivo="6.2">
		<introducao>O código abaixo não compila.<java><![CDATA[public class FormaDeComunicacao {
    protected void fazAlgo() {}
}

class Telefone extends FormaDeComunicacao {
    public void fazAlgo() {}
    private void fazAlgo(int id) {}
    protected void fazAlgo(byte id) {}
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="2001" objetivo="6.2">
		<introducao>A sobreposição do método <stmt>fazAlgo</stmt> na
            classe <stmt>Telefone</stmt> é o método com o mesmo
            modificador de acesso do único método da classe <stmt>FormaDeComunicacao</stmt>.<java><![CDATA[public class FormaDeComunicacao {
    protected void fazAlgo() {}
}

class Telefone extends FormaDeComunicacao {
    public void fazAlgo() {}
    private void fazAlgo(int id) {}
    protected void fazAlgo(byte id) {}
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="2002" objetivo="6.2">
		<introducao>Se a classe <stmt>A</stmt> é derivada de
            <stmt>B</stmt>, quando se cria uma instância de
            <stmt>A</stmt> e a referência é depositada em uma variável
            do tipo referência de <stmt>B</stmt>, as mensagens possíveis
            de serem enviadas para a instância de <stmt>A</stmt> criada
            estão restritas àquelas cujos métodos estão presentes em
            <stmt>B</stmt> e, possivelmente, mas não necessariamente,
            são sobrepostos em <stmt>A</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2003" objetivo="6.2">
		<introducao>O código abaixo compila.<java><![CDATA[public class Base {
    public void faz() {}
}

class Derivada extends Base {
    public void faz(int i) {}
}

class TestaHeranca {
    public static void main(String[] args) {
        Base d = new Derivada();
        d.faz(1);
    }
}]]></java>
		</introducao>
		<resposta valor="f">Observe que para a referência <stmt>d</stmt>
            só podem ser enviadas mensagens para as quais há os métodos
            correspondentes em <stmt>Base</stmt>, o tipo desta referência.</resposta>
	</questao>
	<questao id="2004" objetivo="6.2">
		<introducao>O código abaixo compila.<java><![CDATA[public class Base {
    public void faz() {}
}

class Derivada extends Base {
    public void faz(int i) {}
}

class TestaHeranca {
    public static void main(String[] args) {
        Base d = new Derivada();
        d.faz();
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2005" objetivo="6.2">
		<introducao>Nem o tipo de retorno nem os argumentos, se
            existirem, podem ser alterados quando desejamos uma sobreposição.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2006" objetivo="6.2">
		<introducao>O tipo de retorno pode, eventualmente, ser alterado
            quando desejamos uma sobrecarga. Os argumentos, contudo,
            necessariamente devem ser diferentes.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2007" objetivo="6.2">
		<introducao>As exceções geradas por métodos sobrecarregados
            podem ser diferentes.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2008" objetivo="6.2">
		<introducao>O controle de acesso de métodos sobrecarregados pode
            diferir de um método para outro.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2009" objetivo="1.3">
		<introducao>Quando se cria uma instância de uma classe, o
            construtor desta classe é chamado e, para cada classe na
            hierarquia até a classe <stmt>Object</stmt>, um construtor
            correspondente a cada uma destas classes da hierarquia é chamado.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2010" objetivo="1.3">
		<introducao>Sempre que a palavra reservada <stmt>new</stmt> é
            empregada um construtor é chamado.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2011" objetivo="6.3">
		<introducao>Toda classe, inclusive aquelas abstratas, devem
            possuir um construtor, mesmo que este seja fornecido
            automaticamente pelo compilador.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2012" objetivo="6.3">
		<introducao>A classe abaixo compila.<java><![CDATA[public class Bola {
    Bola() {}
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2013" objetivo="6.3">
		<introducao>A classe abaixo compila.<java><![CDATA[public class Bola {
    private Bola() {}
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2014" objetivo="6.3">
		<introducao>A classe abaixo compila.<java><![CDATA[public class Bola {
    protected Bola() {}
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2015" objetivo="6.3">
		<introducao>A classe abaixo compila.<java><![CDATA[public class Bola {
    public Bola() {}
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2016" objetivo="6.3">
		<introducao>Nenhum construtor possui tipo de retorno.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2017" objetivo="6.3">
		<introducao>O tipo de retorno de um construtor é <stmt>void</stmt>.</introducao>
		<resposta valor="f">Construtor não possui tipo de retorno.</resposta>
	</questao>
	<questao id="2018" objetivo="6.3">
		<introducao>Construtor não possui tipo de retorno.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2019" objetivo="6.3">
		<introducao>O identificador de um construtor é o mesmo
            identificador da classe em questão.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2020" objetivo="6.3">
		<introducao>O identificador de um construtor pode diferir do
            nome da classe no qual se encontra.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="2021" objetivo="6.3">
		<introducao>Um dos modificadores de acesso, ou seja,
            <stmt>private</stmt>, <stmt>protected</stmt>,
            <stmt>public</stmt> e aquele implícito (de
            <it>package</it>), necessariamente é aplicado a todo e
            qualquer construtor.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2022" objetivo="6.3">
		<introducao>O código abaixo compila.<java><![CDATA[public class Camisa {
    Camisa(int numero) {}
    public static void main(String[] args) {
        Camisa c = new Camisa(1);
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2023" objetivo="6.3">
		<introducao>O código abaixo compila.<java><![CDATA[public class Camisa {
    Camisa(int numero) {}
    public static void main(String[] args) {
        Camisa c = new Camisa();
    }
}]]></java>
		</introducao>
		<resposta valor="f">Não há construtor compatível com aquele
            empregado pelo operador <stmt>new</stmt>.</resposta>
	</questao>
	<questao id="2024" objetivo="6.3">
		<introducao>Pode haver sobrecarga de construtores.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2025" objetivo="6.3">
		<introducao>É possível haver sobreposição de construtor.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="2026" objetivo="6.3">
		<introducao>A classe <stmt>public class Exame {}</stmt> é uma
            classe, em Java, derivada da classe <stmt>Object</stmt>,
            embora seja desnecessário a declaração explícita desta herança.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2027" objetivo="6.3">
		<introducao>A declaração <stmt>public class Exame extends Object
            {}</stmt> é equivalente à declaração <stmt>public class
                Exame {}</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2028" objetivo="6.3">
		<introducao>O código abaixo não compila.<java><![CDATA[public class Instrumento {
    Instrumento() {
        System.out.print("I");
    }
}
class Cirurgico extends Instrumento {
    Cirurgico() {
        System.out.print("C");
    }
}

class UsaInstrumento {
    public static void main(String[] args) {
        new Instrumento();
        new Cirurgico();
        new UsaInstrumento();
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="2029" objetivo="6.3">
		<introducao>Quando executado, o código produz como saída <stmt>IIC</stmt>.<java><![CDATA[public class Instrumento {
    Instrumento() {
        System.out.print("I");
    }
}
class Cirurgico extends Instrumento {
    Cirurgico() {
        System.out.print("C");
    }
}

class UsaInstrumento {
    public static void main(String[] args) {
        new Instrumento();
        new Cirurgico();
        new UsaInstrumento();
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2030" objetivo="6.3">
		<introducao>Quando se cria uma instância de determinada classe,
            o construtor desta classe é chamado. Contudo, este
            construtor chama o construtor da superclasse desta classe e
            assim por diante, até que o construtor da classe
            <stmt>Object</stmt> seja chamado. Quando o construtor da
            classe <stmt>Object</stmt> terminar sua execução, o
            construtor da classe descendente desta retoma a execução e
            assim por diante, até que o construtor inicial complete a
            sua execução.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2031" objetivo="6.3">
		<introducao>O código abaixo não compila.<java><![CDATA[public class Roupa {
    Roupa() {
        System.out.print("R");
    }
}

class Costura {
    Roupa r = new Roupa();

    Costura() {
        System.out.print("C");
    }
}

class Cabide extends Costura {
    Roupa r = new Roupa();

    Cabide() {
        System.out.print("B");
    }
}

class Ordem {
    public static void main(String[] args) {
        new Cabide();
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="2032" objetivo="6.3">
		<introducao>A execução do código abaixo produz como saída <stmt>RCRB</stmt>.<java><![CDATA[public class Roupa {
    Roupa() {
        System.out.print("R");
    }
}

class Costura {
    Roupa r = new Roupa();

    Costura() {
        System.out.print("C");
    }
}

class Cabide extends Costura {
    Roupa r = new Roupa();

    Cabide() {
        System.out.print("B");
    }
}

class Ordem {
    public static void main(String[] args) {
        new Cabide();
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2033" objetivo="6.3">
		<introducao>O código abaixo, quando executado, produz como saída <stmt>futebolPele</stmt>.<java><![CDATA[class AtletaDeReferencia {
    AtletaDeReferencia() {
        System.out.print("Pele");
    }
}
public class Esporte {
    AtletaDeReferencia atleta = new AtletaDeReferencia();

    Esporte() {
        System.out.print("futebol");
    }

    public static void main(String[] args) {
        new Esporte();
    }
}]]></java>
		</introducao>
		<resposta valor="f">Quando se cria uma instância de uma classe,
            primeiro as variáveis de instância são iniciadas, caso
            existam, posteriormente o construtor termina a sua execução.
            Neste caso, primeiro a referência para <stmt>Atle</stmt>
		</resposta>
	</questao>
	<questao id="2034" objetivo="6.3">
		<introducao>O código abaixo, quando executado, produz como saída <stmt>Pelefutebol</stmt>.<java><![CDATA[class AtletaDeReferencia {
    AtletaDeReferencia() {
        System.out.print("Pele");
    }
}
public class Esporte {
    AtletaDeReferencia atleta = new AtletaDeReferencia();

    Esporte() {
        System.out.print("futebol");
    }

    public static void main(String[] args) {
        new Esporte();
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2035" objetivo="6.3">
		<introducao>Quando uma instância de uma classe é criada,
            primeiro as variáveis de instância desta classe são
            iniciadas e, posteriormente, o construtor é executado. Estas
            operações, contudo, primeiro são executadas para a
            superclasse desta classe. Quando estas operações forem
            executadas para a superclasse, antes destas serão executadas
            aquelas correspondentes à superclasse da superclasse da
            classe cuja instância é criada e assim por diante, até que
            as operações da classe <stmt>Object</stmt> tenham sido realizadas.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2036" objetivo="6.3">
		<introducao>As operações necessárias para se criar uma instância
            de uma classe <stmt>C</stmt> envolve as atividades de
            iniciar as variáveis de instância e a execução do construtor
            de <stmt>C</stmt>. Estas operações, contudo, só são
            realizadas após estas mesmas operações terem sido realizadas
            para todas as classes na hierarquia da classe <stmt>C</stmt>
            até a classe <stmt>Object</stmt>, na ordem inversa. Ou seja,
            primeiro estas operações são realizadas para a classe
            <stmt>Object</stmt> e, só após, aquelas para a classe
            imediatamente descendente e assim por diante, até que as
            operações correspondentes à classe <stmt>C</stmt> tenham
            sido executadas.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2037" objetivo="6.3">
		<introducao>Um construtor pode fazer uso de qualquer modificador
            de acesso, inclusive o <stmt>private</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2038" objetivo="6.3">
		<introducao>Uma classe <stmt>C</stmt> que possua a declaração
                <stmt>private C() {}</stmt> não dará origem a nenhuma
            instância, pois este construtor não é acessível externamente.</introducao>
		<resposta valor="f">Um método declarado <stmt>static</stmt>
            desta classe pode fazer uso deste construtor, entre outras possibilidades.</resposta>
	</questao>
	<questao id="2039" objetivo="6.3">
		<introducao>O nome de um construtor de uma classe
            necessariamente é o mesmo nome desta classe.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2040" objetivo="6.3">
		<introducao>Nenhum tipo primitivo é aceito como retorno de um construtor.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2041" objetivo="6.3">
		<introducao>O código abaixo compila.<java><![CDATA[public class Fazenda {
    public void Fazenda() {
        System.out.print("F");
    }

    public static void main(String[] args) {
        new Fazenda().Fazenda();
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2042" objetivo="6.3">
		<introducao>A execução do código abaixo produz como saída <stmt>FF</stmt>.<java><![CDATA[public class Fazenda {
    public void Fazenda() {
        System.out.print("F");
    }

    public static void main(String[] args) {
        new Fazenda().Fazenda();
    }
}]]></java>
		</introducao>
		<resposta valor="f">A saída é simplesmente <stmt>F</stmt>.
            Embora seja aconselhável evitar, é possível que uma classe
            possua um ou mais métodos com o mesmo nome da classe. A
            classe <stmt>Fazenda</stmt>, por exemplo, não possui nenhum
            construtor explicitamente fornecido pelo programador.</resposta>
	</questao>
	<questao id="2043" objetivo="6.3">
		<introducao>Uma classe pode conter métodos com o mesmo nome da classe.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2044" objetivo="6.3">
		<introducao>Método e construtor são sinônimos.</introducao>
		<resposta valor="f">Método necessariamente possui um tipo de
            retorno, mesmo que seja <stmt>void</stmt>. Métodos não
            possuem tipo de retorno.</resposta>
	</questao>
	<questao id="2045" objetivo="6.3">
		<introducao>Se o programador não fornece nenhum construtor para
            uma classe, então o compilador automaticamente insere o
            construtor sem argumentos para a classe.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2046" objetivo="6.3">
		<introducao>O construtor inserido pelo compilador sempre o
            construtor que não recebe nenhum argumento.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2047" objetivo="6.3">
		<introducao>A primeira sentença de todo construtor deve ser uma
            chamada para o construtor sobrecarregado sem argumentos, ou
            <stmt>this()</stmt>, ou uma chamada para o construtor da
            superclasse, ou seja, <stmt>super()</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2048" objetivo="6.3">
		<introducao>O código abaixo compila.<java><![CDATA[public class Aprender {
    Aprender() {
        this();
        System.out.println("Aprender");
    }
}]]></java>
		</introducao>
		<resposta valor="f">Chamada recursiva de construtor é detectada
            pelo compilador e provoca um erro de compilação.</resposta>
	</questao>
	<questao id="2049" objetivo="6.3">
		<introducao>O código abaixo compila.<java><![CDATA[public class Aprender {
    Aprender() {
        super();
        System.out.println("Aprender");
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2050" objetivo="6.3">
		<introducao>Se fornecida expliciatamente, a chamada a
            <stmt>this()</stmt> ou, exclusivamente, a chamada a
            <stmt>super()</stmt>, deve ser a primeira sentença do
            construtor, necessariamente.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2051" objetivo="6.3">
		<introducao>Um construtor não pode incluir uma chamada a
            <stmt>this()</stmt> e uma chamada a <stmt>super()</stmt>,
            qualquer que seja a ordem em que estas sentenças sejam fornecidas.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2052" objetivo="6.3">
		<introducao>O código abaixo não compila.<java><![CDATA[public class Aprender {
    Aprender() {
        super();
        System.out.println("A");
    }

    Aprender(int i) {
        this();
        super();
    }
}]]></java>
		</introducao>
		<resposta valor="v">Ou existe uma chamada ao construtor
            <stmt>this()</stmt> ou uma ao construtor
            <stmt>super()</stmt>, exclusivamente, nunca a ambas.</resposta>
	</questao>
	<questao id="2053" objetivo="6.3">
		<introducao>A criação de uma instância de determinada classe faz
            com que um único construtor seja executado.</introducao>
		<resposta valor="f">Um construtor pode fazer uso da sentença
            <stmt>this()</stmt>, que chama outro construtor para uma
            mesma instância.</resposta>
	</questao>
	<questao id="2054" objetivo="6.3">
		<introducao>Se um certo número de chamadas a construtores é
            realizada, então pelo menos este número de instâncias é criado.</introducao>
		<resposta valor="f">A criação de um único objeto pode envolver a
            execução de mais de um construtor da classe em questão.</resposta>
	</questao>
	<questao id="2055" objetivo="6.3">
		<introducao>Se um construtor é explicitamente fornecido para uma
            classe e este construtor não possui uma chamada para o
            construtor da superclasse, então o compilador
            automaticamente insere uma chamada sem argumentos para o
            construtor da superclasse, ou seja, <stmt>super()</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2056" objetivo="6.3">
		<introducao>Uma chamada a <stmt>super()</stmt> não
            necessariamente é sem argumentos. A chamada ao construtor da
            superclasse que recebe como argumento um inteiro, por
            exemplo, pode ser realizada via <stmt>super(2)</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2057" objetivo="6.3">
		<introducao>O construtor que não recebe nenhum argumento só pode
            ser fornecido pelo compilador.</introducao>
		<resposta valor="f">Este construtor pode ser explicitamente fornecido.</resposta>
	</questao>
	<questao id="2058" objetivo="6.3">
		<introducao>O código abaixo compila.<java><![CDATA[public class Grupo {
    Grupo(int n) {
        System.out.print(n);
    }
}

class Torcida extends Grupo {
    Torcida() {
        System.out.print("Torcida");
    }
}]]></java>
		</introducao>
		<resposta valor="f">O construtor da classe <stmt>Torcida</stmt>,
            via <stmt>super()</stmt>, automaticamente inserido pelo
            compilador, faz uso de um construtor não fornecido para a
            classe <stmt>Grupo</stmt>. Como esta classe possui um
            construtor, o compilador não insere automaticamente o
            construtor sem argumentos para esta classe, o que gera um
            erro de compilação.</resposta>
	</questao>
	<questao id="2059" objetivo="6.3">
		<introducao>O código abaixo compila.<java><![CDATA[public class Facilitador {
    Facilitador(int idade) {
        System.out.println(idade);
    }
}

class Professor extends Facilitador {
    Professor() {
        super(getIdade());
    }

    public int getIdade() {
        return 25;
    }
}]]></java>
		</introducao>
		<resposta valor="f">Não é permitido o emprego de variáveis de
            instância ou métodos de instância antes que o construtor da
            superclasse, <stmt>super()</stmt>, tenha sido executado.</resposta>
	</questao>
	<questao id="2060" objetivo="6.3">
		<introducao>Não é permitido o emprego de variáveis de instância
            ou métodos de instância antes que o construtor da
            superclasse, <stmt>super()</stmt>, tenha sido executado.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2061" objetivo="6.3">
		<introducao>Interfaces não possuem construtores.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2062" objetivo="6.3">
		<introducao>Interfaces não fazem parte da árvore de herança de objetos.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2063" objetivo="6.3">
		<introducao>A única possibilidade de se chamar um construtor é
            do interior de outro construtor. Ou seja, não é permitido
            chamar um construtor como se chama um método qualquer.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2064" objetivo="6.3">
		<introducao>Pode-se fazer uso de variáveis de classe e métodos
            de classe antes da execução do construtor da superclasse,
            <stmt>super()</stmt>, apenas quando estas variáveis e/ou
            métodos são empregados na chamada a <stmt>super()</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2065" objetivo="6.3">
		<introducao>Se <stmt>a</stmt> é uma variável de classe, então a
            chamada <stmt>super(a)</stmt> é válida como primeira
            sentença de um construtor da classe a qual a variável
            <stmt>a</stmt> pertente. Assuma que a superclasse da classe
            em questão possui um construtor que recebe um valor do mesmo
            tipo da variável <stmt>a</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2066" objetivo="6.3">
		<introducao>Toda classe abstrata possui um construtor.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2067" objetivo="6.3">
		<introducao>Construtor de uma classe abstrata sempre é chamado
            quando uma subclasse concreta é instanciada.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2068" objetivo="6.3">
		<introducao>O código abaixo compila.<java><![CDATA[public class Facilitador {
    Facilitador(int idade) {
        System.out.println(idade);
    }
}

class Professor extends Facilitador {
    Professor() {
        super(getIdade());
    }

    public static int getIdade() {
        return 25;
    }
}]]></java>
		</introducao>
		<resposta valor="v">Observe que, embora seja empregado um método
            de <stmt>Professor</stmt> antes que tenha sido concluído a
            chamada ao construtor da superclasse de
            <stmt>Professor</stmt>, o método é <stmt>static</stmt> e
            está sendo usado como argumento da chamada ao construtor da
            superclasse. Se o método não fosse <stmt>static</stmt>,
            então a chamada seria inválida.</resposta>
	</questao>
	<questao id="2069" objetivo="6.3">
		<introducao>O código abaixo não compila.<java><![CDATA[public class Anta {
    Anta() {
        System.out.println(getIdade());
    }

    public static int getIdade() {
        new Anta();
        return 15;
    }

    public static void main(String[] args) {
        new Anta();
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="2070" objetivo="6.3">
		<introducao>O código abaixo, quando executado, exibe como saída
            o valor <stmt>15</stmt>.<java><![CDATA[public class Anta {
    Anta() {
        System.out.println(getIdade());
    }

    public int getIdade() {
        new Anta();
        return 15;
    }

    public static void main(String[] args) {
        new Anta();
    }
}]]></java>
		</introducao>
		<resposta valor="f">O construtor da classe <stmt>Anta</stmt> faz
            uso de um método de instância, o que é permitido após a
            chamada do construtor da superclasse, o que é o caso.
            Contudo, este método cria uma nova instância desta mesma
            classe, o que força uma nova chamada a este método, que
            tenta criar uma nova instância e assim por diante, até que
            um erro <stmt>java.lang.StackOverflowError</stmt> seja gerado.</resposta>
	</questao>
	<questao id="2071" objetivo="6.3">
		<introducao>O código abaixo, quando executado, provoca um erro: <stmt>java.lang.StackOverflowError</stmt>.<java><![CDATA[public class Anta {
    Anta() {
        System.out.println(getIdade());
    }

    public int getIdade() {
        new Anta();
        return 15;
    }

    public static void main(String[] args) {
        new Anta();
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2072" objetivo="6.3">
		<introducao>Para a classe <stmt>class X {}</stmt> o compilador
            insere o construtor sem argumentos.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2073" objetivo="6.3">
		<introducao>Para a classe abaixo o compilador insere o
            construtor sem argumentos.<java><![CDATA[public class Maquina {
    Maquina() {}
}]]></java>
		</introducao>
		<resposta valor="f">O construtor sem argumentos já é fornecido.</resposta>
	</questao>
	<questao id="2074" objetivo="6.3">
		<introducao>Para a classe abaixo o compilador insere o
            construtor sem argumentos.<java><![CDATA[public class Maquina {
    Maquina(String s) {}
}]]></java>
		</introducao>
		<resposta valor="f">O construtor sem argumentos é
            automaticamente fornecido pelo compilador apenas quando
            nenhum construtor é fornecido explicitamente.</resposta>
	</questao>
	<questao id="2075" objetivo="6.3">
		<introducao>O compilador só insere o construtor sem argumentos
            quando nenhum construtor é fornecido.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2076" objetivo="6.3">
		<introducao>O compilador insere um construtor sem argumentos
            para a classe fornecida abaixo.<java><![CDATA[public class Prato {
    void Prato() {}
}]]></java>
		</introducao>
		<resposta valor="v">A declaração <stmt>void Prato() {}</stmt>
            não se refere a um construtor, mas um método, conforme o
            tipo de retorno <stmt>void</stmt> denuncia.</resposta>
	</questao>
	<questao id="2077" objetivo="6.3">
		<introducao>Todo método possui um tipo de retorno, mesmo que
            este seja <stmt>void</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2078" objetivo="6.3">
		<introducao>Construtor não possui tipo de retorno, nem mesmo
            <stmt>void</stmt>. Dessa forma, é fácil isolar construtores
            de métodos, pois os primeiros não são declarados com um tipo
            de retorno, ao contrário dos últimos.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2079" objetivo="6.3">
		<introducao>Sabe-se que o compilador irá automaticamente inserir
            um construtor sem argumentos para uma classe quando nenhum
            construtor é escrito para esta classe.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2080" objetivo="6.3">
		<introducao>O construtor automaticamente fornecido pelo
            compilador possui <stmt>public</stmt> como modificador de acesso.</introducao>
		<resposta valor="f">Não necessariamente, o modificador de acesso
            é o mesmo da classe.</resposta>
	</questao>
	<questao id="2081" objetivo="6.3">
		<introducao>O modificador de acesso do construtor inserido pelo
            compilador é o mesmo da classe em questão.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2082" objetivo="6.3">
		<introducao>O construtor fornecido pelo compilador não possui argumentos.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2083" objetivo="6.3">
		<introducao>O construtor fornecido automaticamente pelo
            compilador inclui uma chamada sem argumentos para o
            construtor da superclasse, ou <stmt>super()</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2084" objetivo="6.3">
		<introducao>O código abaixo compila.<java><![CDATA[public class Fruta {
    Fruta(int i) {}
}

class Laranja extends Fruta {}]]></java>
		</introducao>
		<resposta valor="f">O construtor para a classe
            <stmt>Laranja</stmt> é automaticamente fornecido pelo
            compilador. Este construtor inclui uma chamada ao construtor
            da superclasse, <stmt>super()</stmt> que, neste caso não
            existe e não pode ser inserido automaticamente pelo
            compilador na classe <stmt>Fruta</stmt>, pois esta inclui um construtor.</resposta>
	</questao>
	<questao id="2085" objetivo="6.3">
		<introducao>As declarações <stmt>class Fruta {}</stmt> e
                <stmt>class Fruta { Fruta() { super(); } }</stmt> são equivalentes.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2086" objetivo="6.3">
		<introducao>As declarações <stmt>class Fruta { Fruta() {}
            }</stmt> e <stmt>class Fruta { Fruta() { super(); } }</stmt>
            são equivalentes.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2087" objetivo="6.3">
		<introducao>Quando nenhum construtor é fornecido para uma
            classe, o compilador insere o construtor sem argumentos para
            esta classe e inclui a chamada <stmt>super()</stmt> no corpo
            deste construtor.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2088" objetivo="6.3">
		<introducao>As sentenças <stmt>class Fruta {}</stmt> e
                <stmt>class Fruta { public Fruta() { super(); } }</stmt>
            são equivalentes.</introducao>
		<resposta valor="f">O modificador de acesso do construtor é
            <stmt>public</stmt>, que é diferente do modificador de
            acesso da classe, portanto, estas declarações não são
            equivalentes. Para serem equivalentes o modificador
            <stmt>public</stmt> deveria ser removido do construtor.</resposta>
	</questao>
	<questao id="2089" objetivo="6.3">
		<introducao>As sentenças <stmt>class Fruta { Fruta(String s) {}
            }</stmt> e <stmt>class Fruta { Fruta(String s) { super(); }
            }</stmt> são equivalentes.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2090" objetivo="6.3">
		<introducao>Para a declaração <stmt>class Fruta {}</stmt> o
            compilador insere o construtor sem argumentos.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2091" objetivo="6.3">
		<introducao>Para a declaração <stmt>class Fruta { void Fruta()
                {} }</stmt> o compilador insere o construtor sem argumentos.</introducao>
		<resposta valor="v">O corpo da classe não contém nenhum
            construtor, mas um método, conforme revela o tipo de retorno
            <stmt>void</stmt>. Portanto, o construtor sem argumentos é
            automaticamente fornecido pelo compilador.</resposta>
	</questao>
	<questao id="2092" objetivo="6.3">
		<introducao>Construtores podem ter argumentos assim como
            métodos. Ao contrário destes últimos, contudo, os primeiros
            não possuem tipo de retorno.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2093" objetivo="6.3">
		<introducao>Se a superclasse de uma classe <stmt>C</stmt> não
            possui o construtor sem argumentos, então a classe
            <stmt>C</stmt> deve explicitamente fazer uma chamada a outro
            construtor da superclasse ou um erro de compilação será gerado.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2094" objetivo="6.3">
		<introducao>O código abaixo não compila.<java><![CDATA[public class Fruta {
    Fruta(int i) {}
}

class Laranja extends Fruta {
    Laranja() {
        super(1);
        System.out.println("Laranja");
    }
    public static void main(String[] args) {
        new Laranja();
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="2095" objetivo="6.3">
		<introducao>O código abaixo compila.<java><![CDATA[public class Fruta {
    Fruta(int i) { super(); }
}

class Laranja extends Fruta {
    Laranja() {
        super(1);
        System.out.println("Laranja");
    }
    public static void main(String[] args) {
        new Laranja();
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2096" objetivo="6.3">
		<introducao>O código abaixo não compila.<java><![CDATA[public class Fruta {
    Fruta(int i) { this(); }
}

class Laranja extends Fruta {
    Laranja() {
        super(1);
        System.out.println("Laranja");
    }
    public static void main(String[] args) {
        new Laranja();
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2097" objetivo="6.3">
		<introducao>A declaração <stmt>class Fruta { Fruta(int i) {
                this(); } }</stmt> é inválida, pois há uma chamada a o
            construtor sem argumentos no interior do construtor
            fornecido na classe. O construtor sem argumentos, contudo,
            só é automaticamente inserido pelo compilador quando nenhum
            construtor é fornecido.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2098" objetivo="6.3">
		<introducao>Tanto <stmt>super()</stmt> quanto
            <stmt>this()</stmt> são chamadas a construtores.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2099" objetivo="6.3">
		<introducao>A chamada <stmt>super()</stmt> é ao construtor da
            superclasse, enquanto <stmt>this()</stmt> é uma chamada ao
            construtor sem argumentos da classe onde é empregada.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2100" objetivo="6.3">
		<introducao>Construtores não podem ser herdados. Métodos podem
            ser herdados.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2101" objetivo="6.3">
		<introducao>Construtor não é método.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2102" objetivo="6.3">
		<introducao>Método não é construtor.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2103" objetivo="6.3">
		<introducao>Construtor não é membro de uma classe.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2104" objetivo="6.3">
		<introducao>Os membros de uma classe não incluem os construtores.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2105" objetivo="6.3">
		<introducao>Não pode haver sobreposição de construtores, pois
            isto exige herança e construtores não são herdados.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2106" objetivo="6.3">
		<introducao>Uma chamada a <stmt>this()</stmt> ou,
            exclusivamente, uma chamada a <stmt>super()</stmt>, pode
            existir como primeira sentença de um construtor.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2107" objetivo="6.3">
		<introducao>A primeira linha de um construtor deve ser uma
            chamada a <stmt>super()</stmt> ou uma chamada a
            <stmt>this()</stmt>. Não há exceções.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2108" objetivo="6.3">
		<introducao>Se a primeira sentença de um construtor não é
            <stmt>this()</stmt> ou <stmt>super()</stmt>, então o
            compilador automaticamente insere a chamada <stmt>super()</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2109" objetivo="6.3">
		<introducao>Não é permitida uma chamada a <stmt>super()</stmt> e
            uma chamada a <stmt>this()</stmt> em um mesmo construtor.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2110" objetivo="6.3">
		<introducao>Se um construtor contém uma chamada a
            <stmt>this()</stmt>, então o compilador não irá inserir uma
            chamada a <stmt>super()</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2111" objetivo="6.3">
		<introducao>Se um construtor já contém uma chamada a
            <stmt>super()</stmt>, então o compilador não irá inserir
            outra chamada a <stmt>super()</stmt> nem irá inserir uma
            chamada a <stmt>this()</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2112" objetivo="1.4">
		<introducao>Se um método herdado é sobrecarregado em uma
            determinada classe, então a sobrecarga não está sujeita às
            rígidas regras de sobreposição.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2113" objetivo="1.4">
		<introducao>Se o método <stmt>int M()</stmt> é a sobrecarga
            válida de um método herdado, então pode-se afirmar que,
            seguramente, o método definido na superclasse possui um tipo
            de retorno diferente.</introducao>
		<resposta valor="f">Uma sobrecarga exige, necessariamente, que a
            lista de argumentos seja diferente, opcionalmente o tipo de
            retorno também pode ser diferente.</resposta>
	</questao>
	<questao id="2114" objetivo="1.4">
		<introducao>Se o método <stmt>int M()</stmt> é a sobrecarga
            válida de um método herdado, então pode-se afirmar que o
            método definido na superclasse necessariamente possui algum argumento.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2115" objetivo="1.4">
		<introducao>Quando uma subclasse deseja alterar a implementação
            de um método herdado, a subclasse deve definir um método com
            o mesmo nome, o mesmo tipo de retorno e os mesmos argumentos
            fornecidos no método da superclasse.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2116" objetivo="1.4">
		<introducao>A sobrecarga de métodos pode dar origem a métodos
            com diferentes tipos de retorno, mas a sobreposição de
            métodos não permite a alteração do tipo de retorno.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2117" objetivo="1.4">
		<introducao>Quando se faz uso de herança, pode ser necessário
            fornecer uma implementação de um método fornecido na
            superclasse para tornar a subclasse mais coerente. Este
            &quot;refinamento&quot; ou &quot;reimplementação&quot; de um
            método herdado é denominado de sobreposição ou <it>overriding</it>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2118" objetivo="1.4">
		<introducao>Um método que retorna uma referência pode retornar o
            valor <stmt>null</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2119" objetivo="1.4">
		<introducao>Um <it>array</it> pode ser retornado por um método.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2120" objetivo="1.4">
		<introducao>Um método que retorna um tipo primitivo pode
            retornar qualquer valor ou variável que é explicitamente
            moldado (<it>casting</it>) para o tipo do retorno.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2121" objetivo="1.4">
		<introducao>Um método que retorna um tipo primitivo pode
            retornar qualquer valor ou variável que pode ser
            implicitamente moldado (<it>casting</it>) para o tipo do retorno.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2122" objetivo="1.4">
		<introducao>Qualquer valor ou variável que é retornado de um
            método cujo tipo de retorno é <stmt>void</stmt> provoca um
            erro de compilação.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2123" objetivo="1.4">
		<introducao>Um método cujo tipo de retorno é uma referência,
            pode retornar qualquer tipo de objeto que pode ser
            implicitamente moldado (<it>casting</it>) para o tipo
            declarado de retorno.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2124" objetivo="1.4">
		<introducao>Todo objeto <stmt>obj</stmt> para o qual o resultado
            de <stmt>obj instanceof Classe</stmt> é verdadeiro pode ser
            retornado em um método cujo tipo de retorno é <stmt>Classe</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2125" objetivo="1.4">
		<introducao>O código abaixo compila.<java><![CDATA[public class Lanche {
    public short peso() {
        return (short) 50 + 98000; 
    }
}]]></java>
		</introducao>
		<resposta valor="f">O valor retornado é do tipo
            <stmt>int</stmt>, pois é resultado da soma de um
            <stmt>short</stmt> com um <stmt>int</stmt>, apesar do tipo
            de retorno do método ser <stmt>short</stmt>, o que gera um
            erro de compilação.</resposta>
	</questao>
	<questao id="2126" objetivo="8.2">
		<introducao>Um <it>array</it> de caracteres não é uma
            <it>string</it> em Java.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2127" objetivo="8.2">
		<introducao>Uma <it>string</it> em Java não necessariamente deve
            terminar pelo caractere '<stmt>\u0000</stmt>'.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2128" objetivo="8.2">
		<introducao>Uma <it>string</it> em Java é possível através da
            classe <stmt>String</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2129" objetivo="8.2">
		<introducao>Uma instância de <stmt>String</stmt> é imutável, ou
            seja, seu conteúdo nunca muda.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2130" objetivo="8.2">
		<introducao>Um <it>array</it> de caracteres em Java pode mudar
            e, não necessariamente, o último caractere é '<stmt>\u0000</stmt>'.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2131" objetivo="8.2">
		<introducao>O método <stmt>toCharArray</stmt> da classe
            <stmt>String</stmt> retorna um <it>array</it> de caracteres
            correspondentes à seqüência de caracteres na instância de
            <stmt>String</stmt> que recebe esta mensagem.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2132" objetivo="8.2">
		<introducao>Ao contrário de instâncias da classe
            <stmt>String</stmt>, instâncias da classe
            <stmt>StringBuffer</stmt> são mutáveis, ou seja, a seqüência
            correspondente pode ser alterada.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2133" objetivo="8.2">
		<introducao>Um construtor é utilizado na criação de um objeto
            que é uma instância de uma classe. Construtores são chamados
            em expressões de criação de instâncias, pelas conversões e
            concatenações causadas pelo operador de concatenação
            <stmt>+</stmt> e pela invocação explícita do interior de
            outros construtores.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2134" objetivo="8.2">
		<introducao>Se apenas um operando do operador <stmt>+</stmt> é
            do tipo <stmt>String</stmt>, então uma conversão para
            <it>string</it> é realizada no outro operando para produzir
            uma <it>string</it> em tempo de execução.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2135" objetivo="8.2">
		<introducao>Quando um operando de <stmt>+</stmt> representa uma
            concatenação de <it>strings</it>, uma nova instância de
            <stmt>String</stmt> é criada para representar o resultado da concatenação.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2136" objetivo="8.2">
		<introducao>O operador de concatenação de <it>strings</it>
            resulta em uma <stmt>String</stmt> que a concatenação das
            <it>string</it> envolvidas na concatenação onde aquela da
            esquerda irá preceder aquela da direita do operador de
            concatenação na <stmt>String</stmt> resultante.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2137" objetivo="8.2">
		<introducao>Qualquer valor de um dado tipo pode ser convertido
            para um valor correspondente do tipo <stmt>String</stmt>
            através do que é conhecido por conversão de string
                (<it>string convertion</it>).</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2138" objetivo="8.2">
		<introducao>Para a conversão de um valor de um tipo primitivo
            para um valor do tipo <stmt>String</stmt> correspondente,
            primeiro este valor é convertido para uma instância de uma
            classe apropriada conforme a seguinte regra: se o tipo é
            <stmt>boolean</stmt> cria-se uma instância de
            <stmt>Boolean</stmt>, se o tipo é <stmt>char</stmt>, cria-se
            uma instância de <stmt>Character</stmt>, se o tipo é
            <stmt>byte</stmt>, <stmt>short</stmt> ou <stmt>int</stmt>,
            cria-se uma instância de <stmt>Integer</stmt>, se o tipo é
            <stmt>long</stmt> cria-se uma instância de
            <stmt>Long</stmt>, se o tipo é <stmt>float</stmt> cria-se
            uma instância de <stmt>Float</stmt> e, finalmente, se o tipo
            é <stmt>double</stmt>, cria-se uma instância de
            <stmt>Double</stmt>. A referência obtida é então convertida
            para uma <stmt>String</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2139" objetivo="8.2">
		<introducao>A conversão de uma referência para o tipo
            <stmt>String</stmt> verifica se a referência é
            <stmt>null</stmt>. Caso afirmativo, a <stmt>String</stmt>
            correspondente a &quot;<stmt>null</stmt>&quot; é criada e a
            conversão encontra-se concluída. Caso contrário, é invocado
            o método <stmt>toString()</stmt> que retorna a
            <stmt>String</stmt> de interesse. Observe que toda instância
            em Java é instância da classe <stmt>Object</stmt> que possui
            uma implementação deste método.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2140" objetivo="8.2">
		<introducao>O código abaixo provoca um erro de compilação.<java><![CDATA[public class ArrayToString {
    public static void main(String[] args) {
        int[] a = { 1, 2, 3 };
        System.out.println("a = " + a);
    }
}]]></java>
		</introducao>
		<resposta valor="f">Ocorre uma <it>string conversion</it> do
            <it>array</it> para uma instância de <stmt>String</stmt> em
            conseqüência do envio da mensagem <stmt>toString()</stmt>
            para o objeto do tipo <it>array</it>.</resposta>
	</questao>
	<questao id="2141" objetivo="8.2">
		<introducao>Conversão de <it>string</it> (<it>string
            converstion</it>) aplica-se somente quando um dos operandos
            do operador <stmt>+</stmt> é do tipo <stmt>String</stmt>.
            Neste caso, o outro operando é convertido para uma instância
            de <stmt>String</stmt> e uma nova <stmt>String</stmt>,
            resultado da concatenação das duas instâncias de
            <stmt>String</stmt> é produzida.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2142" objetivo="8.2">
		<introducao>O código abaixo não compila.<java><![CDATA[public class ToString {
    public static void main(String[] args) {
        int[] a = { 1, 2, 3 };
        System.out.println((String)a);
    }
}]]></java>
		</introducao>
		<resposta valor="v">Observe que não há conversão, mesmo
            explícita entre um <it>array</it> de inteiros e uma
            <stmt>String</stmt>. A mensagem <stmt>toString()</stmt> pode
            realizar a conversão desejada se enviada ao objeto <stmt>a</stmt>
		</resposta>
	</questao>
	<questao id="2143" objetivo="8.2">
		<introducao>A sentença <stmt>&quot;a&quot; + a</stmt> onde
            <stmt>a</stmt> é uma variável do tipo primitivo
            <stmt>int</stmt> provoca a criação de 2 instâncias da classe
            <stmt>String</stmt> quando avaliada. Uma delas é decorrente
            da conversão da variável <stmt>a</stmt> para uma instância
            de <stmt>String</stmt> e a outra é resultante da
            concatenação das duas instâncias de <stmt>String</stmt>
            sobre as quais o operador de concatenação irá atuar.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2144" objetivo="8.2">
		<introducao>Uma literal <it>string</it> é sempre do tipo <stmt>String</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2145" objetivo="8.2">
		<introducao>Toda literal <it>string</it> é uma referência para
            uma instância da classe <stmt>String</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2146" objetivo="8.2">
		<introducao>Em Java, cada caractere em uma <stmt>String</stmt> é
            um valor de 16 bits correspondente a um caractere UNICODE.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2147" objetivo="8.2">
		<introducao>A execução da classe abaixo produz como saída <stmt>null</stmt>.</introducao>
		<resposta valor="f">A referência <stmt>str</stmt> não contém o
            valor <stmt>null</stmt>. Ao contrário, contém uma referência
            para uma <stmt>String</stmt> que não possui nenhum
            caractere, ou <stmt>&quot;&quot;</stmt>.</resposta>
	</questao>
	<questao id="2148" objetivo="8.2">
		<introducao>A execução do programa abaixo produz como saída <stmt>OK</stmt>.<java><![CDATA[public class AtribuicaoString {
    public static void main(String[] args) {
        String s1 = new String();
        String s2 = "ok";
        String s3 = s1;
        s1 = s2;
        if (s3.equals(s1)) {
            System.out.println("OK");
        }
    }
}]]></java>
		</introducao>
		<resposta valor="f">
			<stmt>s3</stmt> é uma referência para uma
            <stmt>String</stmt> que não contém nenhum caractere,
            enquanto <stmt>s1</stmt> é uma referência para a literal de
            valor <stmt>ok</stmt>. A condição, em conseqüência, é
            avaliada como falsa.</resposta>
	</questao>
	<questao id="2149" objetivo="8.2">
		<introducao>Uma instância de <stmt>String</stmt> pode receber a
            mensagem <stmt>length()</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2150" objetivo="8.2">
		<introducao>Um objeto <it>array</it> pode receber a mensagem <stmt>length()</stmt>.</introducao>
		<resposta valor="f">
			<it>Array</it>s possuem a propriedade <stmt>length</stmt> e
            não o método <stmt>length()</stmt>, disponível para
            instâncias da classe <stmt>String</stmt>.</resposta>
	</questao>
	<questao id="2151" objetivo="8.2">
		<introducao>A expressão
            <stmt>&quot;casa&quot;.substring(2)</stmt> resulta em uma
            nova <stmt>String</stmt> cujo valor é &quot;<stmt>sa</stmt>&quot;</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2152" objetivo="8.2">
		<introducao>O programa abaixo não compila.<java><![CDATA[public class SubString {
    public static void main(String[] args) {
        System.out.println("casa".substring(2));
    }
}]]></java>
		</introducao>
		<resposta valor="f">Uma literal <it>string</it> é uma referência
            para uma instância de <stmt>String</stmt>.</resposta>
	</questao>
	<questao id="2153" objetivo="8.2">
		<introducao>O código abaixo não compila.<java><![CDATA[public class SubstringSubstring {
    public static void main(String[] args) {
        boolean b;
        String sub;
        sub = "casa".substring(1);
        b = sub.equals("casa".substring(3) + "casa".substring(2,4));
        System.out.println(b);
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="2154" objetivo="8.2">
		<introducao>A saída produzida pelo código abaixo é <stmt>false</stmt>.<java><![CDATA[public class SubstringSubstring {
    public static void main(String[] args) {
        boolean b;
        String sub;
        sub = "casa".substring(1);
        b = sub.equals("casa".substring(3) + "casa".substring(2,4));
        System.out.println(b);
    }
}]]></java>
		</introducao>
		<resposta valor="f">
			<stmt>&quot;casa&quot;.substring(1)</stmt> resulta na
            <stmt>String</stmt> cujo valor é <stmt>asa</stmt>. Ou seja,
            a partir da posição de índice 1 (íncide inicial é zero)
            retorne a <stmt>String</stmt> correspondente. O mesmo vale
            para <stmt>substring(i,j)</stmt>, exceto que o argumento
            <stmt>j</stmt> indica não a posição ou índice final, mas a
            ordem do caractere final, ou seja, em vez de se empregar
            <stmt>j</stmt> como índice, emprega-se <stmt>j-1</stmt>.</resposta>
	</questao>
	<questao id="2155" objetivo="8.2">
		<introducao>A execução do programa abaixo produz como saída <stmt>beija-flor</stmt>.<java><![CDATA[public class Concatenacao {
    public static void main(String[] args) {
        String str = "beija";
        str.concat("-flor");
        System.out.println(str);
    }
}]]></java>
		</introducao>
		<resposta valor="f">
			<stmt>String</stmt> em Java é imutável, ou seja, a
            concatenação realizada, embora produza uma
            <stmt>String</stmt> com o conteúdo sugerido pela questão,
            este é perdido pois nenhuma referência é direcionada para
            este objeto criado. Por outro lado, por ser imutável,
            <stmt>str</stmt> continua fazendo referência para a literal <stmt>beija</stmt>.</resposta>
	</questao>
	<questao id="2156" objetivo="8.2">
		<introducao>O código abaixo compila.<java><![CDATA[public class ConcatenateSB {
    public static void main(String[] args) {
        StringBuffer str = new StringBuffer("guarda");
        str.append("-chuva");
        System.out.println(str);
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2157" objetivo="8.2">
		<introducao>O código abaixo compila.<java><![CDATA[public class ConcatenateSB {
    public static void main(String[] args) {
        StringBuffer str = "guarda";
        str.append("-chuva");
        System.out.println(str);
    }
}]]></java>
		</introducao>
		<resposta valor="f">Apenas <stmt>String</stmt> pode ser iniciada
            com uma literal <it>string</it>. Esta classe exige o emprego
            do construtor
            <stmt>StringBuffter(&quot;guarda&quot;)</stmt>, por exemplo.</resposta>
	</questao>
	<questao id="2158" objetivo="8.2">
		<introducao>Deve ser empregada a classe
            <stmt>StringBuffer</stmt>, em vez da classe
            <stmt>String</stmt>, quando muitas modificações devem ser
            realizadas sobre seqüências de caracteres.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2159" objetivo="8.2">
		<introducao>A classe <stmt>StringBuffer</stmt> não possui o
            método <stmt>concat(String)</stmt>, em contrapartida, possui
            o método <stmt>append(String)</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2160" objetivo="8.1">
		<introducao>O código abaixo não compila.<java><![CDATA[public class Instancia {
    public static void main(String[] args) {
        Math m = new Math();
    }
}]]></java>
		</introducao>
		<resposta valor="v">O construtor da classe <stmt>Math</stmt> é
            declarado <stmt>private</stmt>.</resposta>
	</questao>
	<questao id="2161" objetivo="8.1">
		<introducao>Não é possível criar instância da classe
            <stmt>Math</stmt>, pois o único construtor é
            <stmt>private</stmt> e, por ser declarada
            <stmt>final</stmt>, não é possível estender esta classe.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2162" objetivo="8.1">
		<introducao>A compilação do código abaixo falha.<java><![CDATA[public class Constantes {
    public static void main(String[] args) {
        System.out.println(Math.PI);
        System.out.println(Math.E);
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="2163" objetivo="8.1">
		<introducao>A declaração <stmt>class MinhasFuncoes extends Math
            {}</stmt> é inválida.</introducao>
		<resposta valor="v">A classe <stmt>Math</stmt> é declarada <stmt>final</stmt>.</resposta>
	</questao>
	<questao id="2164" objetivo="8.1">
		<introducao>O código abaixo não compila.<java><![CDATA[public class Absoluto {
    public static void main(String[] args) {
        for (int i = -2; i <= 2 ; i++) {
            System.out.print(Math.abs(i));
        }
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="2165" objetivo="8.1">
		<introducao>A saída produzida pelo código abaixo é <stmt>21012</stmt>.<java><![CDATA[public class Absoluto {
    public static void main(String[] args) {
        for (int i = -2; i <= 2 ; i++) {
            System.out.print(Math.abs(i));
        }
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2166" objetivo="8.1">
		<introducao>A classe <stmt>Math</stmt> possui quatro métodos
            para se obter valores absolutos, todos eles declarados
            <stmt>static</stmt>. São eles: <stmt>int abs(int)</stmt>,
                <stmt>long abs(long)</stmt>, <stmt>float
            abs(float)</stmt> e <stmt>double abs(double)</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2167" objetivo="8.1">
		<introducao>A saída produzida pela execução do programa abaixo é
            <stmt>-Infinity</stmt> seguida de <stmt>Infinity</stmt> e,
            por último, <stmt>Infinity</stmt>.<java><![CDATA[public class Abs {
    public static void main(String[] args) {
        System.out.println(Float.NEGATIVE_INFINITY);
        System.out.println(Math.abs(Float.NEGATIVE_INFINITY));
        System.out.println(Math.abs(Float.POSITIVE_INFINITY));
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2168" objetivo="8.1">
		<introducao>A execução do programa abaixo produz como saída <stmt>OK</stmt>.<java><![CDATA[public class Infinitos {
    public static void main(String[] args) {
        if (Math.abs(Float.NEGATIVE_INFINITY) == Float.POSITIVE_INFINITY) {
            System.out.println("OK");
        }
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2169" objetivo="8.1">
		<introducao>A execução de <stmt>Math.ceil(-9.4)</stmt> produz
            como resultado o valor <stmt>-9.0</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2170" objetivo="8.1">
		<introducao>A execução de <stmt>Math.ceil(9.4)</stmt> produz
            como resultado o valor <stmt>10</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2171" objetivo="8.1">
		<introducao>O método <stmt>double Math.ceil(double)</stmt>
            retorna o menor valor inteiro que é maior ou igual ao valor
            fornecido como argumento.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2172" objetivo="8.1">
		<introducao>O método <stmt>double Math.floor(double)</stmt>
            retorna o maior valor inteiro que é menor que o argumento fornecido.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2173" objetivo="8.1">
		<introducao>A execução de <stmt>Math.floor(-19.6)</stmt> produz
            como resultado o valor <stmt>-20.0</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2174" objetivo="8.1">
		<introducao>A execução de <stmt>Math.floor(-19.002)</stmt>
            produz como resultado o valor <stmt>-20.0</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2175" objetivo="8.1">
		<introducao>A execução de <stmt>Math.floor(19.6)</stmt> produz
            como resultado o valor <stmt>19</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2176" objetivo="8.1">
		<introducao>Os métodos <stmt>floor</stmt> e <stmt>ceil</stmt> da
            classe <stmt>Math</stmt> retornam, ambos, um valor do tipo <stmt>double</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2177" objetivo="8.1">
		<introducao>Os métodos <stmt>floor</stmt> e <stmt>ceil</stmt> da
            classe <stmt>Math</stmt> recebem como argumento, ambos, um
            valor do tipo <stmt>double</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2178" objetivo="8.1">
		<introducao>Embora os métodos <stmt>double
            Math.floor(double)</stmt> e <stmt>double
            Math.ceil(double)</stmt> retornem valores do tipo
            <stmt>double</stmt>, convém ressaltar que, em ambos os
            casos, tratam-se de valores inteiros, cuja parte fracionária
            é nula.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2179" objetivo="8.1">
		<introducao>O método <stmt>long Math.ceil(double)</stmt> retorna
            o menor valor inteiro que é maior ou igual àquele fornecido
            como argumento.</introducao>
		<resposta valor="f">Embora o retorno seja um valor inteiro, este
            é fornecido via <stmt>double</stmt> e não um
            <stmt>long</stmt>, conforme a declaração fornecida.</resposta>
	</questao>
	<questao id="2180" objetivo="8.1">
		<introducao>O programa abaixo compila sem falha e executa sem exceção.<java><![CDATA[public class Maior {
    public static void main(String[] args) {
        long l = Math.max(1,1L);
        System.out.println(l);
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2181" objetivo="8.1">
		<introducao>O programa abaixo compila sem falha e executa sem exceção.<java><![CDATA[public class Maior {
    public static void main(String[] args) {
        int l = Math.max(1,1L);
        System.out.println(l);
    }
}]]></java>
		</introducao>
		<resposta valor="f">Não compila, pois é empregada o método
                <stmt>long Math.max(long,long)</stmt>. O valor do tipo
            <stmt>long</stmt> retornado não pode ser implicitamente
            depositado em uma variável do tipo <stmt>int</stmt>.</resposta>
	</questao>
	<questao id="2182" objetivo="8.1">
		<introducao>O código abaixo não compila.<java><![CDATA[public class Maiores {
    public static void main(String[] args) {
        float f1 = Math.max(-0,0);
        float f2 = Math.min(-0,0);
        System.out.println(f1 + f2);
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="2183" objetivo="8.1">
		<introducao>A saída produzida pelo código abaixo é <stmt>0.0</stmt>.<java><![CDATA[public class Maiores {
    public static void main(String[] args) {
        float f1 = Math.max(-0,0);
        float f2 = Math.min(-0,0);
        System.out.println(f1 + f2);
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2184" objetivo="8.1">
		<introducao>O método <stmt>Math.randon()</stmt> retorna um valor
            do tipo <stmt>double</stmt> que é maior ou igual a
            <stmt>0.0</stmt> e menor que <stmt>1.0</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2185" objetivo="8.1">
		<introducao>O método <stmt>Math.randon(3)</stmt> retorna um
            valor do tipo <stmt>double</stmt> que é maior ou igual a
            <stmt>0.0</stmt> e menor que <stmt>3.0</stmt>.</introducao>
		<resposta valor="f">Este método não recebe nenhum argumento.</resposta>
	</questao>
	<questao id="2186" objetivo="8.1">
		<introducao>O código abaixo não compila.<java><![CDATA[public class Aleatorios {
    public static void main(String[] args) {
        int[] sorteios = new int[100];

        for (int i = 0; i < 1000 * 1000; i++) {
            sorteios[(int) (Math.random() * sorteios.length)]++;
        }

        int min = 0;
        int max = 0;
        for (int i = 0; i < sorteios.length; i++) {
            min = sorteios[i] < sorteios[min] ? i : min;
            max = sorteios[i] > sorteios[max] ? i : max;
        }

        System.out.println("Mais sorteado: " + max + " #" + sorteios[max]);
        System.out.println("Menos sorteado: " + min + " #" + sorteios[min]);
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="2187" objetivo="8.1">
		<introducao>O código realiza 1 milhão de sorteios de números de
            0 a 99, inclusive, e posteriormente imprime o número mais
            sorteado e aquele menos sorteado, acompanhados do respectivo
            número de ocorrências.<java><![CDATA[public class Aleatorios {
    public static void main(String[] args) {
        int[] sorteios = new int[100];

        for (int i = 0; i < 1000 * 1000; i++) {
            sorteios[(int) (Math.random() * sorteios.length)]++;
        }

        int min = 0;
        int max = 0;
        for (int i = 0; i < sorteios.length; i++) {
            min = sorteios[i] < sorteios[min] ? i : min;
            max = sorteios[i] > sorteios[max] ? i : max;
        }

        System.out.println("Mais sorteado: " + max + " #" + sorteios[max]);
        System.out.println("Menos sorteado: " + min + " #" + sorteios[min]);
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2188" objetivo="8.1">
		<introducao>Se retirarmos o sufixo <stmt>f</stmt> de
            <stmt>0.0f</stmt> do código abaixo, então podemos afirmar
            que o código resultante não compila.<java><![CDATA[public class Promocao {
    public static void main(String[] args) {
        int i = Math.round(0.0f);
    }
}]]></java>
		</introducao>
		<resposta valor="v">Há o método <stmt>int
            Math.round(float)</stmt> e o método <stmt>long
            Math.round(double)</stmt>. Se o sufixo é retirado, o
            argumento do tipo <stmt>float</stmt> torna-se em um do tipo
            <stmt>double</stmt>, que emprega a segunda forma deste
            método que retorna <stmt>long</stmt>, que não pode ser
            depositado em uma variável do tipo <stmt>int</stmt>.</resposta>
	</questao>
	<questao id="2189" objetivo="8.1">
		<introducao>O código abaixo produz como saída <stmt>menor</stmt>.<java><![CDATA[public class Comparacao {
    public static void main(String[] args) {
        if (Math.min(-0.0, 0.0) < 0.0) {
            System.out.println("menor");
        } else if (Math.min(-0.0, 0.0) == 0.0) {
            System.out.println("igual");
        } else {
            System.out.println("maior");
        }
    }
}]]></java>
		</introducao>
		<resposta valor="f">A saída é <stmt>igual</stmt>.</resposta>
	</questao>
	<questao id="2190" objetivo="8.1">
		<introducao>O código abaixo produz como saída <stmt>igual</stmt>.<java><![CDATA[public class Comparacao {
    public static void main(String[] args) {
        if (Math.min(-0.0, 0.0) < 0.0) {
            System.out.println("menor");
        } else if (Math.min(-0.0, 0.0) == 0.0) {
            System.out.println("igual");
        } else {
            System.out.println("maior");
        }
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2191" objetivo="8.1">
		<introducao>O código abaixo produz como saída <stmt>maior</stmt>.<java><![CDATA[public class Comparacao {
    public static void main(String[] args) {
        if (Math.min(-0.0, 0.0) < 0.0) {
            System.out.println("menor");
        } else if (Math.min(-0.0, 0.0) == 0.0) {
            System.out.println("igual");
        } else {
            System.out.println("maior");
        }
    }
}]]></java>
		</introducao>
		<resposta valor="f">A saída é <stmt>igual</stmt>.</resposta>
	</questao>
	<questao id="2192" objetivo="8.1">
		<introducao>O código abaixo não compila.<java><![CDATA[public class Comparacao {
    public static void main(String[] args) {
        if (Math.min(-0.0, 0.0) < 0.0) {
            System.out.println("menor");
        } else if (Math.min(-0.0, 0.0) == 0.0) {
            System.out.println("igual");
        } else {
            System.out.println("maior");
        }
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="2193" objetivo="8.1">
		<introducao>A compilação da sentença <stmt>Math.sqrt(-1)</stmt> falha.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="2194" objetivo="8.1">
		<introducao>O retorno de <stmt>Math.sqrt(-1)</stmt> é <stmt>NaN</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2195" objetivo="8.1">
		<introducao>Pode-se extrair a raiz quadrada de um número em Java
            através do emprego do método <stmt>double
            sqrt(double)</stmt>, pertencente à classe <stmt>java.lang.Math</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2196" objetivo="8.1">
		<introducao>Os métodos <stmt>sin</stmt>, <stmt>cos</stmt>, entre
            outros da classe <stmt>Math</stmt>, recebem como argumento
            um valor do tipo <stmt>double</stmt> correspondentes a um
            ângulo em radianos.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2197" objetivo="8.1">
		<introducao>A conversão de radianos para graus e de graus para
            radianos pode ser realizada através, respectivamente, dos
            métodos <stmt>toDegrees()</stmt> e <stmt>toRadians()</stmt>,
            ambos pertencentes à classe <stmt>java.lang.Math</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2198" objetivo="8.1">
		<introducao>O código abaixo escrito em Java, versão 1.4, não compila.<java><![CDATA[public class NaN {
    public static void main(String[] args) {
        double d1 = Double.NaN;
        double d2 = d1;

        if (d1 == d2) {
            System.out.println("OK");
        } else {
            assert false : "NaN != NaN";
        }
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="2199" objetivo="8.1">
		<introducao>A saída produzida pela execução do programa abaixo é <stmt>OK</stmt>.<java><![CDATA[public class NaN {
    public static void main(String[] args) {
        double d1 = Double.NaN;
        double d2 = d1;

        if (d1 == d2) {
            System.out.println("OK");
        } else {
            assert false : "NaN != NaN";
        }
    }
}]]></java>
		</introducao>
		<resposta valor="f">NaN não é igual a nada, nem mesmo a si mesmo.</resposta>
	</questao>
	<questao id="2200" objetivo="8.1">
		<introducao>A expressão <stmt>Double.NaN == Double.NaN</stmt>
            equivale ao valor <stmt>false</stmt> do tipo <stmt>boolean</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2201" objetivo="8.1">
		<introducao>A expressão <stmt>Double.NaN != Double.NaN</stmt>
            equivale ao valor <stmt>true</stmt> do tipo <stmt>boolean</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2202" objetivo="8.3">
		<introducao>
			<it>Wrapper classes</it> são classes que
            &quot;embrulham&quot; os tipos primitivos em objetos de tal
            forma que estes possam ser empregados em coleções, por exemplo.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2203" objetivo="8.3">
		<introducao>Um método que retorna uma instância de
            <stmt>Object</stmt> pode empregar uma classe como
            <stmt>Integer</stmt>, por exemplo, para retornar um objeto
            correspondente ao valor do tipo primitivo <stmt>int</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2204" objetivo="8.3">
		<introducao>Há uma classe <it>wrapper</it> para cada tipo
            primitivo em Java.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2205" objetivo="8.3">
		<introducao>A classe <stmt>Boolean</stmt> correspondente ao tipo
            primitivo <stmt>boolean</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2206" objetivo="8.3">
		<introducao>A classe <stmt>Byte</stmt> correspondente ao tipo
            primitivo <stmt>byte</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2207" objetivo="8.3">
		<introducao>A classe <stmt>Short</stmt> correspondente ao tipo
            primitivo <stmt>short</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2208" objetivo="8.3">
		<introducao>A classe <stmt>Integer</stmt> correspondente ao tipo
            primitivo <stmt>int</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2209" objetivo="8.3">
		<introducao>A classe <stmt>Long</stmt> correspondente ao tipo
            primitivo <stmt>long</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2210" objetivo="8.3">
		<introducao>A classe <stmt>Float</stmt> correspondente ao tipo
            primitivo <stmt>float</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2211" objetivo="8.3">
		<introducao>A classe <stmt>Double</stmt> correspondente ao tipo
            primitivo <stmt>double</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2212" objetivo="8.3">
		<introducao>A classe <stmt>Character</stmt> correspondente ao
            tipo primitivo <stmt>char</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2213" objetivo="8.3">
		<introducao>A classe <stmt>Char</stmt> correspondente ao tipo
            primitivo <stmt>char</stmt>.</introducao>
		<resposta valor="f">A classe é <stmt>Character</stmt>.</resposta>
	</questao>
	<questao id="2214" objetivo="8.3">
		<introducao>A classe <stmt>Float</stmt> possui três
            construtores. Um que recebe como argumento um
            <stmt>float</stmt>, outro que recebe um <stmt>double</stmt>
            e o terceiro recebe como argumento uma <stmt>String</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2215" objetivo="8.3">
		<introducao>O código abaixo compila.<java><![CDATA[public class Wrappers {
    public static void main(String[] args) {
        Float f1 = new Float(1.0f);
        Float f2 = new Float(1.0D);
        Float f3 = new Float(f2.toString());

        assert f1.floatValue() == f2.floatValue();
        assert f2.floatValue() == f3.floatValue();
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2216" objetivo="8.3">
		<introducao>A execução do código abaixo gera pelo menos uma
            exceção ou, tecnicamente, uma instância da classe <stmt>AssertionError</stmt>.<java><![CDATA[public class Wrappers {
    public static void main(String[] args) {
        Float f1 = new Float(1.0f);
        Float f2 = new Float(1.0D);
        Float f3 = new Float(f2.toString());

        assert f1.floatValue() == f2.floatValue();
        assert f2.floatValue() == f3.floatValue();
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2217" objetivo="8.3">
		<introducao>A classe <stmt>java.lang.Byte</stmt> possui dois
            construtores: <stmt>Byte(String)</stmt> e <stmt>Byte(byte)</stmt>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2218" objetivo="8.3">
		<introducao>As classes <stmt>Byte</stmt>, <stmt>Short</stmt>,
            <stmt>Integer</stmt>, <stmt>Long</stmt>, <stmt>Float</stmt>
            e <stmt>Double</stmt>, todas elas, herdam da classe <stmt>Number</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2219" objetivo="8.3">
		<introducao>A classe <stmt>java.lang.Boolean</stmt> permite a
            criação de objeto que representa um valor do tipo primitivo <stmt>Boolean</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2220" objetivo="8.3">
		<introducao>Os tipos primitivos em Java não são objetos. Para
            tratá-los como objetos existem várias classes. Uma para cada
            tipo primitivo. Por exemplo, um valor do tipo primitivo
            <stmt>double</stmt> pode ser encapsulado pela classe <stmt>Double</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2221" objetivo="8.3">
		<introducao>A sentença <stmt>true == Boolean.TRUE</stmt> não compila.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2222" objetivo="8.3">
		<introducao>
			<stmt>Boolean.TRUE</stmt> é um objeto da classe
            <stmt>Boolean</stmt> que representa o valor primitivo
            <stmt>true</stmt> do tipo <stmt>boolean</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2223" objetivo="8.3">
		<introducao>A expressão <stmt>Boolean.FALSE</stmt> é uma
            constante do tipo <stmt>boolean</stmt> correspondente ao
            valor <stmt>false</stmt>.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="2224" objetivo="8.3">
		<introducao>Para se obter o valor do tipo <stmt>boolean</stmt>
            encapsulado por uma instância de <stmt>Boolean</stmt> pode
            ser utilizado o método <stmt>booleanValue()</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2225" objetivo="8.3">
		<introducao>O programa abaixo não compila.<java><![CDATA[public class BoolConst {
    public static void main(String[] args) {
        if (Boolean.TRUE.equals(new Boolean(true))) {
            System.out.println("OK");
        }
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="2226" objetivo="8.3">
		<introducao>A execução do programa abaixo gera uma exceção.<java><![CDATA[public class BoolConst {
    public static void main(String[] args) {
        if (Boolean.TRUE.equals(new Boolean(true))) {
            System.out.println("OK");
        }
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="2227" objetivo="8.3">
		<introducao>A saída produzida pela execução do programa abaixo é <stmt>OK</stmt>.<java><![CDATA[public class BoolConst {
    public static void main(String[] args) {
        if (Boolean.TRUE.equals(new Boolean(true))) {
            System.out.println("OK");
        }
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2228" objetivo="8.3">
		<introducao>Para se obter o valor do tipo <stmt>byte</stmt>
            encapsulado por uma instância de <stmt>Byte</stmt> pode ser
            utilizado o método <stmt>byteValue()</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2229" objetivo="8.3">
		<introducao>Para se obter o valor do tipo <stmt>short</stmt>
            encapsulado por uma instância de <stmt>Short</stmt> pode ser
            utilizado o método <stmt>shortValue()</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2230" objetivo="8.3">
		<introducao>Para se obter o valor do tipo <stmt>int</stmt>
            encapsulado por uma instância de <stmt>Integer</stmt> pode
            ser utilizado o método <stmt>intValue()</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2231" objetivo="8.3">
		<introducao>Para se obter o valor do tipo <stmt>int</stmt>
            encapsulado por uma instância de <stmt>Int</stmt> pode ser
            utilizado o método <stmt>intValue()</stmt>.</introducao>
		<resposta valor="f">Não existe a classe <stmt>Int</stmt>, mas <stmt>Integer</stmt>.</resposta>
	</questao>
	<questao id="2232" objetivo="8.3">
		<introducao>Para se obter o valor do tipo <stmt>long</stmt>
            encapsulado por uma instância de <stmt>Long</stmt> pode ser
            utilizado o método <stmt>longValue()</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2233" objetivo="8.3">
		<introducao>Para se obter o valor do tipo <stmt>float</stmt>
            encapsulado por uma instância de <stmt>Float</stmt> pode ser
            utilizado o método <stmt>floatValue()</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2234" objetivo="8.3">
		<introducao>Para se obter o valor do tipo <stmt>double</stmt>
            encapsulado por uma instância de <stmt>Double</stmt> pode
            ser utilizado o método <stmt>doubleValue()</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2235" objetivo="8.3">
		<introducao>A expressão <stmt>a + b</stmt> não compila caso as
            variáveis <stmt>a</stmt> e <stmt>b</stmt> sejam referências
            para objetos do tipo <stmt>Integer</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2236" objetivo="8.3">
		<introducao>Embora uma instância de <stmt>Integer</stmt>
            representa um valor do tipo primitivo <stmt>int</stmt>, as
            operações aritméticas são realizadas como soma, por exemplo,
            são realizadas exclusivamente através do emprego de tipos
            primitivos, ou seja, <stmt>new Integer(3) + new
            Integer(2)</stmt> não dá origem ao valor <stmt>5</stmt> ou a
            uma instância de <stmt>Integer</stmt> que retém este valor.
            De fato, esta expressão nem compila.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2237" objetivo="8.3">
		<introducao>O código abaixo não compila.<java><![CDATA[public class IntegerOperacoes {
    public static void main(String[] args) {
        System.out.println("SOMA: " + new Integer(2) + new Integer(3));
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="2238" objetivo="8.3">
		<introducao>O código abaixo não compila.<java><![CDATA[public class IntegerOperacoes {
    public static void main(String[] args) {
        System.out.println("SOMA: " + (new Integer(2) + new Integer(3)));
    }
}]]></java>
		</introducao>
		<resposta valor="v">Não é possível aplicar o operador
            <stmt>+</stmt> a instâncias de <stmt>Integer</stmt>.</resposta>
	</questao>
	<questao id="2239" objetivo="8.3">
		<introducao>O código abaixo, quando executado, provoca uma exceção.<java><![CDATA[public class IntegerOperacoes {
    public static void main(String[] args) {
        System.out.println("SOMA: " + new Integer(2) + new Integer(3));
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="2240" objetivo="8.3">
		<introducao>A saída produzida pelo código abaixo é <stmt>SAIDA: 5</stmt>.<java><![CDATA[public class IntegerOperacoes {
    public static void main(String[] args) {
        System.out.println("SOMA: " + new Integer(2) + new Integer(3));
    }
}]]></java>
		</introducao>
		<resposta valor="f">O resultado é: <stmt>SAIDA: 23</stmt>.</resposta>
	</questao>
	<questao id="2241" objetivo="8.3">
		<introducao>Para uma instância de <stmt>Boolean</stmt> receber
            um valor do tipo primitivo <stmt>boolean</stmt>, por
            exemplo, <stmt>false</stmt>, pode ser empregado o método <stmt>setBoolean(boolean)</stmt>.</introducao>
		<resposta valor="f">Não existe tal método.</resposta>
	</questao>
	<questao id="2242" objetivo="8.3">
		<introducao>À semelhança da classe <stmt>String</stmt>,
            instâncias de <stmt>Boolean</stmt> são imutáveis.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2243" objetivo="8.3">
		<introducao>À semelhança da classe <stmt>String</stmt>,
            instâncias de <stmt>Character</stmt> são imutáveis.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2244" objetivo="8.3">
		<introducao>À semelhança da classe <stmt>String</stmt>,
            instâncias de <stmt>Byte</stmt> são imutáveis.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2245" objetivo="8.3">
		<introducao>À semelhança da classe <stmt>String</stmt>,
            instâncias de <stmt>Short</stmt> são imutáveis.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2246" objetivo="8.3">
		<introducao>À semelhança da classe <stmt>String</stmt>,
            instâncias de <stmt>Integer</stmt> são imutáveis.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2247" objetivo="8.3">
		<introducao>À semelhança da classe <stmt>String</stmt>,
            instâncias de <stmt>Float</stmt> são imutáveis.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2248" objetivo="8.3">
		<introducao>À semelhança da classe <stmt>String</stmt>,
            instâncias de <stmt>Double</stmt> são imutáveis.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2249" objetivo="8.3">
		<introducao>As instâncias obtidas das classes
            <stmt>Character</stmt>, <stmt>Boolean</stmt>,
            <stmt>Byte</stmt>, <stmt>Short</stmt>, <stmt>Integer</stmt>,
            <stmt>Long</stmt>, <stmt>Float</stmt> e <stmt>Double</stmt>
            são imutáveis. Ou seja, os valores dos tipos primitivos
            correspondentes que tais instâncias representam não podem
            ser alterados.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2250" objetivo="8.3">
		<introducao>A classe <stmt>Boolean</stmt> não implementa a
            interface <stmt>Comparable</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2251" objetivo="8.3">
		<introducao>A interface <stmt>Comparable</stmt> compreende um
            único método: <stmt>int compareTo(Object)</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2252" objetivo="8.3">
		<introducao>A classe <stmt>Integer</stmt> possui o método <stmt>integerValue()</stmt>.</introducao>
		<resposta valor="f">Um dos métodos desta classe é
            <stmt>intValue()</stmt>, que retorna o valor do tipo
            primitivo <stmt>int</stmt> armazenado na instância em questão.</resposta>
	</questao>
	<questao id="2253" objetivo="8.3">
		<introducao>A classe <stmt>Character</stmt> possui o método <stmt>characterValue()</stmt>.</introducao>
		<resposta valor="f">Um dos métodos desta classe é
            <stmt>charValue()</stmt>, que retorna o valor do tipo
            primitivo <stmt>char</stmt> armazenado na instância em questão.</resposta>
	</questao>
	<questao id="2254" objetivo="8.3">
		<introducao>A classe <stmt>Byte</stmt> implementa a interface <stmt>Comparable</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2255" objetivo="8.3">
		<introducao>A classe <stmt>Short</stmt> implementa a interface <stmt>Comparable</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2256" objetivo="8.3">
		<introducao>A classe <stmt>Integer</stmt> implementa a interface <stmt>Comparable</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2257" objetivo="8.3">
		<introducao>A classe <stmt>Long</stmt> implementa a interface <stmt>Comparable</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2258" objetivo="8.3">
		<introducao>A classe <stmt>Float</stmt> implementa a interface <stmt>Comparable</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2259" objetivo="8.3">
		<introducao>A classe <stmt>Double</stmt> implementa a interface <stmt>Comparable</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2260" objetivo="8.3">
		<introducao>A classe <stmt>Number</stmt> é abstrata e declara
            seis métodos: <stmt>byte byteValue()</stmt>, <stmt>short
            shortValue()</stmt>, <stmt>int intValue()</stmt>, <stmt>long
            longValue()</stmt>, <stmt>float floatValue()</stmt> e
                <stmt>double doubleValue()</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2261" objetivo="8.3">
		<introducao>As classes que &quot;embrulham&quot; (<it>wrapper
            classes</it>) os tipos primitivos herdam da classe
            <stmt>Number</stmt>, exceto as classes <stmt>Boolean</stmt>
            e <stmt>Character</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2262" objetivo="8.3">
		<introducao>Todos os métodos <stmt>valueOf</stmt> das classes
            <stmt>Boolean</stmt>, <stmt>Byte</stmt>, <stmt>Short</stmt>,
            <stmt>Integer</stmt>, <stmt>Long</stmt>, <stmt>Float</stmt>
            e <stmt>Double</stmt> retornam uma instância da classe cujo
            objeto em questão recebe esta mensagem.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2263" objetivo="8.3">
		<introducao>O método <stmt>parseDouble(String)</stmt>, da classe
            <stmt>Double</stmt>, retorna um valor do tipo primitivo <stmt>double</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2264" objetivo="8.3">
		<introducao>O método <stmt>parseFloat(String)</stmt>, da classe
            <stmt>Float</stmt>, retorna um valor do tipo primitivo <stmt>float</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2265" objetivo="8.3">
		<introducao>O método <stmt>parseInt(String)</stmt>, da classe
            <stmt>Integer</stmt>, retorna um valor do tipo primitivo <stmt>int</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2266" objetivo="8.3">
		<introducao>O método <stmt>parseLong(String)</stmt>, da classe
            <stmt>Long</stmt>, retorna um valor do tipo primitivo <stmt>long</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2267" objetivo="8.3">
		<introducao>O método <stmt>parseShort(String)</stmt>, da classe
            <stmt>Short</stmt>, retorna um valor do tipo primitivo <stmt>short</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2268" objetivo="5.2">
		<introducao>Em Java, estamos interessado na comparação entre
            variáveis de tipos primitivos, entre variáveis referência e
            entre objetos.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2269" objetivo="5.2">
		<introducao>O método <stmt>boolean equals(Object)</stmt> é
            herdado por toda classe em Java.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2270" objetivo="5.2">
		<introducao>Todo objeto em Java pode ser comparado com outro
            através do método <stmt>boolean equals(Object)</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2271" objetivo="5.2">
		<introducao>O método <stmt>boolean equals(Object)</stmt> não se
            aplica aos tipos primitivos. Para comparar valores dos tipos
            primitivos usa-se o operador <stmt>==</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2272" objetivo="5.2">
		<introducao>O operador <stmt>==</stmt> retorna o valor
            <stmt>true</stmt> do tipo <stmt>boolean</stmt> se e somente
            se os operandos comparados são equivalentes.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2273" objetivo="5.2">
		<introducao>Quando o operador <stmt>==</stmt> é empregado com
            operados que são referências, está-se verificando se estes
            operandos referem-se ao mesmo objeto.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2274" objetivo="5.2">
		<introducao>Quando o operador <stmt>==</stmt> é empregado com
            operados que são referências, está-se verificando se os
            objetos correspondentes são iguais, ou seja, suas
            propriedades possuem os mesmos valores.</introducao>
		<resposta valor="f">Será <stmt>true</stmt> se ambas as
            referências indicam o mesmo objeto.</resposta>
	</questao>
	<questao id="2275" objetivo="5.2">
		<introducao>Quando se emprega o operador <stmt>==</stmt>,
            está-se comparando os padrões de bits dos operandos.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2276" objetivo="5.2">
		<introducao>Se duas referências <stmt>a</stmt> e <stmt>b</stmt>
            estão referenciando o mesmo objeto, então possuem o mesmo
            padrão de bits e, neste caso, <stmt>a==b</stmt> é avaliada
            como <stmt>true</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2277" objetivo="5.2">
		<introducao>Se duas referências <stmt>a</stmt> e <stmt>b</stmt>
            estão referenciando objetos distintos de uma mesma classe,
            então a expressão <stmt>a==b</stmt> sempre será avaliada
            como <stmt>false</stmt>, independente dos estados destes objetos.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2278" objetivo="5.2">
		<introducao>O código abaixo não compila.<java><![CDATA[public class Compara {
    public static void main(String[] args) {
        int a = 3;
        int b = 2;

        if (a == b) {
            System.out.println("IGUAIS");
        } else {
            System.out.println("DIFERENTES");
        }
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="2279" objetivo="5.2">
		<introducao>O código abaixo, quando executado, produz como saída <stmt>IGUAIS</stmt>.<java><![CDATA[public class Compara {
    public static void main(String[] args) {
        int a = 3;
        int b = 2;

        if (a == b) {
            System.out.println("IGUAIS");
        } else {
            System.out.println("DIFERENTES");
        }
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="2280" objetivo="5.2">
		<introducao>O código abaixo não compila.<java><![CDATA[class A { int a = 1; }
class B { int a = 1; }

public class ComparaReferencias {
    public static void main(String[] args) {
        if (new A() == new B()) {
            System.out.println("IGUAIS");
        } else {
            System.out.println("DIFERENTES");
        }
    }
}]]></java>
		</introducao>
		<resposta valor="v">
			<stmt>A</stmt> e <stmt>B</stmt> pertencem a hierarquias
            distintas e, portanto, não é possível comparar via operador
            <stmt>==</stmt>, referências para instâncias destas classes.</resposta>
	</questao>
	<questao id="2281" objetivo="5.2">
		<introducao>Se duas classes <stmt>A</stmt> e <stmt>B</stmt>
            pertencem a hierarquias distinta, então não é permitido
            comparar, via operador <stmt>==</stmt>, referências para
            instâncias destas classes.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2282" objetivo="5.2">
		<introducao>Se uma classe herda de outra classe, então
            referências para estas duas classes podem ser comparadas via
            operador <stmt>==</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2283" objetivo="5.2">
		<introducao>O código abaixo não compila.<java><![CDATA[class A { int a = 1; }
class B extends A { int a = 2; }

public class ComparaReferencias {
    public static void main(String[] args) {
        if (new A() == new B()) {
            System.out.println("IGUAIS");
        } else {
            System.out.println("DIFERENTES");
        }
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="2284" objetivo="5.2">
		<introducao>O código abaixo, quando executado, gera uma exceção.<java><![CDATA[class A { int a = 1; }
class B extends A { int a = 2; }

public class ComparaReferencias {
    public static void main(String[] args) {
        if (new A() == new B()) {
            System.out.println("IGUAIS");
        } else {
            System.out.println("DIFERENTES");
        }
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="2285" objetivo="5.2">
		<introducao>O código abaixo, quando executado, sempre irá gerar
            como saída <stmt>DIFERENTES</stmt>.<java><![CDATA[class A { int a = 1; }
class B extends A { int a = 2; }

public class ComparaReferencias {
    public static void main(String[] args) {
        if (new A() == new B()) {
            System.out.println("IGUAIS");
        } else {
            System.out.println("DIFERENTES");
        }
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2286" objetivo="5.2">
		<introducao>A expressão <stmt>new A() == new A()</stmt> sempre
            irá resultar em <stmt>false</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2287" objetivo="5.2">
		<introducao>O código abaixo não compila.<java><![CDATA[class A { int a = 1; }
class B { int a = 2; }

public class ComparaReferencias {
    public static void main(String[] args) {
        if (new A() == (Object)new B()) {
            System.out.println("IGUAIS");
        } else {
            System.out.println("DIFERENTES");
        }
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="2288" objetivo="5.2">
		<introducao>Quando executado, o código abaixo gera uma exceção: <stmt>ClassCastException</stmt>.<java><![CDATA[class A { int a = 1; }
class B { int a = 2; }

public class ComparaReferencias {
    public static void main(String[] args) {
        if (new A() == (Object)new B()) {
            System.out.println("IGUAIS");
        } else {
            System.out.println("DIFERENTES");
        }
    }
}]]></java>
		</introducao>
		<resposta valor="f">Nenhuma exceção é gerada.</resposta>
	</questao>
	<questao id="2289" objetivo="5.2">
		<introducao>Quaisquer que sejam as classes das quais duas
            instâncias sejam criadas e indicadas pelas referências
            <stmt>a</stmt> e <stmt>b</stmt>, a expressão <stmt>a ==
            (Object)b</stmt> é válida e sempre irá resultar em um valor <stmt>false</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2290" objetivo="5.2">
		<introducao>O código abaixo não compila.<java><![CDATA[public class ComparaRefs {
    public static void main(String[] args) {
        ComparaRefs a = new ComparaRefs();
        Object b = a;
        System.out.println(b == a);
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="2291" objetivo="5.2">
		<introducao>Quando executado, o código abaixo exibe como saída <stmt>true</stmt>.<java><![CDATA[public class ComparaRefs {
    public static void main(String[] args) {
        ComparaRefs a = new ComparaRefs();
        Object b = a;
        System.out.println(b == a);
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2292" objetivo="5.2">
		<introducao>A comparação de referências via o operador
            <stmt>==</stmt> compara o padrão de bits das referências, ou
            seja, se estas estão indicando um mesmo objeto ou não. Para
            comparar se dois objetos distintos possuem conteúdos
            semelhantes, qualquer que seja a definição de semelhança,
            deve-se empregar sobrepor o métodos <stmt>boolean
            equals(Object)</stmt> herdado da classe <stmt>Object</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2293" objetivo="5.2">
		<introducao>A saída produzida pela execução do programa abaixo é <stmt>false</stmt>.<java><![CDATA[public class Comparacao {
    public static void main(String[] args) {
        String str1 = "casa";
        String str2 = "CASA";
        System.out.println(str1 == str2.toLowerCase());
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2294" objetivo="5.2">
		<introducao>A saída produzida pela execução do programa abaixo é <stmt>true</stmt>.<java><![CDATA[public class Comparacao {
    public static void main(String[] args) {
        String str1 = "casa";
        String str2 = "casa";
        System.out.println(str1 == str2);
    }
}]]></java>
		</introducao>
		<resposta valor="v">Referem-se ao mesmo objeto.</resposta>
	</questao>
	<questao id="2295" objetivo="5.2">
		<introducao>A saída produzida pela execução do programa abaixo é <stmt>true</stmt>.<java><![CDATA[public class Comparacao {
    public static void main(String[] args) {
        String str1 = new String("casa");
        String str2 = "casa";
        System.out.println(str1 == str2.toLowerCase());
    }
}]]></java>
		</introducao>
		<resposta valor="f">São objetos distintos.</resposta>
	</questao>
	<questao id="2296" objetivo="5.2">
		<introducao>Em Java não é permitida a comparação
                <stmt>&quot;CASA&quot; == &quot;casa&quot;</stmt>.</introducao>
		<resposta valor="f">Uma literal <it>string</it> é uma referência
            para um objeto do tipo <stmt>String</stmt>.</resposta>
	</questao>
	<questao id="2297" objetivo="5.2">
		<introducao>O programa abaixo não compila.<java><![CDATA[public class Comparacao2 {
    public static void main(String[] args) {
        System.out.println("A" == "A");
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="2298" objetivo="5.2">
		<introducao>A saída produzida pela execução do programa abaixo é <stmt>true</stmt>.<java><![CDATA[public class Comparacao2 {
    public static void main(String[] args) {
        System.out.println("A" == "A");
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2299" objetivo="5.2">
		<introducao>A sentença
                <stmt>&quot;A&quot;.toLowerCase().intern() ==
            &quot;a&quot;.intern()</stmt> é avaliada como <stmt>true</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2300" objetivo="5.2">
		<introducao>A sentença
                <stmt>&quot;A&quot;.toLowerCase().intern() ==
            &quot;a&quot;.intern()</stmt> é inválida em Java.</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="2301" objetivo="5.2">
		<introducao>O código abaixo não compila.<java><![CDATA[public class Comparacao4 {
    public static void main(String[] args) {
        Double d = new Double("1.2");
        Float  f = new Float("1.2");

        System.out.println(d == f);
    }
}]]></java>
		</introducao>
		<resposta valor="v">Tipos incompatíveis.</resposta>
	</questao>
	<questao id="2302" objetivo="5.2">
		<introducao>O código abaixo não compila.<java><![CDATA[public class Comparacao4 {
    public static void main(String[] args) {
        Double d = new Double("1.2");
        Float  f = new Float("1.2");

        System.out.println(d == (Object)f);
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="2303" objetivo="5.2">
		<introducao>O código abaixo, quando executado, produz como saída <stmt>false</stmt>.<java><![CDATA[public class Comparacao4 {
    public static void main(String[] args) {
        Double d = new Double("1.2");
        Float  f = new Float("1.2");

        System.out.println(d == (Object)f);
    }
}]]></java>
		</introducao>
		<resposta valor="v">São comparadas as referências e não o
            conteúdo dos objetos.</resposta>
	</questao>
	<questao id="2304" objetivo="5.2">
		<introducao>O código abaixo compila satisfatoriamente.<java><![CDATA[public class Comparacao5 {
    public static void main(String[] args) {
        int v = 5;
        Long l = new Long(v);
        Integer i = new Integer(v);
        System.out.println(l.equals(i));
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2305" objetivo="5.2">
		<introducao>O código abaixo, quando executado, produz como saída <stmt>false</stmt>.<java><![CDATA[public class Comparacao5 {
    public static void main(String[] args) {
        int v = 5;
        Long l = new Long(v);
        Integer i = new Integer(v);
        System.out.println(l.equals(i));
    }
}]]></java>
		</introducao>
		<resposta valor="v">Os objetos são de classes distintas.</resposta>
	</questao>
	<questao id="2306" objetivo="5.2">
		<introducao>A execução do programa abaixo produz como saída
                <stmt>false true</stmt>.<java><![CDATA[public class Comparacao6 {
    public static void main(String[] args) {
        Integer x = new Integer("1");
        Integer y = new Integer("1");
        System.out.print(x == y);
        System.out.println(" " + x.equals(y));
    }
}]]></java>
		</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2307" objetivo="5.2">
		<introducao>A execução do programa abaixo produz como saída
                <stmt>true true</stmt>.<java><![CDATA[public class Comparacao6 {
    public static void main(String[] args) {
        Integer x = new Integer("1");
        Integer y = new Integer("1");
        System.out.print(x == y);
        System.out.println(" " + x.equals(y));
    }
}]]></java>
		</introducao>
		<resposta valor="f">A expressão <stmt>x == y</stmt> é avaliada
            como <stmt>false</stmt>, pois são referências para dois
            objetos distintos.</resposta>
	</questao>
	<questao id="2308" objetivo="5.2">
		<introducao>O método <stmt>boolean equals(Object)</stmt> é
            herdado por toda classe em Java, exceto a classe
            <stmt>Object</stmt>, que não possui ancestral.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2309" objetivo="5.2">
		<introducao>A classe <stmt>StringBuffer</stmt> não fornece uma
            sobreposição do método <stmt>boolean equals(Object)</stmt>,
            ou seja, <stmt>sb1.equals(sb2)</stmt> será avaliada como
            verdadeiro se e somente se <stmt>sb1 == sb2</stmt>.</introducao>
		<resposta valor="v"/>
	</questao>
	<questao id="2310" objetivo="5.2">
		<introducao>O código abaixo não compila.<java><![CDATA[public class Comparacao7 {
    public static void main(String[] args) {
        System.out.print("A".equals("a".toUpperCase()) + " ");
        System.out.print(new StringBuffer("A").equals("A"));
    }
}]]></java>
		</introducao>
		<resposta valor="f"/>
	</questao>
	<questao id="2311" objetivo="5.2">
		<introducao>O código abaixo, quando executado, produz como saída
                <stmt>true false</stmt>.<java><![CDATA[public class Comparacao7 {
    public static void main(String[] args) {
        System.out.print("A".equals("a".toUpperCase()) + " ");
        System.out.print(new StringBuffer("A").equals("A"));
    }
}]]></java>
		</introducao>
		<resposta valor="v">A classe <stmt>StringBuffer</stmt> não
            sobrepõe o método <stmt>boolean equals(Object)</stmt>,
            herdado de <stmt>Object</stmt>.</resposta>
	</questao>
	<questao id="2312" objetivo="5.2">
		<introducao>O código abaixo, quando executado, produz como saída
                <stmt>true true</stmt>.<java><![CDATA[public class Comparacao7 {
    public static void main(String[] args) {
        System.out.print("A".equals("a".toUpperCase()) + " ");
        System.out.print(new StringBuffer("A").equals("A"));
    }
}]]></java>
		</introducao>
		<resposta valor="f">A classe <stmt>StringBuffer</stmt> não
            sobrepõe o método <stmt>boolean equals(Object)</stmt>,
            herdado de <stmt>Object</stmt>. Ou seja, só retornaria
            <stmt>true</stmt> caso a instância criada fosse a mesma
            indicada pela referência fornecida como argumento, o que não
            é o caso.</resposta>
	</questao>
	<questao id="2313" objetivo="5.2">
		<introducao>O código abaixo, quando executado, produz como saída
                <stmt>true false</stmt>.<java><![CDATA[public class Comparacao7 {
    public static void main(String[] args) {
        System.out.print("A".equals("a".toUpperCase()) + " ");
        StringBuffer sb1 = new StringBuffer("A");
        StringBuffer sb2 = new StringBuffer("A");
        System.out.print(sb1.equals(sb2));
    }
}]]></java>
		</introducao>
		<resposta valor="v">A classe <stmt>StringBuffer</stmt> não
            sobrepõe o método <stmt>boolean equals(Object)</stmt>,
            herdado de <stmt>Object</stmt>. Ou seja, só retornaria
            <stmt>true</stmt> caso a instância criada fosse a mesma
            indicada pela referência fornecida como argumento, o que não
            é o caso.</resposta>
	</questao>
	
    <questao id="0" objetivo="9.1">
		<introducao>Existe a classe <stmt>Collections</stmt> e a interface 
<stmt>Collection</stmt>.
		</introducao>
		<resposta valor="v">
		</resposta>
	</questao>
	
	    <questao id="0" objetivo="9.1">
		<introducao>As interfaces <stmt>Set</stmt> e <stmt>List</stmt> herdam
da interface <stmt>Collection</stmt>.
		</introducao>
		<resposta valor="v">
		</resposta>
	</questao>
	
	    <questao id="0" objetivo="9.1">
		<introducao>A interface <stmt>Map</stmt> herda da interface
<stmt>Collection</stmt>
		</introducao>
		<resposta valor="f">
		</resposta>
	</questao>

<questao id="0" objetivo="9.1">
	<introducao>Várias operações são executadas sobre coleções: adicionar objetos;
		remover objetos; encontrar um objeto ou grupo de objetos; recuperar um objeto
		armazenado na coleção e iterar sobre uma coleção.
	</introducao>
	<resposta valor="v">
	</resposta>
</questao>

</Avaliacao>
