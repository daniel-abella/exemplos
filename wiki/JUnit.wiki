Introdução ao JUnit 4

= Introdução =

Em _Pragmatica Unit Testing: In Java with JUnit_, Andrew Hunt e David Thomas definem teste de unidade como "código escrito por um desenvolvedor que exercita um trecho de código pequeno e de uma área específica da funcionalidade do código que está sendo testado". Eles ainda acrescentam que testes de unidade são desenvolvidos para provar que um trecho de código faz o que o desenvolvedor imagina que deveria fazer.

Nesta breve introdução são fornecidos os passos básicos para uso do JUnit para a confecção de testes de unidade (em Java). 

= Processo =
Não é necessário seguir os passos abaixo. Esta é a abordagem geralmente conhecida por "desenvolvimento baseado em testes". 

 * Escreva um ou mais testes de unidade correspondentes à função a ser desenvolvida
 * Execute os testes de unidade (eles irão falhar, afinal, a funcionalidade ainda não foi implementada)
 * Escreva código que implementa a função e repita o passo anterior até que todos os testes sejam executados satisfatoriamente. 

= Onde obter o JUnit e outras informações =
Em http://www.junit.org você poderá obter a versão mais recente, assim como tutoriais acerca do emprego do JUnit. No momento em que este texto é escrito, a versão mais recente é a versão 4.4.

= Instalar o JUnit =
Obtenha o arquivo contendo o JUnit em http://www.junit.org. No momento, a versão disponível é fornecida no arquivo *junit4.4.zip*. Simplesmente descomprima este arquivo, o que cria o diretório *junit4.4*. Neste diretório criado encontra-se o arquivo *junit-4.4.jar*. Acrescente este arquivo ao _classpath_. Isto pode ser feito de várias formas, por exemplo, pela definição da variável *CLASSPATH* ou toda vez que código contendo referência ao JUnit for compilado ou executado. Neste último caso, tanto o compilador Java (*javac*) quanto a máquina virtual Java (*java*) deverão ser executados com a opção *-cp* incluindo o arquivo *junit-4.4.jar*. 

= Primeiro exemplo =
Abaixo segue uma classe contendo uma única propriedade e três (3) métodos públicos. Para este exemplo didático, apenas o método {{{adiciona(int valor)}}} será testado. Conforme a implementação, após a chamada a este método o valor corrente da instância de {{{Valor}}} deve ser acrescido do valor fornecido como argumento.

{{{
package basico;

public class Valor {
    private int valor;

    public int getValor() {
        return valor;
    }

    public void setValor(int valor) {
        this.valor = valor;
    }
	
    public void adiciona(int valor) {
        this.valor += valor;
    }
}
}}}

O teste que verifica se o método {{{adiciona(int valor)}}} faz o que deveria estar fazendo é fornecido abaixo usando o JUnit. O código é simples, mas cada uma das linhas é comentada em seguida.

{{{
package basico;

import static org.junit.Assert.*;
import org.junit.Test;

public class ValorTest {

    @Test
    public void testAdiciona() {
        Valor v1 = new Valor();
	v1.setValor(1);
	Valor v2 = new Valor();
	v2.setValor(2);
	assertEquals(3,v1.getValor() + v2.getValor());
    }
}
}}}

Há duas sentenças {{{import}}}. A primeira permite o uso da chamada {{{assertEquals}}}. Há várias sobrecargas deste método estático. Neste caso, a variante contendo dois argumentos do tipo {{{int}}} é empregada. A outra sentença importa declara a anotação {{{Test}}}. É o emprego desta anotação que identifica, na classe {{{ValorTest}}}, os métodos que executam os testes de unidade. Neste caso apenas o método {{{testAdiciona()}}}. Todos os métodos de teste devem possuir esta assinatura, ou seja, devem ser públicos, retornar {{{void}}} e não recebem nenhum valor como argumento. Naturalmente, a classe {{{ValorTest}}} pode possuir muitos outros métodos sem estas restrições.

Abaixo segue apenas um trecho do código fornecido acima. Isto é feito para permitir que alguns itens sejam discutidos em detalhes.

{{{
@Test
public void testAdiciona() {
    Valor v1 = new Valor();
    v1.setValor(1);
    Valor v2 = new Valor();
    v2.setValor(2);
    assertEquals(3,v1.getValor() + v2.getValor());
}
}}}

O trecho acima inicia-se com {{{@Test}}}. Isto indica que o método que segue é um teste de unidade, qualquer que seja o nome do método. Contudo, deve ser público, retorna {{{void}}} e não recebe nenhum valor como argumento. É o conteúdo deste método que exercita o código a ser testado e, adicionalmente, verifica se o resultado obtido é o esperado. No exemplo acima, duas instâncias de {{{Valor}}} são criadas, respectivamente com o valor {{{1}}} e {{{2}}}. Em conseqüência, é esperado que a soma destes dois valores resulte em {{{3}}}, conforme o método {{{assertEquals}}}. Não faz muito sentido a execução do teste acima. Contudo, o teste do método {{{adiciona(int valor}}} já é representativa de casos típicos.

{{{
@Test
public void testAdicionaNulo() {
    Valor v = new Valor();
    assertEquals(0, v.adiciona(0));
}
}}}

Embora ainda muito simples, o teste acima verifica se a adição de zero a uma instância de {{{Valor}}}, recém-criada, produz como resultado o valor {{{0}}}.

Até agora simplemente criamos os testes, mas não foi mostrado como testá-los. O que é feito a seguir.

= Como executar os testes? =
Será necessário compilar a classe {{{Valor}}} e a classe {{{ValorTest}}}. Notou o sufixo {{{Test}}}? Não é necessário, mas uma convenção simples que pode facilitar a localização de classes de teste. Assumindo que os arquivos {{{Valor.java}}} e {{{ValorTest.java}}} estão disponíveis no diretório corrente, então o comando abaixo é suficiente para compilar tais classes.

{{{
javac *.java
}}}

Para executar os testes é necessário executar o comando seguinte

{{{
java org.junit.runner.JUnitCore basico.ValorTest
}}}

O comando acima requisita que a máquina virtual Java execute a classe {{{org.junit.runner.JUnitCore}}} com o argumento {{{basico.ValorTest}}}. Este argumento é o nome da classe que contém um ou mais testes de unidade. 

*OBSERVAÇÃO:* tanto a execução do compilador quanto da máquina virtual Java, conforme os comandos acima, só irá funcionar caso a variável *CLASSPATH* inclua o arquivo *junit-4.4.jar*. Se este não for o caso, também é possível fornecer o arquivo como argumento da opção *-cp*, conforme abaixo, assumindo que *junit-4.4.jar* está disponível no diretório *dir*.

Para compilar:
{{{
javac -cp dir/junit-4.4.jar:. *.java
}}}

Para executar:
{{{
java -cp dir/junit-4.4.jar:. org.junit.runner.JUnitCore basico.ValorTest
}}}

Nos comandos acima, tanto o compilador irá tratar o arquivo *junit-4.4.jar* como parte do _classpath_, juntamente com o diretório corrente. 

= Considerações finais =
Este breve texto introduziu elementos básicos do desenvolvimento e execução de testes de unidade empregando a ferramenta JUnit. Vários outros recursos estão disponíveis, além daqueles apresentados acima.